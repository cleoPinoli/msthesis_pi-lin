\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Product using (_×_; _,_; ∃; ∃-syntax)
open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong; cong₂)
open import Data.List.Base using (List; []; _∷_; [_]; _++_)

open import Type
open import Context
\end{code}

\subsection{Context Permutations}
\label{sec:permutations-agda}

According to our nameless representation of channels, it is the \emph{position}
of a type in a typing context $\Context$ that determines the location of its
binder in the structure of a process. When the binding structure of a process
changes, \eg because a structural pre-congruence rule is applied, or when a
channel substitution occurs, \cf the right-hand side of the \LinkRule reduction
in \Cref{tab:semantics}, the typing context must be suitably rearranged. Such
rearrangement is in fact a \emph{permutation} of the elements of $\Context$.

We define typing context permutations inductively, as a binary relation
\AgdaDatatype{\_↭\_}:

\begin{code}
data _↭_ : Context → Context → Set where
  refl   : ∀{Γ} → Γ ↭ Γ
  swap   : ∀{A B Γ} → (A ∷ B ∷ Γ) ↭ (B ∷ A ∷ Γ)
  prep   : ∀{A Γ Δ} → Γ ↭ Δ → (A ∷ Γ) ↭ (A ∷ Δ)
  trans  : ∀{Γ Δ Θ} → Γ ↭ Δ → Δ ↭ Θ → Γ ↭ Θ
\end{code}

Each constructor of \AgdaDatatype{\_↭\_} represents a particular kind of
permutation: \AgdaInductiveConstructor{refl} for the trivial permutation that
does not change anything; \AgdaInductiveConstructor{swap} for the permutation
that swaps the first two elements of a typing context;
\AgdaInductiveConstructor{prep} for the permutation applied to the tail of a
typing context; \AgdaInductiveConstructor{trans} for the sequential composition
of permutations.

The definition of the data type \AgdaDatatype{\_↭\_} is nearly the same found in
the module \AgdaModule{Data.List.Relation.Binary.Permutation.Propositional} of
Agda's standard library. We have preferred defining our own notion of
permutation for simplicity and convenience: the \AgdaInductiveConstructor{swap}
constructor does not need a sub-permutation for the tail of the typing context,
which can always be performed, if needed, combining
\AgdaInductiveConstructor{swap} with \AgdaInductiveConstructor{prep} and
\AgdaInductiveConstructor{trans}. Also, and more importantly, our data type
\AgdaDatatype{\_↭\_} is monomorphic (it does not need to relate arbitrary lists)
and the arguments $A$ and $B$ of \AgdaInductiveConstructor{swap} and
\AgdaInductiveConstructor{prep} are implicit, which streamlines the usage of
these constructors in the rest of the code.

\begin{code}[hide]
↭sym : ∀{Γ Δ} → Γ ↭ Δ → Δ ↭ Γ
↭sym refl = refl
↭sym swap = swap
↭sym (prep π) = prep (↭sym π)
↭sym (trans π π′) = trans (↭sym π′) (↭sym π)

↭empty-inv : ∀{Γ} → [] ↭ Γ → Γ ≡ []
↭empty-inv refl = refl
↭empty-inv (trans π π′) rewrite ↭empty-inv π | ↭empty-inv π′ = refl

↭solo-inv : ∀{A Γ} → [ A ] ↭ Γ → Γ ≡ [ A ]
↭solo-inv refl = refl
↭solo-inv (prep π) rewrite ↭empty-inv π = refl
↭solo-inv (trans π π′) rewrite ↭solo-inv π | ↭solo-inv π′ = refl
\end{code}

Just like permutations in Agda's standard library, also \AgdaDatatype{\_↭\_}
enjoys a number of expected properties, such as symmetry. In the following we
will make use of a specific property that relates context splitting, list
concatenation \AgdaFunction{\_++\_} and permutations: if
$\Splitting\ContextC\ContextD\ContextE$, then $\ContextC$ is a permutation of
the concatenation of $\ContextD$ and $\ContextE$.

\begin{code}[hide]
↭split : ∀{Γ Γ₁ Γ₂ Δ} → Γ ↭ Δ → Γ ≃ Γ₁ + Γ₂ → ∃[ Δ₁ ] ∃[ Δ₂ ] (Δ ≃ Δ₁ + Δ₂ × Γ₁ ↭ Δ₁ × Γ₂ ↭ Δ₂)
↭split refl p = _ , _ , p , refl , refl
↭split (prep π) (< p) with ↭split π p
... | Δ₁ , Δ₂ , q , π₁ , π₂ = _ ∷ Δ₁ , Δ₂ , < q , prep π₁ , π₂
↭split (prep π) (> p) with ↭split π p
... | Δ₁ , Δ₂ , q , π₁ , π₂ = Δ₁ , _ ∷ Δ₂ , > q , π₁ , prep π₂
↭split swap (< < p) = _ , _ , < < p , swap , refl
↭split swap (< > p) = _ , _ , > < p , refl , refl
↭split swap (> < p) = _ , _ , < > p , refl , refl
↭split swap (> > p) = _ , _ , > > p , refl , swap
↭split (trans π π′) p with ↭split π p
... | Θ₁ , Θ₂ , p′ , π₁ , π₂ with ↭split π′ p′
... | Δ₁ , Δ₂ , q , π₁′ , π₂′ = Δ₁ , Δ₂ , q , trans π₁ π₁′ , trans π₂ π₂′

↭solo : ∀{A Γ Γ′ Δ} → Γ ↭ Δ → Γ ≃ [ A ] + Γ′ → ∃[ Δ′ ] (Δ ≃ [ A ] + Δ′ × Γ′ ↭ Δ′)
↭solo π p with ↭split π p
... | _ , _ , q , π₁ , π₂ rewrite ↭solo-inv π₁ = _ , q , π₂

↭shift : ∀{A Γ Δ} → (Γ ++ A ∷ Δ) ↭ (A ∷ Γ ++ Δ)
↭shift {_} {[]} = refl
↭shift {_} {_ ∷ _} = trans (prep ↭shift) swap
\end{code}

\begin{code}
↭concat : ∀{Γ Γ₁ Γ₂} → Γ ≃ Γ₁ + Γ₂ → (Γ₁ ++ Γ₂) ↭ Γ
\end{code}
\begin{code}[hide]
↭concat • = refl
↭concat (< p) = prep (↭concat p)
↭concat (> p) = trans ↭shift (prep (↭concat p))

↭left : ∀{Γ Δ Θ} → Γ ↭ Δ → (Θ ++ Γ) ↭ (Θ ++ Δ)
↭left {Θ = []} π = π
↭left {Θ = _ ∷ _} π = prep (↭left π)

↭un : ∀{Γ Δ} → Γ ↭ Δ → Un Γ → Un Δ
↭un refl un = un
↭un (prep π) (un-∷ un) = un-∷ (↭un π un)
↭un swap (un-∷ (un-∷ un)) = un-∷ (un-∷ un)
↭un (trans π π′) un = ↭un π′ (↭un π un)
\end{code}
