\begin{code}[hide]
open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Product using (_×_; _,_; ∃; ∃-syntax)
open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong; cong₂)
open import Data.List.Base using (List; []; _∷_; [_]; _++_)

open import Type
open import Context
\end{code}

\subsection{Context Permutations}
\label{sec:permutations-agda}

According to our nameless representation of channels, it is the \emph{order} of
channels in a typing context $\Context$ that determines the binding location in
the structure of a process. When the binding structure of a process changes, \eg
because a structural pre-congruence rule is applied, or when a channel
substitution occurs, \cf the right-hand side of the \LinkRule reduction, the
typing context must be suitably rearranged. Such rearrangement is in fact a
\emph{permutation} of the elements of $\Context$.

We define typing context permutations inductively, as a binary relation
\AgdaDatatype{\_\#\_}:

\begin{code}
data _#_ : Context → Context → Set where
  #refl  : ∀{Γ} → Γ # Γ
  #here  : ∀{A B Γ} → (A ∷ B ∷ Γ) # (B ∷ A ∷ Γ)
  #next  : ∀{A Γ Δ} → Γ # Δ → (A ∷ Γ) # (A ∷ Δ)
  #tran  : ∀{Γ Δ Θ} → Γ # Δ → Δ # Θ → Γ # Θ
\end{code}

This definition is essentially the same as the notion of list permutation in
Agda's standard library. Each constructor represents a particular kind of
permutation: \AgdaInductiveConstructor{\#refl} for the trivial permutation that
does not change anything; \AgdaInductiveConstructor{\#here} for the permutation
that swaps the first two elements of a typing context;
\AgdaInductiveConstructor{\#next} for the permutation that applies a
sub-permutation to the tail of a typing context;
\AgdaInductiveConstructor{\#tran} for the sequential composition of
permutations.
%
We have preferred defining our own notion of permutation for simplicity: the
\AgdaInductiveConstructor{\#here} constructor does not need a sub-permutation
for the tail of the typing context, which can always be performed, if needed,
using \AgdaInductiveConstructor{\#next} and \AgdaInductiveConstructor{\#tran}.
Also, and more importantly, this definition is \emph{monomorphic} (it does not
need to operate on lists of arbitrary type), resulting in a more streamlined
usage in the rest of the code.

\begin{code}[hide]
#sym : ∀{Γ Δ} → Γ # Δ → Δ # Γ
#sym #refl = #refl
#sym #here = #here
#sym (#next π) = #next (#sym π)
#sym (#tran π π′) = #tran (#sym π′) (#sym π)

#empty-inv : ∀{Γ} → [] # Γ → Γ ≡ []
#empty-inv #refl = refl
#empty-inv (#tran π π′) rewrite #empty-inv π | #empty-inv π′ = refl

#singleton-inv : ∀{A Γ} → [ A ] # Γ → Γ ≡ [ A ]
#singleton-inv {Γ = Γ} #refl = refl
#singleton-inv {Γ = Γ} (#next π) rewrite #empty-inv π = refl
#singleton-inv {Γ = Γ} (#tran π π′) rewrite #singleton-inv π | #singleton-inv π′ = refl

#rot : ∀{A B C Γ} → (A ∷ B ∷ C ∷ Γ) # (C ∷ A ∷ B ∷ Γ)
#rot = #tran (#next #here) #here
\end{code}

Just like permutations from Agda's standard library, also \AgdaDatatype{\_\#\_}
enjoys a number of expected (and useful) properties, such as symmetry. Among all
properties, in the following we will make use of a specific one that connects
context splitting and permutations: if $\Context \simeq A, \ContextD$, then
$\Context$ must be a permutation of $A~\AgdaInductiveConstructor{∷}~\ContextD$.

\begin{code}
#cons : ∀{A Γ Δ} → Γ ≃ A , Δ → (A ∷ Δ) # Γ
#cons (split-l p) with +-empty-l p
... | refl = #refl
#cons (split-r p) = #tran #here (#next (#cons p))
\end{code}

\begin{code}[hide]
#split : ∀{Γ Γ₁ Γ₂ Δ} → Γ # Δ → Γ ≃ Γ₁ + Γ₂ → ∃[ Δ₁ ] ∃[ Δ₂ ] (Δ ≃ Δ₁ + Δ₂ × Γ₁ # Δ₁ × Γ₂ # Δ₂)
#split #refl p = _ , _ , p , #refl , #refl
#split (#next π) (split-l p) with #split π p
... | Δ₁ , Δ₂ , q , π₁ , π₂ = _ ∷ Δ₁ , Δ₂ , split-l q , #next π₁ , π₂
#split (#next π) (split-r p) with #split π p
... | Δ₁ , Δ₂ , q , π₁ , π₂ = Δ₁ , _ ∷ Δ₂ , split-r q , π₁ , #next π₂
#split #here (split-l (split-l p)) = _ , _ , split-l (split-l p) , #here , #refl
#split #here (split-l (split-r p)) = _ , _ , split-r (split-l p) , #refl , #refl
#split #here (split-r (split-l p)) = _ , _ , split-l (split-r p) , #refl , #refl
#split #here (split-r (split-r p)) = _ , _ , split-r (split-r p) , #refl , #here
#split (#tran π π′) p with #split π p
... | Θ₁ , Θ₂ , p′ , π₁ , π₂ with #split π′ p′
... | Δ₁ , Δ₂ , q , π₁′ , π₂′ = Δ₁ , Δ₂ , q , #tran π₁ π₁′ , #tran π₂ π₂′

#one+ : ∀{A Γ Γ′ Δ} → Γ # Δ → Γ ≃ A , Γ′ → ∃[ Δ′ ] (Δ ≃ A , Δ′ × Γ′ # Δ′)
#one+ π p with #split π p
... | _ , _ , q , π₁ , π₂ rewrite #singleton-inv π₁ = _ , q , π₂

#shift : ∀{Γ A Δ} → (Γ ++ A ∷ Δ) # (A ∷ Γ ++ Δ)
#shift {[]} = #refl
#shift {B ∷ Γ} = #tran (#next #shift) #here

+++# : ∀{Γ Γ₁ Γ₂} → Γ ≃ Γ₁ + Γ₂ → (Γ₁ ++ Γ₂) # Γ
+++# split-e = #refl
+++# (split-l p) = #next (+++# p)
+++# (split-r p) = #tran #shift (#next (+++# p))

#left : ∀{Γ Δ Θ} → Γ # Δ → (Θ ++ Γ) # (Θ ++ Δ)
#left {Θ = []} π = π
#left {Θ = _ ∷ Θ} π = #next (#left π)

#un : ∀{Γ Δ} → Γ # Δ → Un Γ → Un Δ
#un #refl un = un
#un (#next π) (un-∷ un) = un-∷ (#un π un)
#un #here (un-∷ (un-∷ un)) = un-∷ (un-∷ un)
#un (#tran π π′) un = #un π′ (#un π un)

#un+ : ∀{Γ Γ₁ Γ₂} → Γ ≃ Γ₁ + Γ₂ → Un Γ₁ → Un Γ₂ → Un Γ
#un+ split-e un-[] un-[] = un-[]
#un+ (split-l p) (un-∷ un₁) un₂ = un-∷ (#un+ p un₁ un₂)
#un+ (split-r p) un₁ (un-∷ un₂) = un-∷ (#un+ p un₁ un₂)
\end{code}
