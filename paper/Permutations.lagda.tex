\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Product using (_×_; _,_; ∃; ∃-syntax)
open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong; cong₂)
open import Data.List.Base using (List; []; _∷_; [_]; _++_)

open import Type
open import Context
\end{code}

\subsection{Context Permutations}
\label{sec:permutations-agda}

According to our nameless representation of channels, it is the \emph{order} of
channels in a typing context $\Context$ that determines the binding location in
the structure of a process. When the binding structure of a process changes, \eg
because a structural pre-congruence rule is applied, or when a channel
substitution occurs, \cf the right-hand side of the \LinkRule reduction, the
typing context must be suitably rearranged. Such rearrangement is in fact a
\emph{permutation} of the elements of $\Context$.

We define typing context permutations inductively, as a binary relation
\AgdaDatatype{\_↭\_}:

\begin{code}
data _↭_ : Context → Context → Set where
  refl   : ∀{Γ} → Γ ↭ Γ
  swap   : ∀{A B Γ} → (A ∷ B ∷ Γ) ↭ (B ∷ A ∷ Γ)
  prep   : ∀{A Γ Δ} → Γ ↭ Δ → (A ∷ Γ) ↭ (A ∷ Δ)
  trans  : ∀{Γ Δ Θ} → Γ ↭ Δ → Δ ↭ Θ → Γ ↭ Θ
\end{code}

This definition is essentially the same as the notion of list permutation in
Agda's standard library. Each constructor represents a particular kind of
permutation: \AgdaInductiveConstructor{refl} for the trivial permutation that
does not change anything; \AgdaInductiveConstructor{swap} for the permutation
that swaps the first two elements of a typing context;
\AgdaInductiveConstructor{prep} for the permutation that applies a permutation
to the tail of a typing context; \AgdaInductiveConstructor{trans} for the
sequential composition of permutations.
%
We have preferred defining our own notion of permutation for simplicity: the
\AgdaInductiveConstructor{swap} constructor does not need a sub-permutation for
the tail of the typing context, which can always be performed, if needed, using
\AgdaInductiveConstructor{prep} and \AgdaInductiveConstructor{trans}. Also, and
more importantly, this definition is \emph{monomorphic} (it does not need to
operate on lists of arbitrary type), resulting in a more streamlined usage in
the rest of the code.

\begin{code}[hide]
↭sym : ∀{Γ Δ} → Γ ↭ Δ → Δ ↭ Γ
↭sym refl = refl
↭sym swap = swap
↭sym (prep π) = prep (↭sym π)
↭sym (trans π π′) = trans (↭sym π′) (↭sym π)

↭empty-inv : ∀{Γ} → [] ↭ Γ → Γ ≡ []
↭empty-inv refl = refl
↭empty-inv (trans π π′) rewrite ↭empty-inv π | ↭empty-inv π′ = refl

↭solo-inv : ∀{A Γ} → [ A ] ↭ Γ → Γ ≡ [ A ]
↭solo-inv refl = refl
↭solo-inv (prep π) rewrite ↭empty-inv π = refl
↭solo-inv (trans π π′) rewrite ↭solo-inv π | ↭solo-inv π′ = refl

↭rot : ∀{A B C Γ} → (A ∷ B ∷ C ∷ Γ) ↭ (C ∷ A ∷ B ∷ Γ)
↭rot = trans (prep swap) swap
\end{code}

Just like permutations from Agda's standard library, also \AgdaDatatype{\_↭\_}
enjoys a number of expected (and useful) properties, such as symmetry. Among all
properties, in the following we will make use of a specific one that connects
context splitting and permutations: if $\Splitting\ContextC\ContextD\ContextE$,
then $\ContextC$ is a permutation of the concatenation of $\ContextD$ and
$\ContextE$.\Luca{Ci sono molte altre proprietà non descritte, controllare
quelle che servono davvero.}

\begin{code}[hide]
↭split : ∀{Γ Γ₁ Γ₂ Δ} → Γ ↭ Δ → Γ ≃ Γ₁ + Γ₂ → ∃[ Δ₁ ] ∃[ Δ₂ ] (Δ ≃ Δ₁ + Δ₂ × Γ₁ ↭ Δ₁ × Γ₂ ↭ Δ₂)
↭split refl p = _ , _ , p , refl , refl
↭split (prep π) (< p) with ↭split π p
... | Δ₁ , Δ₂ , q , π₁ , π₂ = _ ∷ Δ₁ , Δ₂ , < q , prep π₁ , π₂
↭split (prep π) (> p) with ↭split π p
... | Δ₁ , Δ₂ , q , π₁ , π₂ = Δ₁ , _ ∷ Δ₂ , > q , π₁ , prep π₂
↭split swap (< < p) = _ , _ , < < p , swap , refl
↭split swap (< > p) = _ , _ , > < p , refl , refl
↭split swap (> < p) = _ , _ , < > p , refl , refl
↭split swap (> > p) = _ , _ , > > p , refl , swap
↭split (trans π π′) p with ↭split π p
... | Θ₁ , Θ₂ , p′ , π₁ , π₂ with ↭split π′ p′
... | Δ₁ , Δ₂ , q , π₁′ , π₂′ = Δ₁ , Δ₂ , q , trans π₁ π₁′ , trans π₂ π₂′

↭solo : ∀{A Γ Γ′ Δ} → Γ ↭ Δ → Γ ≃ A , Γ′ → ∃[ Δ′ ] (Δ ≃ A , Δ′ × Γ′ ↭ Δ′)
↭solo π p with ↭split π p
... | _ , _ , q , π₁ , π₂ rewrite ↭solo-inv π₁ = _ , q , π₂

↭shift : ∀{A Γ Δ} → (Γ ++ A ∷ Δ) ↭ (A ∷ Γ ++ Δ)
↭shift {_} {[]} = refl
↭shift {_} {_ ∷ _} = trans (prep ↭shift) swap
\end{code}

\begin{code}
↭concat : ∀{Γ Γ₁ Γ₂} → Γ ≃ Γ₁ + Γ₂ → (Γ₁ ++ Γ₂) ↭ Γ
\end{code}
\begin{code}[hide]
↭concat • = refl
↭concat (< p) = prep (↭concat p)
↭concat (> p) = trans ↭shift (prep (↭concat p))

↭left : ∀{Γ Δ Θ} → Γ ↭ Δ → (Θ ++ Γ) ↭ (Θ ++ Δ)
↭left {Θ = []} π = π
↭left {Θ = _ ∷ _} π = prep (↭left π)

↭un : ∀{Γ Δ} → Γ ↭ Δ → Un Γ → Un Δ
↭un refl un = un
↭un (prep π) (un-∷ un) = un-∷ (↭un π un)
↭un swap (un-∷ (un-∷ un)) = un-∷ (un-∷ un)
↭un (trans π π′) un = ↭un π′ (↭un π un)
\end{code}
