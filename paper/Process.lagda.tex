\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Unit using (tt)
open import Data.Sum
open import Data.Product using (_,_)
open import Data.List.Base using ([]; _‚à∑_; [_])
open import Relation.Unary

open import Type
open import Context
open import Permutations
\end{code}

\subsection{Channel and Process Representation}
\label{sec:process-agda}

We adopt an \emph{intrinsically-typed} representation of processes with
\emph{nameless} channels. The intrinsically-typed representation makes sure that
only well-typed processes can be constructed. This choice increases the effort
in the definition of the datatypes for representing processes and their
operational semantics, but pays off in the rest of the formalisation for at
least three reasons:
\begin{itemize}
\item we need not give explicit names to channels, thus we avoid all the
  technicalities and pitfalls that a named representation entails;
\item we conflate processes and typing rules in the same datatype, thus reducing
  the overall number of datatypes defined in the formalisation;
\item the typing preservation results are embedded in the very definition of the
  operational semantics of processes and need not require separate proofs
  (\Cref{sec:congruence-agda,sec:reduction-agda}).
\end{itemize}

Channels are not given any name. Instead, they are represented as terms
witnessing that their type is present in the typing context. This is known as
\emph{co-de Bruijn syntax}~\cite{McBride18}, according to which the typing
context associated with a term (a process, a channel) only contains the types of
the channels that actually occur within the term. For this reason, typing
contexts are split eagerly, according to the structure of processes, to make
sure that channels are appropriately (and above all linearly) distributed among
sub-processes, so that each channel occurs (and is used) exactly
once.\footnote{Strictly speaking, the typing context of a
\AgdaInductiveConstructor{fail} process may contain channels that do not occur
(and therefore are not used) by the process, but we consider this case as an
exception that does not alter in a substantial way the provided intuition
underlying the use of co-de Bruijn representation.}
%
Concretely, a channel of type $A$ is a predicate that holds for the singleton
context $\AgdaFunction[~A~\AgdaFunction]$:

\begin{code}
data Ch (A : Type) : Context ‚Üí Set where
  ch : Ch A [ A ]
\end{code}

A process that is well typed in a typing context $\Context$ is a predicate that
holds for $\Context$. Here is the datatype \AgdaDatatype{Proc} for representing
processes:

\begin{code}
data Proc : Context ‚Üí Set where
  link      : ‚àÄ{A} ‚Üí ‚àÄ[ Ch A ‚àó Ch (dual A) ‚áí Proc ]
  fail      : ‚àÄ[ Ch ‚ä§ ‚àó U ‚áí Proc ]
  wait      : ‚àÄ[ Ch ‚ä• ‚àó Proc ‚áí Proc ]
  close     : ‚àÄ[ Ch ùüô ‚áí Proc ]
  case      : ‚àÄ{A B} ‚Üí
              ‚àÄ[ Ch (A & B) ‚àó ((A ‚à∑_) ‚ä¢ Proc ‚à© (B ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  select    : ‚àÄ{A B} ‚Üí
              ‚àÄ[ Ch (A ‚äï B) ‚àó ((A ‚à∑_) ‚ä¢ Proc ‚à™ (B ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  join      : ‚àÄ{A B} ‚Üí ‚àÄ[ Ch (A ‚Öã B) ‚àó ((A ‚à∑_) ‚ä¢ (B ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  fork      : ‚àÄ{A B} ‚Üí
              ‚àÄ[ Ch (A ‚äó B) ‚àó ((A ‚à∑_) ‚ä¢ Proc) ‚àó ((B ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  all       : ‚àÄ{A} ‚Üí
              ‚àÄ[ Ch (`‚àÄ A) ‚àó ‚ãÇ[ X ‚à∂ Type ] ((subst [ X /] A ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  ex        : ‚àÄ{A B} ‚Üí ‚àÄ[ Ch (`‚àÉ A) ‚àó ((subst [ B /] A ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  server    : ‚àÄ{A} ‚Üí ‚àÄ[ Ch (`! A) ‚àó (Un ‚à© ((A ‚à∑_) ‚ä¢ Proc)) ‚áí Proc ]
  client    : ‚àÄ{A} ‚Üí ‚àÄ[ Ch (`? A) ‚àó ((A ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  weaken    : ‚àÄ{A} ‚Üí ‚àÄ[ Ch (`? A) ‚àó Proc ‚áí Proc ]
  contract  : ‚àÄ{A} ‚Üí ‚àÄ[ Ch (`? A) ‚àó ((`? A ‚à∑_) ‚ä¢ (`? A ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  cut       : ‚àÄ{A} ‚Üí ‚àÄ[ ((A ‚à∑_) ‚ä¢ Proc) ‚àó ((dual A ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
\end{code}

The constructor \AgdaInductiveConstructor{link} models a process of the form
$\Link\x\y$. This process is well typed in a context of the form $x : A, y :
\dual{A}$, namely a context satisfying the predicate
$\AgdaDatatype{Ch}~A~\AgdaDatatype{‚àó}~\AgdaDatatype{Ch}~(\AgdaFunction{dual}~A)$
which we see on the left-hand side of \AgdaFunction{‚áí}.
%
The constructor \AgdaInductiveConstructor{cut} models a cut $\Cut[A]\x{P}{Q}$.
For this process to be well typed in a context $\Context$, it must be the case
that $\Splitting\Context\ContextD\ContextE$ so that $P$ and $Q$ are well typed
in the contexts $x : A, \ContextD$ and $x : \dual{A}, \ContextE$ respectively.
Since $x$ is the most recently introduced channel, the types $A$ and $\dual{A}$
must be added \emph{at the front} of $\ContextD$ and $\ContextE$, which we do by
means of the functions $(A~\AgdaInductiveConstructor{‚à∑\_})$ and
$(\AgdaFunction{dual}~A~\AgdaInductiveConstructor{‚à∑\_})$ (these are partial
applications of the constructor $\AgdaInductiveConstructor{\_‚à∑\_}$ for lists to
which we have supplied the left operand).

All the remaining constructors basically follow the same pattern: they possibly
quantify over some types $A$ and $B$ and then (implicitly) over a typing context
$\Context$ through the function \AgdaFunction{‚àÄ[\_]} applied to a predicate of
the form $P~\AgdaFunction{‚áí}~\AgdaDatatype{Proc}$. The predicate states how to
build a process that is well typed in $\Context$, provided that $\Context$
satisfies $P$. In general, $P$ is a (separating) conjunction of sub-predicates
corresponding to the channel on which the process is acting and to the premises
of its typing rule.

For example, the constructor \AgdaInductiveConstructor{fail}, which corresponds
to a process of the form $\Fail\x$, requires the context $\Context$ to satisfy
the predicate
$\AgdaDatatype{Ch}~\AgdaInductiveConstructor{‚ä§}~\AgdaDatatype{‚àó}~\AgdaFunction{U}$,
meaning that $\Context$ must contain an entry \AgdaInductiveConstructor{‚ä§}
(\AgdaFunction{U} is the universal predicate that holds for every context, \cf
\Cref{tab:predicates}). That form of $\Context$ matches the one in the
conclusion of \FailRule.

The constructor \AgdaInductiveConstructor{wait} corresponds to a process of the
form $\Wait\x.P$ and requires $\Context$ to (separately) satisfy
$\AgdaDatatype{Ch}~\AgdaInductiveConstructor{‚ä•}$, that is the channel $x$ on
which the process is operating, as well as \AgdaDatatype{Proc}, that is the
continuation process $P$, which must be well typed in the remaining typing
context.

The constructor \AgdaInductiveConstructor{close}, which corresponds to a process
of the form $\Close\x$, requires the typing context to be the singleton list
$[\One]$.

Let us move on to the processes that produce a continuation channel. For
example, the constructor \AgdaInductiveConstructor{case} corresponds to a
process of the form $\Case\x\y{P}{Q}$, where both $P$ and $Q$ may use the
continuation channel $y$. In this case $\Context$ must satisfy the predicate
\[
  \AgdaDatatype{Ch}~(A~\AgdaInductiveConstructor{\&}~B)~\AgdaDatatype{‚àó}~((A~\AgdaInductiveConstructor{‚à∑\_})~\AgdaFunction{‚ä¢}~\AgdaDatatype{Proc}~\AgdaFunction{‚à©}~(B~\AgdaInductiveConstructor{‚à∑\_})~\AgdaFunction{‚ä¢}~\AgdaDatatype{Proc})
\]
which looks intimidating at first but makes perfect sense once we recall the
typing rule \CaseRule and the definitions of \AgdaFunction{‚à©} and
\AgdaFunction{‚ä¢} in \Cref{tab:predicates}. Remember that we are trying to
establish whether $\Case\x\y{P}{Q}$ is well typed in $\Context$.
%
The predicate $\AgdaDatatype{Ch}~(A~\AgdaInductiveConstructor{\&}~B)$ expresses
the requirement that the type of $x$ must be of the form $A \With B$ and should
be found in $\Context$. In other words, it must be the case that
$\Splitting\Context{[A \With B]}\ContextD$ for some $\ContextD$. Now $P$ and $Q$
must be well typed in the context $\ContextD$ augmented with the association $y
: A$ and $y : B$, respectively, whence the use of \AgdaFunction{‚à©} to verify a
(non-separating) conjunction of the predicates
$(A~\AgdaInductiveConstructor{‚à∑\_})~\AgdaFunction{‚ä¢}~\AgdaDatatype{Proc}$ and
$(B~\AgdaInductiveConstructor{‚à∑\_})~\AgdaFunction{‚ä¢}~\AgdaDatatype{Proc}$. The
two new contexts are obtained by \emph{adding} either $A$ or $B$ to $\ContextD$,
which we perform using \AgdaFunction{‚ä¢}.
%
Crucially, the types $A$ and $B$ are \emph{prepended} to $\ContextD$, which is
consistent with the fact that the continuation $y$ has been freshly introduced
and the channel $x$ has been consumed. Notice how easy it is to \emph{prepend}
either $A$ or $B$ to $\ContextD$ instead of \emph{changing} the type of $x$ in
$\Context$ from $A \With B$ to either $A$ or $B$ while preserving the position
of the type, as we would have to do in a ``true'' session type system without
explicit continuation channels.

The interpretation of the remaining constructors is analogous, so we only
comment \AgdaInductiveConstructor{all}, which represents a polymorphic process
$\Forall\x\X\y.P$. This constructor models the continuation $P$ using
higher-order abstract syntax: witnessing that a context $\Context$ satisfies the
predicate
\[
  \AgdaFunction{‚ãÇ[}~X~\AgdaFunction{‚à∂}~\AgdaDatatype{Type}~\AgdaFunction]~((\AgdaFunction{subst~[}~X~\AgdaFunction{/]}~A~\AgdaInductiveConstructor{‚à∑\_})~\AgdaFunction{‚ä¢}~\AgdaDatatype{Proc}
\]
means providing a function that, for every type $X$, produces a witness for the
predicate
\[
  ((\AgdaFunction{subst~[}~X~\AgdaFunction{/]}~A~\AgdaInductiveConstructor{‚à∑\_})~\AgdaFunction{‚ä¢}~\AgdaDatatype{Proc}
\]
applied to $\Context$. Note that the side condition $X \not\in \fv\Context$ of
\ForallRule is enforced \emph{by definition}:
%
$A$ has type $\AgdaDatatype{PreType}~\AgdaInductiveConstructor{1}$, that is a
pre-type with \emph{at most one} free type variable ($X$), whereas $\Context$ is
a typing context, that is a list of $\AgdaDatatype{Type} =
\AgdaDatatype{PreType}~\AgdaInductiveConstructor{0}$ without free type
variables. Therefore, $X$ cannot occur in $\Context$.

We conclude this module proving that permutations preserve process typing. Since
list permutations basically correspond to channel renaming, we can read this
property as the fact that typing is preserved by (injective) name
substitutions.\Luca{Da qualche parte mettere un remark per far notare che l'uso
della separating conjunction introduce rumore, ma avere i costruttori
currificati ne complica un po' l'interpretazione dei tipi. Forse √® meglio fare
questo rilievo nella prossima sezione quando √® evidente il pattern matching che
serve per esprimere le regole.}

\begin{code}
‚Ü≠proc : ‚àÄ{Œì Œî} ‚Üí Œì ‚Ü≠ Œî ‚Üí Proc Œì ‚Üí Proc Œî
\end{code}
\begin{code}[hide]
‚Ü≠proc œÄ (link (ch ‚ü® p ‚ü© ch)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' rewrite ‚Ü≠solo-inv œÄ' = link (ch ‚ü® q ‚ü© ch)
‚Ü≠proc œÄ (fail (ch ‚ü® p ‚ü© tt)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = fail (ch ‚ü® q ‚ü© tt)
‚Ü≠proc œÄ (wait (ch ‚ü® p ‚ü© P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = wait (ch ‚ü® q ‚ü© ‚Ü≠proc œÄ' P)
‚Ü≠proc œÄ (close ch) rewrite ‚Ü≠solo-inv œÄ = close ch
‚Ü≠proc œÄ (case (ch ‚ü® p ‚ü© (P , Q))) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = case (ch ‚ü® q ‚ü© (‚Ü≠proc (prep œÄ') P , ‚Ü≠proc (prep œÄ') Q))
‚Ü≠proc œÄ (select (ch ‚ü® p ‚ü© inj‚ÇÅ P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = select (ch ‚ü® q ‚ü© inj‚ÇÅ (‚Ü≠proc (prep œÄ') P))
‚Ü≠proc œÄ (select (ch ‚ü® p ‚ü© inj‚ÇÇ P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = select (ch ‚ü® q ‚ü© inj‚ÇÇ (‚Ü≠proc (prep œÄ') P))
‚Ü≠proc œÄ (join (ch ‚ü® p ‚ü© P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = join (ch ‚ü® q ‚ü© ‚Ü≠proc (prep (prep œÄ')) P)
‚Ü≠proc œÄ (fork (ch ‚ü® p ‚ü© (P ‚ü® q ‚ü© Q))) with ‚Ü≠solo œÄ p
... | _ , p' , œÄ' with ‚Ü≠split œÄ' q
... | Œî‚ÇÅ , Œî‚ÇÇ , q' , œÄ‚ÇÅ , œÄ‚ÇÇ = fork (ch ‚ü® p' ‚ü© (‚Ü≠proc (prep œÄ‚ÇÅ) P ‚ü® q' ‚ü© ‚Ü≠proc (prep œÄ‚ÇÇ) Q))
‚Ü≠proc œÄ (all (ch ‚ü® p ‚ü© F)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = all (ch ‚ü® q ‚ü© Œª X ‚Üí ‚Ü≠proc (prep œÄ') (F X))
‚Ü≠proc œÄ (ex (ch ‚ü® p ‚ü© P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = ex (ch ‚ü® q ‚ü© ‚Ü≠proc (prep œÄ') P)
‚Ü≠proc œÄ (server (ch ‚ü® p ‚ü© (un , P))) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = server (ch ‚ü® q ‚ü© (‚Ü≠un œÄ' un , ‚Ü≠proc (prep œÄ') P))
‚Ü≠proc œÄ (client (ch ‚ü® p ‚ü© P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = client (ch ‚ü® q ‚ü© ‚Ü≠proc (prep œÄ') P)
‚Ü≠proc œÄ (weaken (ch ‚ü® p ‚ü© P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = weaken (ch ‚ü® q ‚ü© ‚Ü≠proc œÄ' P)
‚Ü≠proc œÄ (contract (ch ‚ü® p ‚ü© P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = contract (ch ‚ü® q ‚ü© ‚Ü≠proc (prep (prep œÄ')) P)
‚Ü≠proc œÄ (cut (P ‚ü® p ‚ü© Q)) with ‚Ü≠split œÄ p
... | Œî‚ÇÅ , Œî‚ÇÇ , q , œÄ‚ÇÅ , œÄ‚ÇÇ = cut (‚Ü≠proc (prep œÄ‚ÇÅ) P ‚ü® q ‚ü© ‚Ü≠proc (prep œÄ‚ÇÇ) Q)
\end{code}
