\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Product using (_Ã—_; _,_; âˆƒ; âˆƒ-syntax)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; cong; congâ‚‚)
open import Data.List.Base using (List; []; _âˆ·_; [_]; _++_)

open import Type
open import Context
open import Permutations
\end{code}

\subsection{Process Representation}
\label{sec:process-agda}

CO-DE BRUIJN INDICES

We adopt a \emph{nameless, intrinsically typed} representation of processes,
that is: a channel is identified simply by the presence of its type in the
typing context; a process is also a proof derivation showing that the process is
well typed. This choice increases the effort in the definition of the datatypes
for processes and their operational semantics, but pays off in the rest of the
formalization for a number of reasons:
\begin{itemize}
\item we use context splitting not only to separate resources used by parallel
  processes (\cf \ForkRule and \CutRule), but also to witness that a channel is
  present in the typing context;
\item we conflate processes and typing rules in the same datatype, thus reducing
  the overall number of datatypes defined in the formalization;
\item we embed the typing preservation results within the very definition of the
  operational semantics of processes instead of proving them separately
  (\Cref{sec:agda-semantics}).
\end{itemize}

Our nameless modeling of channels is known in the literature as the \emph{co-de
Bruijn} representation~\cite{McBride18}. The proof that the type of a channel is
found within a typing context essentially encodes the de Bruijn index of the
channel in the typing context of a given process. However, the typing context
only contains types for those channels that actually occur in the process.
Context splitting makes sure that channels are appropriately (and above all
linearly) distributed among sub-processes, so that each channel occurs (and is
used) exactly once.\footnote{Strictly speaking, the typing context of a
\AgdaInductiveConstructor{fail} process may contain channels that do not occur
(and therefore are not used) by the process, but we consider this case as an
exception that does not alter in a substantial way the provided intuition
underlying the use of co-de Bruijn representation.}

We now illustrate the definition of the \AgdaDatatype{Process} datatype and
describe its key aspects in detail. The datatype is indexed by a typing context:

\begin{code}
data Process : Context â†’ Set where
  link      : âˆ€{A Î“} â†’ Î“ â‰ƒ A , [ dual A ] â†’ Process Î“
  fail      : âˆ€{Î“ Î”} â†’ Î“ â‰ƒ âŠ¤ , Î” â†’ Process Î“
  wait      : âˆ€{Î“ Î”} â†’ Î“ â‰ƒ âŠ¥ , Î” â†’ Process Î” â†’ Process Î“
  close     : Process [ ğŸ™ ]
  case      : âˆ€{A B Î“ Î”} â†’ Î“ â‰ƒ A & B , Î” â†’
              Process (A âˆ· Î”) â†’ Process (B âˆ· Î”) â†’ Process Î“
  select    : âˆ€{A B Î“ Î”} (x : Bool) â†’ Î“ â‰ƒ A âŠ• B , Î” â†’
              Process ((if x then A else B) âˆ· Î”) â†’ Process Î“
  join      : âˆ€{A B Î“ Î”} â†’ Î“ â‰ƒ A â…‹ B , Î” â†’ Process (B âˆ· A âˆ· Î”) â†’ Process Î“
  fork      : âˆ€{A B Î“ Î” Î“â‚ Î“â‚‚} â†’ Î“ â‰ƒ A âŠ— B , Î” â†’ Î” â‰ƒ Î“â‚ + Î“â‚‚ â†’
              Process (A âˆ· Î“â‚) â†’ Process (B âˆ· Î“â‚‚) â†’ Process Î“
  all       : âˆ€{A Î“ Î”} â†’ Î“ â‰ƒ `âˆ€ A , Î” â†’
              ((B : Type) â†’ Process (subst [ B /_] A âˆ· Î”)) â†’ Process Î“
  ex        : âˆ€{A B Î“ Î”} â†’ Î“ â‰ƒ `âˆƒ A , Î” â†’ Process (subst [ B /_] A âˆ· Î”) â†’ Process Î“
  server    : âˆ€{A Î“ Î”} â†’ Î“ â‰ƒ `! A , Î” â†’ Un Î” â†’ Process (A âˆ· Î”) â†’ Process Î“
  client    : âˆ€{A Î“ Î”} â†’ Î“ â‰ƒ `? A , Î” â†’ Process (A âˆ· Î”) â†’ Process Î“
  weaken    : âˆ€{A Î“ Î”} â†’ Î“ â‰ƒ `? A , Î” â†’ Process Î” â†’ Process Î“
  contract  : âˆ€{A Î“ Î”} â†’ Î“ â‰ƒ `? A , Î” â†’ Process (`? A âˆ· `? A âˆ· Î”) â†’ Process Î“
  cut       : âˆ€{A Î“ Î“â‚ Î“â‚‚} â†’ Î“ â‰ƒ Î“â‚ + Î“â‚‚ â†’
              Process (A âˆ· Î“â‚) â†’ Process (dual A âˆ· Î“â‚‚) â†’ Process Î“
\end{code}

A \AgdaInductiveConstructor{link} process is well typed in a typing context with
exactly two types $A$ and $B$ which must be related by duality. We use a proof
$p$ that $\Context \simeq [A] + [B]$ instead of requiring $\Context$ to be
simply $[A,B]$ so that it becomes straightforward to define \SLink using
\AgdaFunction{dual-symm} and \AgdaFunction{+-comm}.

% \begin{code}
%    fail      : âˆ€{Î“ Î”} (p : Î“ â‰ƒ âŠ¤ , Î”) â†’ Process Î“
% \end{code}

A \AgdaInductiveConstructor{fail} process simply requires the presence of $\Top$
in the typing context.

% \begin{code}
%    close     : Process  [ ğŸ™ ]
% \end{code}

A \AgdaInductiveConstructor{close} process is well typed in the singleton
context $[\One]$.

% \begin{code}
%    wait      : âˆ€{Î“ Î”} (p : Î“ â‰ƒ âŠ¥ , Î”) â†’ Process Î” â†’ Process Î“
% \end{code}

A \AgdaInductiveConstructor{wait} process is well typed in any context
$\ContextC$ that contains $\Bot$ and whose residual $\ContextD$ allows the
continuation to be well typed.

% \begin{code}
%    select    : âˆ€{A B Î“ Î”} (x : Bool) (p : Î“ â‰ƒ A âŠ• B , Î”) â†’
%                Process ((if x then A else B) âˆ· Î”) â†’ Process Î“
% \end{code}

We represent the tags $\InTag_1$ and $\InTag_2$ with Agda's boolean values
\AgdaInductiveConstructor{true} and \AgdaInductiveConstructor{false}. In this
way we can use a single constructor \AgdaInductiveConstructor{select} for the
selections $\Select\x{\InTag_i}.P$. According to the semantics of \Calculus, the
channel on which the selection is performed is consumed and the continuation
process uses a fresh continuation channel. As a consequence, the type of the
continuation channel, which is either $A$ or $B$ depending on the value of the
tag $x$, is \emph{prepended} in front of the typing context used to type the
continuation process.

% \begin{code}
%    case      : âˆ€{A B Î“ Î”} (p : Î“ â‰ƒ A & B , Î”) â†’
%                Process (A âˆ· Î”) â†’ Process (B âˆ· Î”) â†’ Process Î“
% \end{code}

A \AgdaInductiveConstructor{case} process has two possible continuations. Note
again that the continuation channel, which is received along with the tag, has
either type $A$ or type $B$ depending on the tag and its type is prepended to
the typing context of the continuation process since it is the newest channel.

% \begin{code}
%    fork      : âˆ€{A B Î“ Î” Î“â‚ Î“â‚‚} (p : Î“ â‰ƒ A âŠ— B , Î”) (q : Î” â‰ƒ Î“â‚ + Î“â‚‚) â†’
%                Process (A âˆ· Î“â‚) â†’ Process (B âˆ· Î“â‚‚) â†’ Process Î“
% \end{code}

A \AgdaInductiveConstructor{fork} process creates two fresh continuation
channels and spaws two continuation processes. Since context splitting is a
ternary relation, we need two splitting proofs $p$ and $q$ to isolate the type
$A \Ten B$ of channel on which the pair of continuation channels is sent and to
distribute the remaining channel across the two continuation processes.

% \begin{code}
%    join      : âˆ€{A B Î“ Î”} (p : Î“ â‰ƒ A â…‹ B , Î”) â†’ Process (B âˆ· A âˆ· Î”) â†’
%                Process Î“
% \end{code}

The \AgdaInductiveConstructor{join} process has a single continuation which uses
the pair of continuation channels received from a channel of type $A \Par B$.
Note that $B$ is prepended in front of $A$, somewhat implying that the second
continuation is bound \emph{after} the first even though, from a technical
standpoint, both continuations are bound simultaneously. We could have prepended
the types $A$ and $B$ also in the opposite order, provided that the reduction
rule \RFork (formalized in \Cref{sec:reduction-agda}) is suitably adjusted.

% \begin{code}
%    server    : âˆ€{A Î“ Î”} (p : Î“ â‰ƒ `! A , Î”) (un : Un Î”) â†’
%                Process (A âˆ· Î”) â†’ Process Î“
% \end{code}

A \AgdaInductiveConstructor{server} constructor introduces a channel of type
$\OfCourse A$ given a continuation process that consumes a channel of type $A$
and a proof $\mathit{un}$ that every other channel in $\ContextD$ is
unrestricted.\Luca{Introdurre terminologia e dire che unrestricted vuol dire che
il canale puÃ² essere ``duplicato'' e scartato.}

% \begin{code}
%    client    : âˆ€{A Î“ Î”} (p : Î“ â‰ƒ `? A , Î”) â†’ Process (A âˆ· Î”) â†’ Process Î“
%    weaken    : âˆ€{A Î“ Î”} (p : Î“ â‰ƒ `? A , Î”) â†’ Process Î” â†’ Process Î“
%    contract  : âˆ€{A Î“ Î”} (p : Î“ â‰ƒ `? A , Î”) â†’ Process (`? A âˆ· `? A âˆ· Î”) â†’
%                Process Î“
% \end{code}

The constructors \AgdaInductiveConstructor{client},
\AgdaInductiveConstructor{weaken} and \AgdaInductiveConstructor{contract}
introduce a channel of type $\WhyNot A$ and follow the same pattern of the
previous process forms. Note that, in the case of
\AgdaInductiveConstructor{contract}, the contraction of $\WhyNot A$ applies to
the first two channels in the typing context of the continuation. This is
consistent with the fact that \Calculus uses an explicit prefix
$\Contract\x\y\z$ that models contraction and binds $y$ and $z$ in the
continuation process. In a pen-and-paper presentation, like the one by
Wadler~\citep{Wadler14}, it is arguably more convenient to have weaking and
contraction typing rules without the corresponding process forms.

% \begin{code}
%    cut       : âˆ€{A Î“ Î“â‚ Î“â‚‚} (p : Î“ â‰ƒ Î“â‚ + Î“â‚‚) â†’
%                Process (A âˆ· Î“â‚) â†’ Process (dual A âˆ· Î“â‚‚) â†’ Process Î“

%    all       : âˆ€{A Î“ Î”} (p : Î“ â‰ƒ `âˆ€ A , Î”) â†’
%                ((B : Type) â†’ Process (subst [ B /_] A âˆ· Î”)) â†’ Process Î“
%    ex        : âˆ€{A B Î“ Î”} (p : Î“ â‰ƒ `âˆƒ A , Î”) â†’
%                Process (subst [ B /_] A âˆ· Î”) â†’ Process Î“
% \end{code}

A \AgdaInductiveConstructor{cut} process incorporates a duality proof for the
peer endpoints of the channel being restricted and a splitting proof that
distributes the free channels among the two parallel processes.

Permutations preserve process typeability. In a sense we can read this property
as the fact that we can rename channels at will.

\begin{code}
â†­process : âˆ€{Î“ Î”} â†’ Î“ â†­ Î” â†’ Process Î“ â†’ Process Î”
\end{code}
\begin{code}[hide]
â†­process Ï€ (link p) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² rewrite â†­solo-inv Ï€â€² = link q
â†­process Ï€ (fail p) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = fail q
â†­process Ï€ (wait p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = wait q (â†­process Ï€â€² P)
â†­process Ï€ close rewrite â†­solo-inv Ï€ = close
â†­process Ï€ (case p P Q) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = case q (â†­process (prep Ï€â€²) P) (â†­process (prep Ï€â€²) Q)
â†­process Ï€ (select x p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = select x q (â†­process (prep Ï€â€²) P)
â†­process Ï€ (join p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = join q (â†­process (prep (prep Ï€â€²)) P)
â†­process Ï€ (fork p q P Q) with â†­solo Ï€ p
... | Î”â€² , pâ€² , Ï€â€² with â†­split Ï€â€² q
... | Î”â‚ , Î”â‚‚ , qâ€² , Ï€â‚ , Ï€â‚‚ = fork pâ€² qâ€² (â†­process (prep Ï€â‚) P) (â†­process (prep Ï€â‚‚) Q)
â†­process Ï€ (all p P) with â†­solo Ï€ p
... | Î”' , q , Ï€' = all q Î» B â†’ â†­process (prep Ï€') (P B)
â†­process Ï€ (ex p P) with â†­solo Ï€ p
... | Î”' , q , Ï€' = ex q (â†­process (prep Ï€') P)
â†­process Ï€ (server p un P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = server q (â†­un Ï€â€² un) (â†­process (prep Ï€â€²) P)
â†­process Ï€ (client p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = client q (â†­process (prep Ï€â€²) P)
â†­process Ï€ (weaken p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = weaken q (â†­process Ï€â€² P)
â†­process Ï€ (contract p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = contract q (â†­process (prep (prep Ï€â€²)) P)
â†­process Ï€ (cut p P Q) with â†­split Ï€ p
... | Î”â‚ , Î”â‚‚ , q , Ï€â‚ , Ï€â‚‚ = cut q (â†­process (prep Ï€â‚) P) (â†­process (prep Ï€â‚‚) Q)
\end{code}
