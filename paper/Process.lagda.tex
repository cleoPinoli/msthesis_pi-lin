\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Unit using (tt)
open import Data.Sum
open import Data.Product using (_,_)
open import Data.List.Base using ([]; _‚à∑_; [_])
open import Relation.Unary

open import Type
open import Context
open import Permutations
\end{code}

\subsection{Channel and Process Representation}
\label{sec:process-agda}

We adopt an \emph{intrinsically-typed} representation of processes with
\emph{nameless} channels. The intrinsically-typed representation makes sure that
only well-typed processes can be constructed. This choice increases the effort
in the definition of the datatypes for representing processes and their
operational semantics, but pays off in the rest of the formalization for at
least three reasons:
\begin{itemize}
\item we need not give explicit names to channels, thus we avoid all the
  technicalities and pitfalls that a named representation entails;
\item we conflate processes and typing rules in the same datatype, thus reducing
  the overall number of datatypes defined in the formalization;
\item the typing preservation results are embedded in the very definition of the
  operational semantics of processes and need not require separate proofs
  (\Cref{sec:agda-semantics}).
\end{itemize}

Channels are not given any name. Instead, they are represented as terms
witnessing that their type is present in the typing context. This is known as
\emph{co-de Bruijn syntax}~\cite{McBride18}, according to which the typing
context associated with a term (a process, a channel) only contains the types of
the channels that actually occur within the term. For this reason, typing
contexts are split as soon as possible, according to the structure of processes,
to make sure that channels are appropriately (and above all linearly)
distributed among sub-processes, so that each channel occurs (and is used)
exactly once.\footnote{Strictly speaking, the typing context of a
\AgdaInductiveConstructor{fail} process may contain channels that do not occur
(and therefore are not used) by the process, but we consider this case as an
exception that does not alter in a substantial way the provided intuition
underlying the use of co-de Bruijn representation.}
%
Concretely, a channel of type $A$ is a predicate that holds for the singleton
context $\AgdaFunction[~A~\AgdaFunction]$:

\begin{code}
data Ch (A : Type) : Context ‚Üí Set where
  ch : Ch A [ A ]
\end{code}

A process that is well typed in a typing context $\Context$ is a predicate that
holds for $\Context$. Here is the datatype \AgdaDatatype{Proc} for representing
processes:

\begin{code}
data Proc : Context ‚Üí Set where
  link      : ‚àÄ{A} ‚Üí ‚àÄ[ Ch A ‚àó Ch (dual A) ‚áí Proc ]
  fail      : ‚àÄ[ Ch ‚ä§ ‚àó U ‚áí Proc ]
  wait      : ‚àÄ[ Ch ‚ä• ‚àó Proc ‚áí Proc ]
  close     : ‚àÄ[ Ch ùüô ‚áí Proc ]
  case      : ‚àÄ{A B} ‚Üí
              ‚àÄ[ Ch (A & B) ‚àó ((A ‚à∑_) ‚ä¢ Proc ‚à© (B ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  select    : ‚àÄ{A B} ‚Üí
              ‚àÄ[ Ch (A ‚äï B) ‚àó ((A ‚à∑_) ‚ä¢ Proc ‚à™ (B ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  join      : ‚àÄ{A B} ‚Üí ‚àÄ[ Ch (A ‚Öã B) ‚àó ((A ‚à∑_) ‚ä¢ (B ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  fork      : ‚àÄ{A B} ‚Üí
              ‚àÄ[ Ch (A ‚äó B) ‚àó ((A ‚à∑_) ‚ä¢ Proc) ‚àó ((B ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  all       : ‚àÄ{A} ‚Üí
              ‚àÄ[ Ch (`‚àÄ A) ‚àó ‚ãÇ[ X ‚à∂ Type ] ((subst [ X /_] A ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  ex        : ‚àÄ{A B} ‚Üí ‚àÄ[ Ch (`‚àÉ A) ‚àó ((subst [ B /_] A ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  server    : ‚àÄ{A} ‚Üí ‚àÄ[ Ch (`! A) ‚àó (Un ‚à© ((A ‚à∑_) ‚ä¢ Proc)) ‚áí Proc ]
  client    : ‚àÄ{A} ‚Üí ‚àÄ[ Ch (`? A) ‚àó ((A ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  weaken    : ‚àÄ{A} ‚Üí ‚àÄ[ Ch (`? A) ‚àó Proc ‚áí Proc ]
  contract  : ‚àÄ{A} ‚Üí ‚àÄ[ Ch (`? A) ‚àó ((`? A ‚à∑_) ‚ä¢ (`? A ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
  cut       : ‚àÄ{A} ‚Üí ‚àÄ[ ((A ‚à∑_) ‚ä¢ Proc) ‚àó ((dual A ‚à∑_) ‚ä¢ Proc) ‚áí Proc ]
\end{code}

All the constructors representing input/output actions, namely those from
\AgdaInductiveConstructor{fail} through \AgdaInductiveConstructor{contract},
basically follow the same pattern: they possibly quantify over some types $A$
and $B$ and then (implicitly) over a typing context $\Context$ through the
function \AgdaFunction{‚àÄ[\_]} applied to a predicate of the form
$P~\AgdaFunction{‚áí}~\AgdaDatatype{Proc}$. The predicate states how to build a
process that is well typed in $\Context$, provided that $\Context$ satisfies
$P$. In general, $P$ is a (separating) conjunction of sub-predicates
corresponding to the channel on which the process is acting and to the premises
of its typing rule.

For example, the constructor \AgdaInductiveConstructor{fail}, which corresponds
to a process of the form $\Fail\x$, requires the context $\Context$ to satisfy
the predicate
$\AgdaDatatype{Ch}~\AgdaInductiveConstructor{‚ä§}~\AgdaDatatype{‚àó}~\AgdaFunction{U}$,
meaning that $\Context$ must contain an entry \AgdaInductiveConstructor{‚ä§}. That
form of $\Context$ matches the one in the conclusion of \FailRule.

The constructor \AgdaInductiveConstructor{wait} corresponds to a process of the
form $\Wait\x.P$ and requires $\Context$ to (separately) satisfy
$\AgdaDatatype{Ch}~\AgdaInductiveConstructor{‚ä•}$, that is the channel $x$ on
which the process is operating, as well as \AgdaDatatype{Proc}, that is the
continuation process $P$, which must be well typed in the remaining typing
context.

The constructor \AgdaInductiveConstructor{close}, which corresponds to a process
of the form $\Close\x$, requires the typing context to be the singleton list
$[\One]$.

Let us move on to the processes that produce a continuation channel. For
example, the constructor \AgdaInductiveConstructor{case} corresponds to a
process of the form $\Case\x\y{P}{Q}$, where both $P$ and $Q$ may use the
continuation channel $y$. In this case $\Context$ must satisfy the predicate
\[
  \AgdaDatatype{Ch}~(A~\AgdaInductiveConstructor{\&}~B)~\AgdaDatatype{‚àó}~((A~\AgdaInductiveConstructor{‚à∑\_})~\AgdaFunction{‚ä¢}~\AgdaDatatype{Proc}~\AgdaFunction{‚à©}~(B~\AgdaInductiveConstructor{‚à∑\_})~\AgdaFunction{‚ä¢}~\AgdaDatatype{Proc})
\]
which looks intimidating at first but makes perfect sense once we recall
\CaseRule. Remember that we are trying to establish whether $\Case\x\y{P}{Q}$ is
well typed in $\Context$.
%
The predicate $\AgdaDatatype{Ch}~(A~\AgdaInductiveConstructor{\&}~B)$ expresses
the requirement that the type of $x$ must be of the form $A \With B$ and should
be found in $\Context$. In other words, it must be the case that
$\Splitting\Context{[A \With B]}\ContextD$ for some $\ContextD$. Now $P$ and $Q$
must be well typed in the context $\ContextD$ augmented with the association $y
: A$ and $y : B$, respectively, whence the use of \AgdaFunction{‚à©} to verify a
(non-separating) conjunction of the predicates
$(A~\AgdaInductiveConstructor{‚à∑\_})~\AgdaFunction{‚ä¢}~\AgdaDatatype{Proc}$ and
$(B~\AgdaInductiveConstructor{‚à∑\_})~\AgdaFunction{‚ä¢}~\AgdaDatatype{Proc}$. The
two new contexts are obtained by \emph{adding} either $A$ or $B$ to $\ContextD$,
which we perform using \AgdaFunction{‚ä¢}.
%
Crucially, the types $A$ and $B$ are \emph{prepended} to $\ContextD$, which is
consistent with the fact that $y$ has been freshly introduced and $x$ has been
consumed. Notice how easy it is to \emph{prepend} either $A$ or $B$ to
$\ContextD$ instead of \emph{changing} the type of $x$ in $\Context$ from $A
\With B$ to either $A$ or $B$ while preserving the position of the type, as we
would have to do in a ``true'' session type system without explicit continuation
channels.

The interpretation of the remaining constructors is analogous, so we only
comment \AgdaInductiveConstructor{all}, which represents a process
$\Forall\x\X\y.P$. This constructor models the continuation $P$ using
higher-order abstract syntax (HOAS~\cite{}): witnessing that a context
$\Context$ satisfies the predicate
\[
  \AgdaFunction{‚ãÇ[}~X~\AgdaFunction{‚à∂}~\AgdaDatatype{Type}~\AgdaFunction]~((\AgdaFunction{subst~[}~X~\AgdaFunction{/\_]}~A~\AgdaInductiveConstructor{‚à∑\_})~\AgdaFunction{‚ä¢}~\AgdaDatatype{Proc}
\]
means providing a function that, for every type $X$, produces a witness for the
predicate
\[
  ((\AgdaFunction{subst~[}~X~\AgdaFunction{/\_]}~A~\AgdaInductiveConstructor{‚à∑\_})~\AgdaFunction{‚ä¢}~\AgdaDatatype{Proc}
\]
applied to $\Context$. Note that the side condition $X \not\in \fv\Context$ of
\ForallRule is enforced \emph{by definition}:
%
$A$ has type $\AgdaDatatype{PreType}~\AgdaInductiveConstructor{1}$, that is a
pre-type with \emph{at most one} free type variable ($X$), whereas $\Context$ is
a typing context, that is a list of $\AgdaDatatype{Type} =
\AgdaDatatype{PreType}~\AgdaInductiveConstructor{0}$ without free type
variables. Therefore, $X$ cannot occur in $\Context$.

We conclude this module proving that permutations preserve process typeability.
Since list permutations basically correspond to channel renaming, we can read
this property as the fact that typeability is preserved by (injective) name
substitutions.\Luca{Abbiamo detto da qualche parte dove emergono gli indici di
de Bruijn e di fare attenzione al fatto che lo splitting li altera? Serve questa
digressione?}\Luca{Da qualche parte mettere un remark per far notare che l'uso
della separating conjunction introduce rumore, ma avere i costruttori
currificati ne complica un po' l'interpretazione dei tipi. Forse √® meglio fare
questo rilievo nella prossima sezione quando √® evidente il pattern matching che
serve per esprimere le regole.}

\begin{code}
‚Ü≠proc : ‚àÄ{Œì Œî} ‚Üí Œì ‚Ü≠ Œî ‚Üí Proc Œì ‚Üí Proc Œî
\end{code}
\begin{code}[hide]
‚Ü≠proc œÄ (link (ch ‚ü® p ‚ü© ch)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' rewrite ‚Ü≠solo-inv œÄ' = link (ch ‚ü® q ‚ü© ch)
‚Ü≠proc œÄ (fail (ch ‚ü® p ‚ü© tt)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = fail (ch ‚ü® q ‚ü© tt)
‚Ü≠proc œÄ (wait (ch ‚ü® p ‚ü© P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = wait (ch ‚ü® q ‚ü© ‚Ü≠proc œÄ' P)
‚Ü≠proc œÄ (close ch) rewrite ‚Ü≠solo-inv œÄ = close ch
‚Ü≠proc œÄ (case (ch ‚ü® p ‚ü© (P , Q))) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = case (ch ‚ü® q ‚ü© (‚Ü≠proc (prep œÄ') P , ‚Ü≠proc (prep œÄ') Q))
‚Ü≠proc œÄ (select (ch ‚ü® p ‚ü© inj‚ÇÅ P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = select (ch ‚ü® q ‚ü© inj‚ÇÅ (‚Ü≠proc (prep œÄ') P))
‚Ü≠proc œÄ (select (ch ‚ü® p ‚ü© inj‚ÇÇ P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = select (ch ‚ü® q ‚ü© inj‚ÇÇ (‚Ü≠proc (prep œÄ') P))
‚Ü≠proc œÄ (join (ch ‚ü® p ‚ü© P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = join (ch ‚ü® q ‚ü© ‚Ü≠proc (prep (prep œÄ')) P)
‚Ü≠proc œÄ (fork (ch ‚ü® p ‚ü© (P ‚ü® q ‚ü© Q))) with ‚Ü≠solo œÄ p
... | _ , p' , œÄ' with ‚Ü≠split œÄ' q
... | Œî‚ÇÅ , Œî‚ÇÇ , q' , œÄ‚ÇÅ , œÄ‚ÇÇ = fork (ch ‚ü® p' ‚ü© (‚Ü≠proc (prep œÄ‚ÇÅ) P ‚ü® q' ‚ü© ‚Ü≠proc (prep œÄ‚ÇÇ) Q))
‚Ü≠proc œÄ (all (ch ‚ü® p ‚ü© F)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = all (ch ‚ü® q ‚ü© Œª X ‚Üí ‚Ü≠proc (prep œÄ') (F X))
‚Ü≠proc œÄ (ex (ch ‚ü® p ‚ü© P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = ex (ch ‚ü® q ‚ü© ‚Ü≠proc (prep œÄ') P)
‚Ü≠proc œÄ (server (ch ‚ü® p ‚ü© (un , P))) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = server (ch ‚ü® q ‚ü© (‚Ü≠un œÄ' un , ‚Ü≠proc (prep œÄ') P))
‚Ü≠proc œÄ (client (ch ‚ü® p ‚ü© P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = client (ch ‚ü® q ‚ü© ‚Ü≠proc (prep œÄ') P)
‚Ü≠proc œÄ (weaken (ch ‚ü® p ‚ü© P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = weaken (ch ‚ü® q ‚ü© ‚Ü≠proc œÄ' P)
‚Ü≠proc œÄ (contract (ch ‚ü® p ‚ü© P)) with ‚Ü≠solo œÄ p
... | _ , q , œÄ' = contract (ch ‚ü® q ‚ü© ‚Ü≠proc (prep (prep œÄ')) P)
‚Ü≠proc œÄ (cut (P ‚ü® p ‚ü© Q)) with ‚Ü≠split œÄ p
... | Œî‚ÇÅ , Œî‚ÇÇ , q , œÄ‚ÇÅ , œÄ‚ÇÇ = cut (‚Ü≠proc (prep œÄ‚ÇÅ) P ‚ü® q ‚ü© ‚Ü≠proc (prep œÄ‚ÇÇ) Q)
\end{code}
