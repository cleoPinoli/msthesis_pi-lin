\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Product using (_Ã—_; _,_; âˆƒ; âˆƒ-syntax)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; cong; congâ‚‚)
open import Data.List.Base using (List; []; _âˆ·_; [_]; _++_)

open import Type
open import Context
open import Permutations
\end{code}

\subsection{Process Representation}
\label{sec:process-agda}

We adopt a \emph{nameless, intrinsically-typed} representation of processes,
whereby a channel is identified by the position of its type in the typing
context and a process is also a proof derivation showing that the process is
well typed. This choice increases the effort in the definition of the datatypes
for defining processes and their operational semantics, but pays off in the rest
of the formalization for a number of reasons:
\begin{itemize}
\item we use context splitting not only to separate resources used by parallel
  processes (\cf \ForkRule and \CutRule), but also to witness that a channel is
  present in the typing context;
\item we conflate processes and typing rules in the same datatype, thus reducing
  the overall number of datatypes defined in the formalization;
\item we embed the typing preservation results within the very definition of the
  operational semantics of processes instead of proving them separately
  (\Cref{sec:agda-semantics}).
\end{itemize}

Our nameless representation of channels is known in the literature as the
\emph{co-de Bruijn} representation of identifiers~\cite{McBride18}. The proof
that the type of a channel is found within a typing context essentially encodes
the de Bruijn index of the channel in the typing context of a given process.
However, the typing context only contains types for those channels that actually
occur in the process. Context splitting makes sure that channels are
appropriately (and above all linearly) distributed among sub-processes, so that
each channel occurs (and is used) exactly once.\footnote{Strictly speaking, the
typing context of a \AgdaInductiveConstructor{fail} process may contain channels
that do not occur (and therefore are not used) by the process, but we consider
this case as an exception that does not alter in a substantial way the provided
intuition underlying the use of co-de Bruijn representation.}

We now illustrate the definition of the \AgdaDatatype{Process} datatype and then
describe its key aspects in detail. The datatype is indexed by a typing context
$\Context$ according to which the process is well typed:

\begin{code}
data Process : Context â†’ Set where
  link      : âˆ€{A Î“} â†’ Î“ â‰ƒ [ A ] + [ dual A ] â†’ Process Î“
  fail      : âˆ€{Î“ Î”} â†’ Î“ âˆ‹ âŠ¤ âŠ³ Î” â†’ Process Î“
  wait      : âˆ€{Î“ Î”} â†’ Î“ âˆ‹ âŠ¥ âŠ³ Î” â†’ Process Î” â†’ Process Î“
  close     : Process [ ğŸ™ ]
  case      : âˆ€{A B Î“ Î”} â†’ Î“ âˆ‹ A & B âŠ³ Î” â†’
              Process (A âˆ· Î”) â†’ Process (B âˆ· Î”) â†’ Process Î“
  left      : âˆ€{A B Î“ Î”} â†’ Î“ âˆ‹ A âŠ• B âŠ³ Î” â†’ Process (A âˆ· Î”) â†’ Process Î“
  right     : âˆ€{A B Î“ Î”} â†’ Î“ âˆ‹ A âŠ• B âŠ³ Î” â†’ Process (B âˆ· Î”) â†’ Process Î“
  join      : âˆ€{A B Î“ Î”} â†’ Î“ âˆ‹ A â…‹ B âŠ³ Î” â†’ Process (B âˆ· A âˆ· Î”) â†’ Process Î“
  fork      : âˆ€{A B Î“ Î” Î“â‚ Î“â‚‚} â†’ Î“ âˆ‹ A âŠ— B âŠ³ Î” â†’ Î” â‰ƒ Î“â‚ + Î“â‚‚ â†’
              Process (A âˆ· Î“â‚) â†’ Process (B âˆ· Î“â‚‚) â†’ Process Î“
  all       : âˆ€{A Î“ Î”} â†’ Î“ âˆ‹ `âˆ€ A âŠ³ Î” â†’
              ((X : Type) â†’ Process (subst [ X /_] A âˆ· Î”)) â†’ Process Î“
  ex        : âˆ€{A B Î“ Î”} â†’ Î“ âˆ‹ `âˆƒ A âŠ³ Î” â†’ Process (subst [ B /_] A âˆ· Î”) â†’ Process Î“
  server    : âˆ€{A Î“ Î”} â†’ Î“ âˆ‹ `! A âŠ³ Î” â†’ Un Î” â†’ Process (A âˆ· Î”) â†’ Process Î“
  client    : âˆ€{A Î“ Î”} â†’ Î“ âˆ‹ `? A âŠ³ Î” â†’ Process (A âˆ· Î”) â†’ Process Î“
  weaken    : âˆ€{A Î“ Î”} â†’ Î“ âˆ‹ `? A âŠ³ Î” â†’ Process Î” â†’ Process Î“
  contract  : âˆ€{A Î“ Î”} â†’ Î“ âˆ‹ `? A âŠ³ Î” â†’ Process (`? A âˆ· `? A âˆ· Î”) â†’ Process Î“
  cut       : âˆ€{A Î“ Î“â‚ Î“â‚‚} â†’ Î“ â‰ƒ Î“â‚ + Î“â‚‚ â†’
              Process (A âˆ· Î“â‚) â†’ Process (dual A âˆ· Î“â‚‚) â†’ Process Î“
\end{code}

Let us start from the constructors representing input/output actions, namely
those from \AgdaInductiveConstructor{fail} through
\AgdaInductiveConstructor{contract}. They all basically follow the same pattern:
their first (explicit) argument is a splitting of the form
$\SimpleSplitting\ContextC{C}\ContextD$ that identifies the channel on which the
process is acting within the typing context $\ContextC$ and where the shape of
$C$ is determined by the typing rule; the subsequent arguments are terms
corresponding to the continuations of the process being represented, each
indexed by its own context. Crucially, the type of the continuation channels are
\emph{prepended} to the context that indexes the continuation processes using
the \AgdaInductiveConstructor{\_âˆ·\_} list constructor. This is consistent with
the fact that the continuation channels have been freshly introduced, and the
channel on which the process operates has been consumed.
%
There are just a few deviations from this pattern, which we discuss next.

The constructor \AgdaInductiveConstructor{close} lacks a splitting argument:
since a process $\Close\x$ is well typed in a singleton context $x : \One$, it
is easier to specify such context directly as the index of
\AgdaDatatype{Process} rather than through a splitting.

The constructor \AgdaInductiveConstructor{fork}, which represents a process
$\Fork\x\y\z{P}{Q}$, has an additional splitting argument
$\Splitting\ContextD{\Context_1}{\Context_2}$ which distributes the resources in
$\ContextD$ among the two continuation processes $P$ and $Q$.

The constructor \AgdaInductiveConstructor{all}, which represents a process
$\Forall\x\X\y.P$, models the continuation $P$ using higher-order abstract
syntax (HOAS~\cite{}): the continuation $P$ is produced by a function applied to
a \AgdaInductiveConstructor{Type} $X$. Notice how the constructor enforces the
side condition of \ForallRule \emph{by definition}:
%
$A$ has type
$\AgdaDatatype{PreType}~(\AgdaInductiveConstructor{suc}~\AgdaInductiveConstructor{zero})$,
that is a pre-type with \emph{at most one} free type variable (that is $X$),
whereas $\ContextD$ is a list of $\AgdaDatatype{Type} =
\AgdaDatatype{PreType}~\AgdaInductiveConstructor{zero}$, that is a list of
pre-types without free type variables. Therefore, $X$ cannot occur in
$\ContextD$ as required by \ForallRule.

Finally, the constructor \AgdaInductiveConstructor{server}, which represents a
process $\Server\x\y.P$, has an additional argument of type
$\AgdaDatatype{Un}~\ContextD$ enforcing the property that $\ContextD$ is
unrestricted.

The two remaining constructors, \AgdaInductiveConstructor{link} and
\AgdaInductiveConstructor{cut}, deal with links and cuts in the expected way. A
link is well typed in a context
$\Splitting\Context{[A]}{[\AgdaFunction{dual}~A]}$. We use a splitting instead
of requiring $\Context$ to be $[A,\AgdaFunction{dual}~A]$ so that it becomes
straightforward to define \SLink using \AgdaFunction{+-comm}.
%
The constructor \AgdaInductiveConstructor{cut} models a process $\Cut\x{P}{Q}$
and uses splitting to distribute the resources in $\Context$ among $P$ and $Q$.

Permutations preserve process typeability. In a sense we can read this property
as the fact that we can rename channels at will.

\begin{code}
â†­process : âˆ€{Î“ Î”} â†’ Î“ â†­ Î” â†’ Process Î“ â†’ Process Î”
\end{code}
\begin{code}[hide]
â†­process Ï€ (link p) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² rewrite â†­solo-inv Ï€â€² = link q
â†­process Ï€ (fail p) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = fail q
â†­process Ï€ (wait p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = wait q (â†­process Ï€â€² P)
â†­process Ï€ close rewrite â†­solo-inv Ï€ = close
â†­process Ï€ (case p P Q) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = case q (â†­process (prep Ï€â€²) P) (â†­process (prep Ï€â€²) Q)
â†­process Ï€ (left p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = left q (â†­process (prep Ï€â€²) P)
â†­process Ï€ (right p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = right q (â†­process (prep Ï€â€²) P)
â†­process Ï€ (join p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = join q (â†­process (prep (prep Ï€â€²)) P)
â†­process Ï€ (fork p q P Q) with â†­solo Ï€ p
... | Î”â€² , pâ€² , Ï€â€² with â†­split Ï€â€² q
... | Î”â‚ , Î”â‚‚ , qâ€² , Ï€â‚ , Ï€â‚‚ = fork pâ€² qâ€² (â†­process (prep Ï€â‚) P) (â†­process (prep Ï€â‚‚) Q)
â†­process Ï€ (all p P) with â†­solo Ï€ p
... | Î”' , q , Ï€' = all q Î» B â†’ â†­process (prep Ï€') (P B)
â†­process Ï€ (ex p P) with â†­solo Ï€ p
... | Î”' , q , Ï€' = ex q (â†­process (prep Ï€') P)
â†­process Ï€ (server p un P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = server q (â†­un Ï€â€² un) (â†­process (prep Ï€â€²) P)
â†­process Ï€ (client p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = client q (â†­process (prep Ï€â€²) P)
â†­process Ï€ (weaken p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = weaken q (â†­process Ï€â€² P)
â†­process Ï€ (contract p P) with â†­solo Ï€ p
... | Î”â€² , q , Ï€â€² = contract q (â†­process (prep (prep Ï€â€²)) P)
â†­process Ï€ (cut p P Q) with â†­split Ï€ p
... | Î”â‚ , Î”â‚‚ , q , Ï€â‚ , Ï€â‚‚ = cut q (â†­process (prep Ï€â‚) P) (â†­process (prep Ï€â‚‚) Q)
\end{code}
