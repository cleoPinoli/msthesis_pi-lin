\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Unit using (tt)
open import Data.Sum
open import Data.Product using (_,_)
open import Data.List.Base using ([]; _âˆ·_; [_])
open import Relation.Unary

open import Type
open import Context
open import Permutations
\end{code}

\subsection{Process Representation}
\label{sec:process-agda}

We adopt an \emph{intrinsically-typed} representation of processes with
\emph{nameless} channels. The intrinsically-typed representation makes sure that
only well-typed processes can be constructed. This choice increases the effort
in the definition of the datatypes for representing processes and their
operational semantics, but pays off in the rest of the formalization for at
least three reasons:
\begin{itemize}
\item we need not give explicit names to channels, thus we avoid all the
  technicalities and pitfalls that a named representation entails;
\item we conflate processes and typing rules in the same datatype, thus reducing
  the overall number of datatypes defined in the formalization;
\item the typing preservation results are embedded in the very definition of the
  operational semantics of processes and need not require separate proofs
  (\Cref{sec:agda-semantics}).
\end{itemize}

Channels are not given any name. Instead, they are represented as terms
witnessing that their type is present in the typing context. This is known as
\emph{co-de Bruijn syntax}~\cite{McBride18}, according to which the typing
context associated with a term (a process, a channel) only contains the types of
the channels that actually occur within the term. For this reason, typing
contexts are split as soon as possible, according to the structure of processes,
to make sure that channels are appropriately (and above all linearly)
distributed among sub-processes, so that each channel occurs (and is used)
exactly once.\footnote{Strictly speaking, the typing context of a
\AgdaInductiveConstructor{fail} process may contain channels that do not occur
(and therefore are not used) by the process, but we consider this case as an
exception that does not alter in a substantial way the provided intuition
underlying the use of co-de Bruijn representation.}
%
Concretely, a channel of type $A$ is a predicate that holds for the singleton
context $\AgdaFunction[~A~\AgdaFunction]$:

\begin{code}
data Ch (A : Type) : Context â†’ Set where
  ch : Ch A [ A ]
\end{code}

A process that is well typed in a typing context $\Context$ is a predicate that
holds for $\Context$. Here is the datatype \AgdaDatatype{Proc} for representing
processes:

\begin{code}
data Proc : Context â†’ Set where
  link      : âˆ€{A} â†’ âˆ€[ Ch A âˆ— Ch (dual A) â‡’ Proc ]
  fail      : âˆ€[ Ch âŠ¤ âˆ— U â‡’ Proc ]
  wait      : âˆ€[ Ch âŠ¥ âˆ— Proc â‡’ Proc ]
  close     : âˆ€[ Ch ğŸ™ â‡’ Proc ]
  case      : âˆ€{A B} â†’
              âˆ€[ Ch (A & B) âˆ— ((A âˆ·_) âŠ¢ Proc âˆ© (B âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  select    : âˆ€{A B} â†’
              âˆ€[ Ch (A âŠ• B) âˆ— ((A âˆ·_) âŠ¢ Proc âˆª (B âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  join      : âˆ€{A B} â†’ âˆ€[ Ch (A â…‹ B) âˆ— ((A âˆ·_) âŠ¢ (B âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  fork      : âˆ€{A B} â†’
              âˆ€[ Ch (A âŠ— B) âˆ— ((A âˆ·_) âŠ¢ Proc) âˆ— ((B âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  all       : âˆ€{A} â†’
              âˆ€[ Ch (`âˆ€ A) âˆ— â‹‚[ X âˆ¶ Type ] ((subst [ X /_] A âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  ex        : âˆ€{A B} â†’ âˆ€[ Ch (`âˆƒ A) âˆ— ((subst [ B /_] A âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  server    : âˆ€{A} â†’ âˆ€[ Ch (`! A) âˆ— (Un âˆ© ((A âˆ·_) âŠ¢ Proc)) â‡’ Proc ]
  client    : âˆ€{A} â†’ âˆ€[ Ch (`? A) âˆ— ((A âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  weaken    : âˆ€{A} â†’ âˆ€[ Ch (`? A) âˆ— Proc â‡’ Proc ]
  contract  : âˆ€{A} â†’ âˆ€[ Ch (`? A) âˆ— ((`? A âˆ·_) âŠ¢ (`? A âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  cut       : âˆ€{A} â†’ âˆ€[ ((A âˆ·_) âŠ¢ Proc) âˆ— ((dual A âˆ·_) âŠ¢ Proc) â‡’ Proc ]
\end{code}

All the constructors representing input/output actions, namely those from
\AgdaInductiveConstructor{fail} through \AgdaInductiveConstructor{contract},
basically follow the same pattern: they possibly quantify over some types $A$
and $B$ and then (implicitly) over a typing context $\Context$ through the
function \AgdaFunction{âˆ€[\_]} applied to a predicate of the form
$P~\AgdaFunction{â‡’}~\AgdaDatatype{Proc}$. The predicate states how to build a
process that is well typed in $\Context$, provided that $\Context$ satisfies
$P$. In general, $P$ is a (separating) conjunction of sub-predicates
corresponding to the channel on which the process is acting and to the premises
of its typing rule.

The constructor \AgdaInductiveConstructor{fail} requires the context $\Context$
to satisfy the predicate
$\AgdaDatatype{Ch}~\AgdaInductiveConstructor{âŠ¤}~\AgdaDatatype{âˆ—}~\AgdaFunction{U}$,
meaning that $\Context$ must contain an entry \AgdaInductiveConstructor{âŠ¤}. That
form of $\Context$ matches the one in the conclusion of \FailRule.

The constructor \AgdaInductiveConstructor{wait} corresponds to a process of the
form $\Wait\x.P$ and requires $\Context$ to (separately) satisfy
$\AgdaDatatype{Ch}~\AgdaInductiveConstructor{âŠ¥}$, that is the channel $x$ on
which the process is operating, as well as \AgdaDatatype{Proc}, that is the
continuation process $P$, which must be well typed in the remaining typing
context.

The constructor \AgdaInductiveConstructor{close}, which corresponds to a process
of the form $\Close\x$, requires the typing context to be the singleton list
$[\One]$.

Crucially, the type of the continuation channels are \emph{prepended} to the
context that indexes the continuation processes using the
\AgdaInductiveConstructor{\_âˆ·\_} list constructor. This is consistent with the
fact that the continuation channels have been freshly introduced, and the
channel on which the process operates has been consumed.
%
There are just a few deviations from this pattern, which we discuss next.


The constructor \AgdaInductiveConstructor{fork}, which represents a process
$\Fork\x\y\z{P}{Q}$, has an additional splitting argument
$\Splitting\ContextD{\Context_1}{\Context_2}$ which distributes the resources in
$\ContextD$ among the two continuation processes $P$ and $Q$.

The constructor \AgdaInductiveConstructor{all}, which represents a process
$\Forall\x\X\y.P$, models the continuation $P$ using higher-order abstract
syntax (HOAS~\cite{}): the continuation $P$ is produced by a function applied to
a \AgdaInductiveConstructor{Type} $X$. Notice how the constructor enforces the
side condition of \ForallRule \emph{by definition}:
%
$A$ has type
$\AgdaDatatype{PreType}~(\AgdaInductiveConstructor{suc}~\AgdaInductiveConstructor{zero})$,
that is a pre-type with \emph{at most one} free type variable (that is $X$),
whereas $\ContextD$ is a list of $\AgdaDatatype{Type} =
\AgdaDatatype{PreType}~\AgdaInductiveConstructor{zero}$, that is a list of
pre-types without free type variables. Therefore, $X$ cannot occur in
$\ContextD$ as required by \ForallRule.

Finally, the constructor \AgdaInductiveConstructor{server}, which represents a
process $\Server\x\y.P$, has an additional argument of type
$\AgdaDatatype{Un}~\ContextD$ enforcing the property that $\ContextD$ is
unrestricted.

The two remaining constructors, \AgdaInductiveConstructor{link} and
\AgdaInductiveConstructor{cut}, deal with links and cuts in the expected way. A
link is well typed in a context
$\Splitting\Context{[A]}{[\AgdaFunction{dual}~A]}$. We use a splitting instead
of requiring $\Context$ to be $[A,\AgdaFunction{dual}~A]$ so that it becomes
straightforward to define \SLink using \AgdaFunction{+-comm}.
%
The constructor \AgdaInductiveConstructor{cut} models a process $\Cut\x{P}{Q}$
and uses splitting to distribute the resources in $\Context$ among $P$ and $Q$.

Permutations preserve process typeability. In a sense we can read this property
as the fact that we can rename channels at will.

\begin{code}
â†­proc : âˆ€{Î“ Î”} â†’ Î“ â†­ Î” â†’ Proc Î“ â†’ Proc Î”
\end{code}
\begin{code}[hide]
â†­proc Ï€ (link (ch âŸ¨ p âŸ© ch)) with â†­solo Ï€ p
... | _ , q , Ï€' rewrite â†­solo-inv Ï€' = link (ch âŸ¨ q âŸ© ch)
â†­proc Ï€ (fail (ch âŸ¨ p âŸ© tt)) with â†­solo Ï€ p
... | _ , q , Ï€' = fail (ch âŸ¨ q âŸ© tt)
â†­proc Ï€ (wait (ch âŸ¨ p âŸ© P)) with â†­solo Ï€ p
... | _ , q , Ï€' = wait (ch âŸ¨ q âŸ© â†­proc Ï€' P)
â†­proc Ï€ (close ch) rewrite â†­solo-inv Ï€ = close ch
â†­proc Ï€ (case (ch âŸ¨ p âŸ© (P , Q))) with â†­solo Ï€ p
... | _ , q , Ï€' = case (ch âŸ¨ q âŸ© (â†­proc (prep Ï€') P , â†­proc (prep Ï€') Q))
â†­proc Ï€ (select (ch âŸ¨ p âŸ© injâ‚ P)) with â†­solo Ï€ p
... | _ , q , Ï€' = select (ch âŸ¨ q âŸ© injâ‚ (â†­proc (prep Ï€') P))
â†­proc Ï€ (select (ch âŸ¨ p âŸ© injâ‚‚ P)) with â†­solo Ï€ p
... | _ , q , Ï€' = select (ch âŸ¨ q âŸ© injâ‚‚ (â†­proc (prep Ï€') P))
â†­proc Ï€ (join (ch âŸ¨ p âŸ© P)) with â†­solo Ï€ p
... | _ , q , Ï€' = join (ch âŸ¨ q âŸ© â†­proc (prep (prep Ï€')) P)
â†­proc Ï€ (fork (ch âŸ¨ p âŸ© (P âŸ¨ q âŸ© Q))) with â†­solo Ï€ p
... | _ , p' , Ï€' with â†­split Ï€' q
... | Î”â‚ , Î”â‚‚ , q' , Ï€â‚ , Ï€â‚‚ = fork (ch âŸ¨ p' âŸ© (â†­proc (prep Ï€â‚) P âŸ¨ q' âŸ© â†­proc (prep Ï€â‚‚) Q))
â†­proc Ï€ (all (ch âŸ¨ p âŸ© F)) with â†­solo Ï€ p
... | _ , q , Ï€' = all (ch âŸ¨ q âŸ© Î» X â†’ â†­proc (prep Ï€') (F X))
â†­proc Ï€ (ex (ch âŸ¨ p âŸ© P)) with â†­solo Ï€ p
... | _ , q , Ï€' = ex (ch âŸ¨ q âŸ© â†­proc (prep Ï€') P)
â†­proc Ï€ (server (ch âŸ¨ p âŸ© (un , P))) with â†­solo Ï€ p
... | _ , q , Ï€' = server (ch âŸ¨ q âŸ© (â†­un Ï€' un , â†­proc (prep Ï€') P))
â†­proc Ï€ (client (ch âŸ¨ p âŸ© P)) with â†­solo Ï€ p
... | _ , q , Ï€' = client (ch âŸ¨ q âŸ© â†­proc (prep Ï€') P)
â†­proc Ï€ (weaken (ch âŸ¨ p âŸ© P)) with â†­solo Ï€ p
... | _ , q , Ï€' = weaken (ch âŸ¨ q âŸ© â†­proc Ï€' P)
â†­proc Ï€ (contract (ch âŸ¨ p âŸ© P)) with â†­solo Ï€ p
... | _ , q , Ï€' = contract (ch âŸ¨ q âŸ© â†­proc (prep (prep Ï€')) P)
â†­proc Ï€ (cut (P âŸ¨ p âŸ© Q)) with â†­split Ï€ p
... | Î”â‚ , Î”â‚‚ , q , Ï€â‚ , Ï€â‚‚ = cut (â†­proc (prep Ï€â‚) P âŸ¨ q âŸ© â†­proc (prep Ï€â‚‚) Q)
\end{code}
