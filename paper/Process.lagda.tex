\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Unit using (tt)
open import Data.Sum
open import Data.Product using (_Ã—_; _,_; âˆƒ; âˆƒ-syntax)
open import Data.List.Base using (List; []; _âˆ·_; [_]; _++_)
open import Relation.Unary
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; cong; congâ‚‚)

open import Type
open import Context
open import Permutations
\end{code}

\subsection{Process Representation}
\label{sec:process-agda}

We adopt a representation of processes that is \emph{intrinsically typed} and
based on \emph{co-de Bruijn indexes}. The intrinsically typed representation
makes sure that only well-typed processes can be constructed. This choice
increases the effort in the definition of the datatypes for representing
processes and their operational semantics, but pays off in the rest of the
formalization for at least three reasons:
\begin{itemize}
\item we can adopt a \emph{nameless} representation of channels, thus avoiding
  all the technicalities and pitfalls that a named representation entails;
\item we conflate processes and typing rules in the same datatype, thus reducing
  the overall number of datatypes defined in the formalization;
\item the typing preservation results are embedded in the very definition of the
  operational semantics of processes and need not require separate proofs
  (\Cref{sec:agda-semantics}).
\end{itemize}

We use \emph{co-de Bruijn indexes}~\cite{McBride18} to represent channels. Co-de
Bruijn indexes are akin to de Bruijn indexes, with the key difference that the
typing context used to type a certain process $P$ is guaranteed to only contain
the type of those channels that actually occur in $P$. For this reason, typing
contexts are split as soon as possible, according to the structure of processes,
to make sure that channels are appropriately (and above all linearly)
distributed among sub-processes, so that each channel occurs (and is used)
exactly once.\footnote{Strictly speaking, the typing context of a
\AgdaInductiveConstructor{fail} process may contain channels that do not occur
(and therefore are not used) by the process, but we consider this case as an
exception that does not alter in a substantial way the provided intuition
underlying the use of co-de Bruijn representation.}

From this informal introduction to the representation of processes it is clear
that context splitting is going to be a pervasive notion in the subsequent
development, to the point that it contributes substantially to the complexity of
the formalization. For this reason, it is worth investing some effort in a
defining an abstraction that allows us to express the type of processes in a
more compact and hopefully more readable way.
\citet{RouvoetPoulsenKrebbersVisser20} observe that both channels and processes
can be thought of as \emph{predicates on typing contexts}:
\begin{itemize}
\item a channel of type $A$ is a predicate that holds for the singleton context
  $\AgdaFunction[~A~\AgdaFunction]$;
\item a process that is well typed in a typing context $\Context$ is a predicate
  that holds for $\Context$.
\end{itemize}

Inspired by separation logic~\cite{Hoare},
\citet{RouvoetPoulsenKrebbersVisser20} define the \emph{separating conjunction}
$P \sand Q$ of two predicates $P$ and $Q$. The separating conjunction of $P$ and
$Q$ holds for those contexts $\ContextC$ that can be split into $\ContextD$ and
$\ContextE$ where $P$ holds for $\ContextD$ and $Q$ holds for $\ContextE$. In
Agda, \citet{RouvoetPoulsenKrebbersVisser20} define $\sand$ as a record, thus:
\begin{code}
record _âˆ—_ (P Q : Pred Context _) (Î“ : Context) : Set where
  constructor _âŸ¨_âŸ©_
  field
    {Î” Î˜} : Context
    px    : P Î”
    p     : Î“ â‰ƒ Î” + Î˜
    qx    : Q Î˜
\end{code}
\begin{code}[hide]
infixr 9 _âˆ—_
\end{code}

The record has five fields: the (implicit) fields $\ContextD$ and $\ContextE$,
which represent the decomposition of $\ContextC$; the fields \AgdaField{px} and
\AgdaField{qx}, which are proofs witnessing that $P$ and $Q$ hold respectively
for $\ContextD$ and $\ContextE$; the field \AgdaField{p}, which witnesses that
$\ContextD$ and $\ContextE$ are indeed a splitting of $\ContextC$. The
constructor \AgdaInductiveConstructor{$\_\langle\_\rangle\_$} provides a
convenient syntax for specifying the (explicit) fields of the record to provide
(and pattern match) separating conjunctions.

To illustrate a typical usage pattern of separating conjunction we first
introduce our first predicate \AgdaDatatype{Ch} on typing contexts, which we use
to describe well-typed channels:

\begin{code}
data Ch (A : Type) : Context â†’ Set where
  ch : Ch A [ A ]
\end{code}

The predicate $\AgdaDatatype{Ch}~A$ holds for the singleton typing context
$[A]$. Hence the predicate $\AgdaDatatype{Ch}~A\sand\AgdaDatatype{Ch}~B$ holds
for those typing contexts that can be split into $[A]$ and $[B]$, as exemplified
below:
\begin{code}
_ : âˆ€{A B} â†’ (Ch A âˆ— Ch B) (A âˆ· B âˆ· [])
_ = ch âŸ¨ < > â€¢ âŸ© ch

_ : âˆ€{A B} â†’ (Ch A âˆ— Ch B) (B âˆ· A âˆ· [])
_ = ch âŸ¨ > < â€¢ âŸ© ch
\end{code}

\begin{table}
  \begin{tabular}{|lll|}
    \hline
    \textbf{Notation} & \textbf{Definition} & \textbf{Meaning} \\
    \hline
    $\AgdaFunction{âˆ€[}~P~\AgdaFunction]$ & $\forall\{x\} \to P~x$ & implicit universality \\
    $P~\AgdaFunction{â‡’}~Q$ & $\lambda x \to P~x \to Q~x$ & implication \\
    $P~\AgdaFunction{âˆª}~Q$ & $\lambda x \to P~x~\AgdaDatatype{âŠŽ}~Q~x$ & disjunction \\
    $P~\AgdaFunction{âˆ©}~Q$ & $\lambda x \to P~x~\AgdaDatatype{Ã—}~Q~x$ & conjunction (non-separating) \\
    $f~\AgdaFunction{âŠ¢}~P$ & $\lambda x \to P~(f~x)$ & update \\
    $\AgdaFunction{U}$ & $\lambda x \to \AgdaModule{Data.Unit}.\AgdaDatatype{âŠ¤}$ & universal
    set \\
    $\AgdaFunction{â‹‚[}~X~\AgdaFunction{:}~A~\AgdaFunction]~P$ & $\lambda x \to (X : A) \to P~X~x$ & infinitary conjunction \\
    \hline
  \end{tabular}
  \caption{\label{tab:predicates} Used definitions from Agda's \AgdaModule{Relation.Unary} module.}
\end{table}

We now illustrate the datatype \AgdaDatatype{Proc} for representing processes
and then describe its key aspects in detail. This datatype uses, in addition to
$\sand$, a number of definitions from the \AgdaModule{Relation.Unary} module in
Agda's standard library which are worth recalling in \Cref{tab:predicates}.

\begin{code}
data Proc : Context â†’ Set where
  link      : âˆ€{A} â†’ âˆ€[ Ch A âˆ— Ch (dual A) â‡’ Proc ]
  fail      : âˆ€[ Ch âŠ¤ âˆ— U â‡’ Proc ]
  wait      : âˆ€[ Ch âŠ¥ âˆ— Proc â‡’ Proc ]
  close     : âˆ€[ Ch ðŸ™ â‡’ Proc ]
  case      : âˆ€{A B} â†’
              âˆ€[ Ch (A & B) âˆ— ((A âˆ·_) âŠ¢ Proc âˆ© (B âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  select    : âˆ€{A B} â†’
              âˆ€[ Ch (A âŠ• B) âˆ— ((A âˆ·_) âŠ¢ Proc âˆª (B âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  join      : âˆ€{A B} â†’
              âˆ€[ Ch (A â…‹ B) âˆ— ((A âˆ·_) âŠ¢ (B âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  fork      : âˆ€{A B} â†’
              âˆ€[ Ch (A âŠ— B) âˆ— ((A âˆ·_) âŠ¢ Proc) âˆ— ((B âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  all       : âˆ€{A} â†’
              âˆ€[ Ch (`âˆ€ A) âˆ— â‹‚[ X âˆ¶ Type ] ((subst [ X /_] A âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  ex        : âˆ€{A B} â†’ âˆ€[ Ch (`âˆƒ A) âˆ— ((subst [ B /_] A âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  server    : âˆ€{A} â†’ âˆ€[ Ch (`! A) âˆ— (Un âˆ© ((A âˆ·_) âŠ¢ Proc)) â‡’ Proc ]
  client    : âˆ€{A} â†’ âˆ€[ Ch (`? A) âˆ— ((A âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  weaken    : âˆ€{A} â†’ âˆ€[ Ch (`? A) âˆ— Proc â‡’ Proc ]
  contract  : âˆ€{A} â†’ âˆ€[ Ch (`? A) âˆ— ((`? A âˆ·_) âŠ¢ (`? A âˆ·_) âŠ¢ Proc) â‡’ Proc ]
  cut       : âˆ€{A} â†’ âˆ€[ ((A âˆ·_) âŠ¢ Proc) âˆ— ((dual A âˆ·_) âŠ¢ Proc) â‡’ Proc ]
\end{code}

Let us start from the constructors representing input/output actions, namely
those from \AgdaInductiveConstructor{fail} through
\AgdaInductiveConstructor{contract}. They all basically follow the same pattern:
they possibly quantify over some types $A$ and $B$ and then (implicitly) over a
typing context $\Context$ through the function \AgdaFunction{âˆ€[\_]} applied to a
predicate of the form $\cdots~\AgdaFunction{â‡’}~\AgdaDatatype{Proc}$. The
predicate states how to build a process of a particular form, provided that the
typing context $\Context$ satisfies the predicate on the l.h.s. of
\AgdaFunction{â‡’}.

The constructor \AgdaInductiveConstructor{fail} requires the context $\Context$
to satisfy the predicate
$\AgdaDatatype{Ch}~\AgdaInductiveConstructor{âŠ¤}~\AgdaDatatype{âˆ—}~\AgdaFunction{U}$,
meaning that $\Context$ must contain an entry \AgdaInductiveConstructor{âŠ¤}. That
form of $\Context$ matches the one in the conclusion of \FailRule.

The constructor \AgdaInductiveConstructor{close} requires the typing context to
be the singleton list $[\One]$.

Crucially, the type of the continuation channels are \emph{prepended} to the
context that indexes the continuation processes using the
\AgdaInductiveConstructor{\_âˆ·\_} list constructor. This is consistent with the
fact that the continuation channels have been freshly introduced, and the
channel on which the process operates has been consumed.
%
There are just a few deviations from this pattern, which we discuss next.


The constructor \AgdaInductiveConstructor{fork}, which represents a process
$\Fork\x\y\z{P}{Q}$, has an additional splitting argument
$\Splitting\ContextD{\Context_1}{\Context_2}$ which distributes the resources in
$\ContextD$ among the two continuation processes $P$ and $Q$.

The constructor \AgdaInductiveConstructor{all}, which represents a process
$\Forall\x\X\y.P$, models the continuation $P$ using higher-order abstract
syntax (HOAS~\cite{}): the continuation $P$ is produced by a function applied to
a \AgdaInductiveConstructor{Type} $X$. Notice how the constructor enforces the
side condition of \ForallRule \emph{by definition}:
%
$A$ has type
$\AgdaDatatype{PreType}~(\AgdaInductiveConstructor{suc}~\AgdaInductiveConstructor{zero})$,
that is a pre-type with \emph{at most one} free type variable (that is $X$),
whereas $\ContextD$ is a list of $\AgdaDatatype{Type} =
\AgdaDatatype{PreType}~\AgdaInductiveConstructor{zero}$, that is a list of
pre-types without free type variables. Therefore, $X$ cannot occur in
$\ContextD$ as required by \ForallRule.

Finally, the constructor \AgdaInductiveConstructor{server}, which represents a
process $\Server\x\y.P$, has an additional argument of type
$\AgdaDatatype{Un}~\ContextD$ enforcing the property that $\ContextD$ is
unrestricted.

The two remaining constructors, \AgdaInductiveConstructor{link} and
\AgdaInductiveConstructor{cut}, deal with links and cuts in the expected way. A
link is well typed in a context
$\Splitting\Context{[A]}{[\AgdaFunction{dual}~A]}$. We use a splitting instead
of requiring $\Context$ to be $[A,\AgdaFunction{dual}~A]$ so that it becomes
straightforward to define \SLink using \AgdaFunction{+-comm}.
%
The constructor \AgdaInductiveConstructor{cut} models a process $\Cut\x{P}{Q}$
and uses splitting to distribute the resources in $\Context$ among $P$ and $Q$.

Permutations preserve process typeability. In a sense we can read this property
as the fact that we can rename channels at will.

\begin{code}
â†­proc : âˆ€{Î“ Î”} â†’ Î“ â†­ Î” â†’ Proc Î“ â†’ Proc Î”
\end{code}
\begin{code}[hide]
â†­proc Ï€ (link (ch âŸ¨ p âŸ© ch)) with â†­solo Ï€ p
... | _ , q , Ï€' rewrite â†­solo-inv Ï€' = link (ch âŸ¨ q âŸ© ch)
â†­proc Ï€ (fail (ch âŸ¨ p âŸ© tt)) with â†­solo Ï€ p
... | _ , q , Ï€' = fail (ch âŸ¨ q âŸ© tt)
â†­proc Ï€ (wait (ch âŸ¨ p âŸ© P)) with â†­solo Ï€ p
... | _ , q , Ï€' = wait (ch âŸ¨ q âŸ© â†­proc Ï€' P)
â†­proc Ï€ (close ch) rewrite â†­solo-inv Ï€ = close ch
â†­proc Ï€ (case (ch âŸ¨ p âŸ© (P , Q))) with â†­solo Ï€ p
... | _ , q , Ï€' = case (ch âŸ¨ q âŸ© (â†­proc (prep Ï€') P , â†­proc (prep Ï€') Q))
â†­proc Ï€ (select (ch âŸ¨ p âŸ© injâ‚ P)) with â†­solo Ï€ p
... | _ , q , Ï€' = select (ch âŸ¨ q âŸ© injâ‚ (â†­proc (prep Ï€') P))
â†­proc Ï€ (select (ch âŸ¨ p âŸ© injâ‚‚ P)) with â†­solo Ï€ p
... | _ , q , Ï€' = select (ch âŸ¨ q âŸ© injâ‚‚ (â†­proc (prep Ï€') P))
â†­proc Ï€ (join (ch âŸ¨ p âŸ© P)) with â†­solo Ï€ p
... | _ , q , Ï€' = join (ch âŸ¨ q âŸ© â†­proc (prep (prep Ï€')) P)
â†­proc Ï€ (fork (ch âŸ¨ p âŸ© (P âŸ¨ q âŸ© Q))) with â†­solo Ï€ p
... | _ , p' , Ï€' with â†­split Ï€' q
... | Î”â‚ , Î”â‚‚ , q' , Ï€â‚ , Ï€â‚‚ = fork (ch âŸ¨ p' âŸ© (â†­proc (prep Ï€â‚) P âŸ¨ q' âŸ© â†­proc (prep Ï€â‚‚) Q))
â†­proc Ï€ (all (ch âŸ¨ p âŸ© F)) with â†­solo Ï€ p
... | _ , q , Ï€' = all (ch âŸ¨ q âŸ© Î» X â†’ â†­proc (prep Ï€') (F X))
â†­proc Ï€ (ex (ch âŸ¨ p âŸ© P)) with â†­solo Ï€ p
... | _ , q , Ï€' = ex (ch âŸ¨ q âŸ© â†­proc (prep Ï€') P)
â†­proc Ï€ (server (ch âŸ¨ p âŸ© (un , P))) with â†­solo Ï€ p
... | _ , q , Ï€' = server (ch âŸ¨ q âŸ© (â†­un Ï€' un , â†­proc (prep Ï€') P))
â†­proc Ï€ (client (ch âŸ¨ p âŸ© P)) with â†­solo Ï€ p
... | _ , q , Ï€' = client (ch âŸ¨ q âŸ© â†­proc (prep Ï€') P)
â†­proc Ï€ (weaken (ch âŸ¨ p âŸ© P)) with â†­solo Ï€ p
... | _ , q , Ï€' = weaken (ch âŸ¨ q âŸ© â†­proc Ï€' P)
â†­proc Ï€ (contract (ch âŸ¨ p âŸ© P)) with â†­solo Ï€ p
... | _ , q , Ï€' = contract (ch âŸ¨ q âŸ© â†­proc (prep (prep Ï€')) P)
â†­proc Ï€ (cut (P âŸ¨ p âŸ© Q)) with â†­split Ï€ p
... | Î”â‚ , Î”â‚‚ , q , Ï€â‚ , Ï€â‚‚ = cut (â†­proc (prep Ï€â‚) P âŸ¨ q âŸ© â†­proc (prep Ï€â‚‚) Q)
\end{code}
