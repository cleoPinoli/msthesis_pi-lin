\section{Agda Formalization}
\label{sec:formalization}

\begin{code}[hide]
open import Data.Product using (_Ã—_; _,_; âˆƒ; âˆƒ-syntax)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; cong; congâ‚‚)
open import Data.List.Base using (List; []; _âˆ·_; [_]; _++_)
\end{code}

\subsection{Type Representation}
\label{sec:type-agda}

The representation of types is standard, with one constructor for each of the
forms described in \Cref{sec:calculus}.

\begin{code}
data Type : Set where
  ğŸ˜ ğŸ™ âŠ¥ âŠ¤          : Type
  Â¡ Â¿              : Type â†’ Type
  _&_ _âŠ•_ _âŠ—_ _â…‹_  : Type â†’ Type â†’ Type
\end{code}

The notion of duality is formalized as a \emph{relation} \AgdaDatatype{Dual}
such that $\AgdaDatatype{Dual}~A~B$ holds if and only if $A = \dual{B}$.

\begin{code}
data Dual : Type â†’ Type â†’ Set where
  d-ğŸ˜-âŠ¤  : Dual ğŸ˜ âŠ¤
  d-âŠ¤-ğŸ˜  : Dual âŠ¤ ğŸ˜
  d-ğŸ™-âŠ¥  : Dual ğŸ™ âŠ¥
  d-âŠ¥-ğŸ™  : Dual âŠ¥ ğŸ™
  d-!-?  : âˆ€{A B} â†’ Dual A B â†’ Dual (Â¡ A) (Â¿ B)
  d-?-!  : âˆ€{A B} â†’ Dual A B â†’ Dual (Â¿ A) (Â¡ B)
  d-&-âŠ•  : âˆ€{A B Aâ€² Bâ€²} â†’ Dual A Aâ€² â†’ Dual B Bâ€² â†’ Dual (A & B) (Aâ€² âŠ• Bâ€²)
  d-âŠ•-&  : âˆ€{A B Aâ€² Bâ€²} â†’ Dual A Aâ€² â†’ Dual B Bâ€² â†’ Dual (A âŠ• B) (Aâ€² & Bâ€²)
  d-âŠ—-â…‹  : âˆ€{A B Aâ€² Bâ€²} â†’ Dual A Aâ€² â†’ Dual B Bâ€² â†’ Dual (A âŠ— B) (Aâ€² â…‹ Bâ€²)
  d-â…‹-âŠ—  : âˆ€{A B Aâ€² Bâ€²} â†’ Dual A Aâ€² â†’ Dual B Bâ€² â†’ Dual (A â…‹ B) (Aâ€² âŠ— Bâ€²)
\end{code}

It is straightforward to prove that duality is a symmetric relation and that it
behaves as an involution. From this we prove that it acts as the function
$\dual\cdot$ defined in \Cref{sec:calculus}.

\begin{code}
dual-symm   : âˆ€{A B} â†’ Dual A B â†’ Dual B A
dual-inv    : âˆ€{A B C} â†’ Dual A B â†’ Dual B C â†’ A â‰¡ C
dual-fun-r  : âˆ€{A B C} â†’ Dual A B â†’ Dual A C â†’ B â‰¡ C
dual-fun-l  : âˆ€{A B C} â†’ Dual B A â†’ Dual C A â†’ B â‰¡ C
\end{code}
\begin{code}[hide]
dual-symm d-ğŸ˜-âŠ¤ = d-âŠ¤-ğŸ˜
dual-symm d-âŠ¤-ğŸ˜ = d-ğŸ˜-âŠ¤
dual-symm d-ğŸ™-âŠ¥ = d-âŠ¥-ğŸ™
dual-symm d-âŠ¥-ğŸ™ = d-ğŸ™-âŠ¥
dual-symm (d-!-? p) = d-?-! (dual-symm p)
dual-symm (d-?-! p) = d-!-? (dual-symm p)
dual-symm (d-&-âŠ• p q) = d-âŠ•-& (dual-symm p) (dual-symm q)
dual-symm (d-âŠ•-& p q) = d-&-âŠ• (dual-symm p) (dual-symm q)
dual-symm (d-âŠ—-â…‹ p q) = d-â…‹-âŠ— (dual-symm p) (dual-symm q)
dual-symm (d-â…‹-âŠ— p q) = d-âŠ—-â…‹ (dual-symm p) (dual-symm q)
\end{code}

\begin{code}[hide]
dual-inv d-ğŸ˜-âŠ¤ d-âŠ¤-ğŸ˜ = refl
dual-inv d-âŠ¤-ğŸ˜ d-ğŸ˜-âŠ¤ = refl
dual-inv d-ğŸ™-âŠ¥ d-âŠ¥-ğŸ™ = refl
dual-inv d-âŠ¥-ğŸ™ d-ğŸ™-âŠ¥ = refl
dual-inv (d-!-? p) (d-?-! q) = cong Â¡ (dual-inv p q)
dual-inv (d-?-! p) (d-!-? q) = cong Â¿ (dual-inv p q)
dual-inv (d-&-âŠ• p q) (d-âŠ•-& r s) = congâ‚‚ _&_ (dual-inv p r) (dual-inv q s)
dual-inv (d-âŠ•-& p q) (d-&-âŠ• r s) = congâ‚‚ _âŠ•_ (dual-inv p r) (dual-inv q s)
dual-inv (d-âŠ—-â…‹ p q) (d-â…‹-âŠ— r s) = congâ‚‚ _âŠ—_ (dual-inv p r) (dual-inv q s)
dual-inv (d-â…‹-âŠ— p q) (d-âŠ—-â…‹ r s) = congâ‚‚ _â…‹_ (dual-inv p r) (dual-inv q s)

dual-fun-r d e = dual-inv (dual-symm d) e

dual-fun-l d e = dual-inv d (dual-symm e)
\end{code}

\subsection{Context Representation}
\label{sec:context-agda}

We are going to adopt a nameless representation of channels whereby a channel is
identified by its position in a typing context. This representation is akin to
using De Bruijn indices, except that the index, instead of being represented
explicitly by a natural number, is computable from the \emph{proof} that the
type of the channel belong to the typing context.
%
Typing contexts are represented using \emph{lists} of types, where the
(polymorphic) \AgdaDatatype{List} type is defined in Agdaâ€²s standard library.

\begin{code}
Context : Set
Context = List Type
\end{code}

The most important operation concerning typing contexts is \emph{splitting}. The
splitting of $\ContextC$ into $\ContextD$ and $\ContextE$, which is denoted by
$\Splitting\ContextC\ContextD\ContextE$, represents the fact that $\ContextC$
contains all the types contained in $\ContextD$ and $\ContextE$, preserving both
their overall \emph{multiplicity} and also their relative \emph{order} within
$\ContextD$ and $\ContextE$. A \emph{proof} of
$\Splitting\ContextC\ContextD\ContextE$ shows how the types in $\ContextC$ are
distributed in $\ContextD$ and $\ContextE$ from left to right.

\begin{code}[hide]
infix 4 _â‰ƒ_+_ _â‰ƒ_,_
\end{code}
\begin{code}
data _â‰ƒ_+_ : Context â†’ Context â†’ Context â†’ Set where
  split-e  : [] â‰ƒ [] + []
  split-l  : âˆ€{A Î“ Î” Î˜} â†’ Î“ â‰ƒ Î” + Î˜ â†’ A âˆ· Î“ â‰ƒ A âˆ· Î” + Î˜
  split-r  : âˆ€{A Î“ Î” Î˜} â†’ Î“ â‰ƒ Î” + Î˜ â†’ A âˆ· Î“ â‰ƒ Î” + A âˆ· Î˜
\end{code}

As an example, below is the splitting of the context $[A, B, C, D]$ into $[A,
D]$ and $[B, C]$. Note how the sequence of \AgdaInductiveConstructor{split-l}
and \AgdaInductiveConstructor{split-r} applications determines where each of the
types in $[A, B, C, D]$ ends up in $[A, D]$ and $[B, C]$.

\begin{code}[hide]
module _ where
  postulate A B C D : Type
\end{code}
\begin{code}
  splitting-example : (A âˆ· B âˆ· C âˆ· D âˆ· []) â‰ƒ (A âˆ· D âˆ· []) + (B âˆ· C âˆ· [])
  splitting-example = split-l (split-r (split-r (split-l split-e)))
\end{code}

It is often the case that the context $\ContextD$ in a splitting
$\Splitting\ContextC\ContextD\ContextE$ is a singleton list $[A]$. For this
particular case, we introduce a dedicated notation that allows us to represent
this case in a more compact and readable way, as
$\SimpleSplitting\ContextC{A}\ContextE$.

\begin{code}
_â‰ƒ_,_ : Context â†’ Type â†’ Context â†’ Set
Î“ â‰ƒ A , Î” = Î“ â‰ƒ [ A ] + Î”
\end{code}

Context splitting enjoys a number of expected properties. In particular, it is
easy to see that splitting is commutative and that the empty context is both a
left and right unit of splitting.

\begin{code}
+-comm    : âˆ€{Î“ Î” Î˜} â†’ Î“ â‰ƒ Î” + Î˜ â†’ Î“ â‰ƒ Î˜ + Î”
+-unit-l  : âˆ€{Î“} â†’ Î“ â‰ƒ [] + Î“
+-unit-r  : âˆ€{Î“} â†’ Î“ â‰ƒ Î“ + []
\end{code}
\begin{code}[hide]
+-comm split-e = split-e
+-comm (split-l p) = split-r (+-comm p)
+-comm (split-r p) = split-l (+-comm p)

+-unit-l {[]} = split-e
+-unit-l {_ âˆ· _} = split-r +-unit-l

+-unit-r = +-comm +-unit-l
\end{code}

Context splitting is also associative in a sense that is made precise below. If
we write $\ContextD + \ContextE$ for some $\ContextC$ such that $Î“ â‰ƒ Î” + Î˜$, then
we can prove that $Î“_1 + (Î“_2 + Î“_3) = (Î“_1 + Î“_2) + Î“_3$.

\begin{code}
+-assoc-r  : âˆ€{Î“ Î” Î˜ Î”â€² Î˜â€²} â†’ Î“ â‰ƒ Î” + Î˜ â†’ Î˜ â‰ƒ Î”â€² + Î˜â€² â†’
             âˆƒ[ Î“â€² ] Î“â€² â‰ƒ Î” + Î”â€² Ã— Î“ â‰ƒ Î“â€² + Î˜â€²
+-assoc-l  : âˆ€{Î“ Î” Î˜ Î”â€² Î˜â€²} â†’ Î“ â‰ƒ Î” + Î˜ â†’ Î” â‰ƒ Î”â€² + Î˜â€² â†’
             âˆƒ[ Î“â€² ] Î“â€² â‰ƒ Î˜â€² + Î˜ Ã— Î“ â‰ƒ Î”â€² + Î“â€²
\end{code}
\begin{code}[hide]
+-assoc-r split-e split-e = [] , split-e , split-e
+-assoc-r (split-l p) q with +-assoc-r p q
... | _ , pâ€² , qâ€² = _ , split-l pâ€² , split-l qâ€²
+-assoc-r (split-r p) (split-l q) with +-assoc-r p q
... | _ , pâ€² , qâ€² = _ , split-r pâ€² , split-l qâ€²
+-assoc-r (split-r p) (split-r q) with +-assoc-r p q
... | _ , pâ€² , qâ€² = _ , pâ€² , split-r qâ€²

+-assoc-l p q with +-assoc-r (+-comm p) (+-comm q)
... | Î” , r , pâ€² = Î” , +-comm r , +-comm pâ€²

+-empty-l : âˆ€{Î“ Î”} â†’ Î“ â‰ƒ [] + Î” â†’ Î“ â‰¡ Î”
+-empty-l split-e = refl
+-empty-l (split-r p) = cong (_ âˆ·_) (+-empty-l p)

+-sing-l : âˆ€{A B Î“} â†’ [ A ] â‰ƒ B , Î“ â†’ A â‰¡ B Ã— Î“ â‰¡ []
+-sing-l (split-l split-e) = refl , refl
\end{code}

\subsection{Context Permutations}
\label{sec:permutation-agda}
