\section{Agda Formalization}
\label{sec:formalization}

\begin{code}[hide]
open import Data.Bool using (Bool; if_then_else_)
open import Data.Product using (_Ã—_; _,_; âˆƒ; âˆƒ-syntax)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; cong; congâ‚‚)
open import Data.List.Base using (List; []; _âˆ·_; [_]; _++_)
\end{code}

\subsection{Type Representation}
\label{sec:type-agda}

The representation of types is standard, with one constructor for each of the
forms described in \Cref{sec:calculus}.

\begin{code}
data Type : Set where
  ğŸ˜ ğŸ™ âŠ¥ âŠ¤          : Type
  Â¡ Â¿              : Type â†’ Type
  _&_ _âŠ•_ _âŠ—_ _â…‹_  : Type â†’ Type â†’ Type
\end{code}

The notion of duality is formalized as a \emph{relation} \AgdaDatatype{Dual}
such that $\AgdaDatatype{Dual}~A~B$ holds if and only if $A = \dual{B}$.

\begin{code}
data Dual : Type â†’ Type â†’ Set where
  d-ğŸ˜-âŠ¤  : Dual ğŸ˜ âŠ¤
  d-âŠ¤-ğŸ˜  : Dual âŠ¤ ğŸ˜
  d-ğŸ™-âŠ¥  : Dual ğŸ™ âŠ¥
  d-âŠ¥-ğŸ™  : Dual âŠ¥ ğŸ™
  d-!-?  : âˆ€{A B} â†’ Dual A B â†’ Dual (Â¡ A) (Â¿ B)
  d-?-!  : âˆ€{A B} â†’ Dual A B â†’ Dual (Â¿ A) (Â¡ B)
  d-&-âŠ•  : âˆ€{A B Aâ€² Bâ€²} â†’ Dual A Aâ€² â†’ Dual B Bâ€² â†’ Dual (A & B) (Aâ€² âŠ• Bâ€²)
  d-âŠ•-&  : âˆ€{A B Aâ€² Bâ€²} â†’ Dual A Aâ€² â†’ Dual B Bâ€² â†’ Dual (A âŠ• B) (Aâ€² & Bâ€²)
  d-âŠ—-â…‹  : âˆ€{A B Aâ€² Bâ€²} â†’ Dual A Aâ€² â†’ Dual B Bâ€² â†’ Dual (A âŠ— B) (Aâ€² â…‹ Bâ€²)
  d-â…‹-âŠ—  : âˆ€{A B Aâ€² Bâ€²} â†’ Dual A Aâ€² â†’ Dual B Bâ€² â†’ Dual (A â…‹ B) (Aâ€² âŠ— Bâ€²)
\end{code}

It is straightforward to prove that duality is a symmetric relation and that it
behaves as an involution. From this we prove that it acts as the function
$\dual\cdot$ defined in \Cref{sec:calculus}.

\begin{code}
dual-symm   : âˆ€{A B} â†’ Dual A B â†’ Dual B A
dual-inv    : âˆ€{A B C} â†’ Dual A B â†’ Dual B C â†’ A â‰¡ C
dual-fun-r  : âˆ€{A B C} â†’ Dual A B â†’ Dual A C â†’ B â‰¡ C
dual-fun-l  : âˆ€{A B C} â†’ Dual B A â†’ Dual C A â†’ B â‰¡ C
\end{code}
\begin{code}[hide]
dual-symm d-ğŸ˜-âŠ¤ = d-âŠ¤-ğŸ˜
dual-symm d-âŠ¤-ğŸ˜ = d-ğŸ˜-âŠ¤
dual-symm d-ğŸ™-âŠ¥ = d-âŠ¥-ğŸ™
dual-symm d-âŠ¥-ğŸ™ = d-ğŸ™-âŠ¥
dual-symm (d-!-? p) = d-?-! (dual-symm p)
dual-symm (d-?-! p) = d-!-? (dual-symm p)
dual-symm (d-&-âŠ• p q) = d-âŠ•-& (dual-symm p) (dual-symm q)
dual-symm (d-âŠ•-& p q) = d-&-âŠ• (dual-symm p) (dual-symm q)
dual-symm (d-âŠ—-â…‹ p q) = d-â…‹-âŠ— (dual-symm p) (dual-symm q)
dual-symm (d-â…‹-âŠ— p q) = d-âŠ—-â…‹ (dual-symm p) (dual-symm q)
\end{code}

\begin{code}[hide]
dual-inv d-ğŸ˜-âŠ¤ d-âŠ¤-ğŸ˜ = refl
dual-inv d-âŠ¤-ğŸ˜ d-ğŸ˜-âŠ¤ = refl
dual-inv d-ğŸ™-âŠ¥ d-âŠ¥-ğŸ™ = refl
dual-inv d-âŠ¥-ğŸ™ d-ğŸ™-âŠ¥ = refl
dual-inv (d-!-? p) (d-?-! q) = cong Â¡ (dual-inv p q)
dual-inv (d-?-! p) (d-!-? q) = cong Â¿ (dual-inv p q)
dual-inv (d-&-âŠ• p q) (d-âŠ•-& r s) = congâ‚‚ _&_ (dual-inv p r) (dual-inv q s)
dual-inv (d-âŠ•-& p q) (d-&-âŠ• r s) = congâ‚‚ _âŠ•_ (dual-inv p r) (dual-inv q s)
dual-inv (d-âŠ—-â…‹ p q) (d-â…‹-âŠ— r s) = congâ‚‚ _âŠ—_ (dual-inv p r) (dual-inv q s)
dual-inv (d-â…‹-âŠ— p q) (d-âŠ—-â…‹ r s) = congâ‚‚ _â…‹_ (dual-inv p r) (dual-inv q s)

dual-fun-r d e = dual-inv (dual-symm d) e

dual-fun-l d e = dual-inv d (dual-symm e)
\end{code}

\subsection{Context Representation}
\label{sec:context-agda}

We are going to adopt a nameless representation of channels whereby a channel is
identified by its position in a typing context. This representation is akin to
using De Bruijn indices, except that the index, instead of being represented
explicitly by a natural number, is computable from the \emph{proof} that the
type of the channel belong to the typing context.
%
Typing contexts are represented using \emph{lists} of types, where the
(polymorphic) \AgdaDatatype{List} type is defined in Agdaâ€²s standard library.

\begin{code}
Context : Set
Context = List Type
\end{code}

The most important operation concerning typing contexts is \emph{splitting}. The
splitting of $\ContextC$ into $\ContextD$ and $\ContextE$, which is denoted by
$\Splitting\ContextC\ContextD\ContextE$, represents the fact that $\ContextC$
contains all the types contained in $\ContextD$ and $\ContextE$, preserving both
their overall \emph{multiplicity} and also their relative \emph{order} within
$\ContextD$ and $\ContextE$. A \emph{proof} of
$\Splitting\ContextC\ContextD\ContextE$ shows how the types in $\ContextC$ are
distributed in $\ContextD$ and $\ContextE$ from left to right.

\begin{code}[hide]
infix 4 _â‰ƒ_+_ _â‰ƒ_,_
\end{code}
\begin{code}
data _â‰ƒ_+_ : Context â†’ Context â†’ Context â†’ Set where
  split-e  : [] â‰ƒ [] + []
  split-l  : âˆ€{A Î“ Î” Î˜} â†’ Î“ â‰ƒ Î” + Î˜ â†’ A âˆ· Î“ â‰ƒ A âˆ· Î” + Î˜
  split-r  : âˆ€{A Î“ Î” Î˜} â†’ Î“ â‰ƒ Î” + Î˜ â†’ A âˆ· Î“ â‰ƒ Î” + A âˆ· Î˜
\end{code}

As an example, below is the splitting of the context $[A, B, C, D]$ into $[A,
D]$ and $[B, C]$. Note how the sequence of \AgdaInductiveConstructor{split-l}
and \AgdaInductiveConstructor{split-r} applications determines where each of the
types in $[A, B, C, D]$ ends up in $[A, D]$ and $[B, C]$.

\begin{code}[hide]
module _ where
  postulate A B C D : Type
\end{code}
\begin{code}
  splitting-example : (A âˆ· B âˆ· C âˆ· D âˆ· []) â‰ƒ (A âˆ· D âˆ· []) + (B âˆ· C âˆ· [])
  splitting-example = split-l (split-r (split-r (split-l split-e)))
\end{code}

It is often the case that the context $\ContextD$ in a splitting
$\Splitting\ContextC\ContextD\ContextE$ is a singleton list $[A]$. For this
particular case, we introduce a dedicated notation that allows us to represent
this case in a more compact and readable way, as
$\SimpleSplitting\ContextC{A}\ContextE$.

\begin{code}
_â‰ƒ_,_ : Context â†’ Type â†’ Context â†’ Set
Î“ â‰ƒ A , Î” = Î“ â‰ƒ [ A ] + Î”
\end{code}

Context splitting enjoys a number of expected properties. In particular, it is
easy to see that splitting is commutative and that the empty context is both a
left and right unit of splitting.

\begin{code}
+-comm    : âˆ€{Î“ Î” Î˜} â†’ Î“ â‰ƒ Î” + Î˜ â†’ Î“ â‰ƒ Î˜ + Î”
+-unit-l  : âˆ€{Î“} â†’ Î“ â‰ƒ [] + Î“
+-unit-r  : âˆ€{Î“} â†’ Î“ â‰ƒ Î“ + []
\end{code}
\begin{code}[hide]
+-comm split-e = split-e
+-comm (split-l p) = split-r (+-comm p)
+-comm (split-r p) = split-l (+-comm p)

+-unit-l {[]} = split-e
+-unit-l {_ âˆ· _} = split-r +-unit-l

+-unit-r = +-comm +-unit-l
\end{code}

Context splitting is also associative in a sense that is made precise below. If
we write $\ContextD + \ContextE$ for some $\ContextC$ such that $Î“ â‰ƒ Î” + Î˜$, then
we can prove that $Î“_1 + (Î“_2 + Î“_3) = (Î“_1 + Î“_2) + Î“_3$.

\begin{code}
+-assoc-r  : âˆ€{Î“ Î” Î˜ Î”â€² Î˜â€²} â†’ Î“ â‰ƒ Î” + Î˜ â†’ Î˜ â‰ƒ Î”â€² + Î˜â€² â†’
             âˆƒ[ Î“â€² ] Î“â€² â‰ƒ Î” + Î”â€² Ã— Î“ â‰ƒ Î“â€² + Î˜â€²
+-assoc-l  : âˆ€{Î“ Î” Î˜ Î”â€² Î˜â€²} â†’ Î“ â‰ƒ Î” + Î˜ â†’ Î” â‰ƒ Î”â€² + Î˜â€² â†’
             âˆƒ[ Î“â€² ] Î“â€² â‰ƒ Î˜â€² + Î˜ Ã— Î“ â‰ƒ Î”â€² + Î“â€²
\end{code}
\begin{code}[hide]
+-assoc-r split-e split-e = [] , split-e , split-e
+-assoc-r (split-l p) q with +-assoc-r p q
... | _ , pâ€² , qâ€² = _ , split-l pâ€² , split-l qâ€²
+-assoc-r (split-r p) (split-l q) with +-assoc-r p q
... | _ , pâ€² , qâ€² = _ , split-r pâ€² , split-l qâ€²
+-assoc-r (split-r p) (split-r q) with +-assoc-r p q
... | _ , pâ€² , qâ€² = _ , pâ€² , split-r qâ€²

+-assoc-l p q with +-assoc-r (+-comm p) (+-comm q)
... | Î” , r , pâ€² = Î” , +-comm r , +-comm pâ€²

+-empty-l : âˆ€{Î“ Î”} â†’ Î“ â‰ƒ [] + Î” â†’ Î“ â‰¡ Î”
+-empty-l split-e = refl
+-empty-l (split-r p) = cong (_ âˆ·_) (+-empty-l p)

+-sing-l : âˆ€{A B Î“} â†’ [ A ] â‰ƒ B , Î“ â†’ A â‰¡ B Ã— Î“ â‰¡ []
+-sing-l (split-l split-e) = refl , refl
\end{code}

\subsection{Context Permutations}
\label{sec:permutation-agda}

\begin{code}
data _#_ : Context â†’ Context â†’ Set where
  #refl  : âˆ€{Î“} â†’ Î“ # Î“
  #here  : âˆ€{A B Î“} â†’ (A âˆ· B âˆ· Î“) # (B âˆ· A âˆ· Î“)
  #next  : âˆ€{A Î“ Î”} â†’ Î“ # Î” â†’ (A âˆ· Î“) # (A âˆ· Î”)
  #tran  : âˆ€{Î“ Î” Î˜} â†’ Î“ # Î” â†’ Î” # Î˜ â†’ Î“ # Î˜

#sym : âˆ€{Î“ Î”} â†’ Î“ # Î” â†’ Î” # Î“
#sym #refl = #refl
#sym #here = #here
#sym (#next Ï€) = #next (#sym Ï€)
#sym (#tran Ï€ Ï€â€²) = #tran (#sym Ï€â€²) (#sym Ï€)

#empty-inv : âˆ€{Î“} â†’ [] # Î“ â†’ Î“ â‰¡ []
#empty-inv #refl = refl
#empty-inv (#tran Ï€ Ï€â€²) rewrite #empty-inv Ï€ | #empty-inv Ï€â€² = refl

#singleton-inv : âˆ€{A Î“} â†’ [ A ] # Î“ â†’ Î“ â‰¡ [ A ]
#singleton-inv {Î“ = Î“} #refl = refl
#singleton-inv {Î“ = Î“} (#next Ï€) rewrite #empty-inv Ï€ = refl
#singleton-inv {Î“ = Î“} (#tran Ï€ Ï€â€²) rewrite #singleton-inv Ï€ | #singleton-inv Ï€â€² = refl

#rot : âˆ€{A B C Î“} â†’ (A âˆ· B âˆ· C âˆ· Î“) # (C âˆ· A âˆ· B âˆ· Î“)
#rot = #tran (#next #here) #here

#cons : âˆ€{A Î“ Î”} â†’ Î“ â‰ƒ A , Î” â†’ (A âˆ· Î”) # Î“
#cons (split-l p) with +-empty-l p
... | refl = #refl
#cons (split-r p) = #tran #here (#next (#cons p))

#split : âˆ€{Î“ Î“â‚ Î“â‚‚ Î”} â†’ Î“ # Î” â†’ Î“ â‰ƒ Î“â‚ + Î“â‚‚ â†’ âˆƒ[ Î”â‚ ] âˆƒ[ Î”â‚‚ ] (Î” â‰ƒ Î”â‚ + Î”â‚‚ Ã— Î“â‚ # Î”â‚ Ã— Î“â‚‚ # Î”â‚‚)
#split #refl p = _ , _ , p , #refl , #refl
#split (#next Ï€) (split-l p) with #split Ï€ p
... | Î”â‚ , Î”â‚‚ , q , Ï€â‚ , Ï€â‚‚ = _ âˆ· Î”â‚ , Î”â‚‚ , split-l q , #next Ï€â‚ , Ï€â‚‚
#split (#next Ï€) (split-r p) with #split Ï€ p
... | Î”â‚ , Î”â‚‚ , q , Ï€â‚ , Ï€â‚‚ = Î”â‚ , _ âˆ· Î”â‚‚ , split-r q , Ï€â‚ , #next Ï€â‚‚
#split #here (split-l (split-l p)) = _ , _ , split-l (split-l p) , #here , #refl
#split #here (split-l (split-r p)) = _ , _ , split-r (split-l p) , #refl , #refl
#split #here (split-r (split-l p)) = _ , _ , split-l (split-r p) , #refl , #refl
#split #here (split-r (split-r p)) = _ , _ , split-r (split-r p) , #refl , #here
#split (#tran Ï€ Ï€â€²) p with #split Ï€ p
... | Î˜â‚ , Î˜â‚‚ , pâ€² , Ï€â‚ , Ï€â‚‚ with #split Ï€â€² pâ€²
... | Î”â‚ , Î”â‚‚ , q , Ï€â‚â€² , Ï€â‚‚â€² = Î”â‚ , Î”â‚‚ , q , #tran Ï€â‚ Ï€â‚â€² , #tran Ï€â‚‚ Ï€â‚‚â€²

#one+ : âˆ€{A Î“ Î“â€² Î”} â†’ Î“ # Î” â†’ Î“ â‰ƒ A , Î“â€² â†’ âˆƒ[ Î”â€² ] (Î” â‰ƒ A , Î”â€² Ã— Î“â€² # Î”â€²)
#one+ Ï€ p with #split Ï€ p
... | _ , _ , q , Ï€â‚ , Ï€â‚‚ rewrite #singleton-inv Ï€â‚ = _ , q , Ï€â‚‚

#shift : âˆ€{Î“ A Î”} â†’ (Î“ ++ A âˆ· Î”) # (A âˆ· Î“ ++ Î”)
#shift {[]} = #refl
#shift {B âˆ· Î“} = #tran (#next #shift) #here

+++# : âˆ€{Î“ Î“â‚ Î“â‚‚} â†’ Î“ â‰ƒ Î“â‚ + Î“â‚‚ â†’ (Î“â‚ ++ Î“â‚‚) # Î“
+++# split-e = #refl
+++# (split-l p) = #next (+++# p)
+++# (split-r p) = #tran #shift (#next (+++# p))

#left : âˆ€{Î“ Î” Î˜} â†’ Î“ # Î” â†’ (Î˜ ++ Î“) # (Î˜ ++ Î”)
#left {Î˜ = []} Ï€ = Ï€
#left {Î˜ = _ âˆ· Î˜} Ï€ = #next (#left Ï€)

data Un : Context â†’ Set where
  un-[]  : Un []
  un-âˆ·   : âˆ€{A Î“} â†’ Un Î“ â†’ Un (Â¿ A âˆ· Î“)

#un : âˆ€{Î“ Î”} â†’ Î“ # Î” â†’ Un Î“ â†’ Un Î”
#un #refl un = un
#un (#next Ï€) (un-âˆ· un) = un-âˆ· (#un Ï€ un)
#un #here (un-âˆ· (un-âˆ· un)) = un-âˆ· (un-âˆ· un)
#un (#tran Ï€ Ï€â€²) un = #un Ï€â€² (#un Ï€ un)

#un+ : âˆ€{Î“ Î“â‚ Î“â‚‚} â†’ Î“ â‰ƒ Î“â‚ + Î“â‚‚ â†’ Un Î“â‚ â†’ Un Î“â‚‚ â†’ Un Î“
#un+ split-e un-[] un-[] = un-[]
#un+ (split-l p) (un-âˆ· unâ‚) unâ‚‚ = un-âˆ· (#un+ p unâ‚ unâ‚‚)
#un+ (split-r p) unâ‚ (un-âˆ· unâ‚‚) = un-âˆ· (#un+ p unâ‚ unâ‚‚)
\end{code}

\subsection{Process Representation}
\label{sec:process-agda}

CO-DE BRUIJN INDICES

We adopt an \emph{intrinsically typed} representation of processes, so that a
process is also a proof derivation showing that the process is well typed. This
choice increases the effort in the definition of the datatypes for processes and
their operational semantics, but it pays off in the rest of the formalization
for a number of reasons:

\begin{itemize}
\item channel names are encoded in the context splitting proofs occurring within
  processes, hence they do not need to be represented explicitly.
\item processes and typing rules are conflated in the same datatype, thus
  reducing the overall number of datatypes in the formalization;
\item the typing preservation results are embedded in the definition of the
  operational semantics of processes and do not need to be proved separately.
\end{itemize}

We now illustrate the definition of the \AgdaDatatype{Process} datatype and
describe each constructor in detail. The datatype is indexed by a typing
context:

\begin{AgdaAlign}
\begin{code}
data Process : Context â†’ Set where
   link      : âˆ€{Î“ A B} (d : Dual A B) (p : Î“ â‰ƒ [ A ] + [ B ]) â†’ Process Î“
\end{code}

A \AgdaInductiveConstructor{link} process is well typed in a typing context with
exactly two types $A$ and $B$ which must be related by duality. We use a proof
$p$ that $\Context \simeq [A] + [B]$ instead of requiring $\Context$ to be
simply $[A,B]$ so that it becomes straightforward to define \SLink using
\AgdaFunction{dual-symm} and \AgdaFunction{+-comm}.

\begin{code}
   fail      : âˆ€{Î“ Î”} (p : Î“ â‰ƒ âŠ¤ , Î”) â†’ Process Î“
\end{code}

A \AgdaInductiveConstructor{fail} process simply requires the presence of $\Top$
in the typing context.

\begin{code}
   close     : Process [ ğŸ™ ]
\end{code}

A \AgdaInductiveConstructor{close} process is well typed in the singleton
context $[\One]$.

\begin{code}
   wait      : âˆ€{Î“ Î”} (p : Î“ â‰ƒ âŠ¥ , Î”) â†’ Process Î” â†’ Process Î“
\end{code}

A \AgdaInductiveConstructor{wait} process is well typed in any context
$\ContextC$ that contains $\Bot$ and whose residual $\ContextD$ allows the
continuation to be well typed.

\begin{code}
   select    : âˆ€{Î“ Î” A B} (x : Bool) (p : Î“ â‰ƒ A âŠ• B , Î”) â†’
               Process ((if x then A else B) âˆ· Î”) â†’ Process Î“
\end{code}

We represent the tags $\InTag_1$ and $\InTag_2$ with Agdaâ€²s boolean values
\AgdaInductiveConstructor{True} and \AgdaInductiveConstructor{False}. In this
way we can use a single constructor \AgdaInductiveConstructor{select} for the
selections $\Select\x{\InTag_i}.P$. According to the semantics of \Calculus, the
channel on which the selection is performed is consumed and the continuation
process uses a fresh continuation channel. As a consequence, the type of the
continuation channel, which is either $A$ or $B$ depending on the value of the
tag $x$, is \emph{prepended} in front of the typing context used to type the
continuation process.

\begin{code}
   case      : âˆ€{Î“ Î” A B} (p : Î“ â‰ƒ A & B , Î”) â†’
               Process (A âˆ· Î”) â†’ Process (B âˆ· Î”) â†’ Process Î“
\end{code}

A \AgdaInductiveConstructor{case} process has two possible continuations. Note
again that the continuation channel, which is received along with the tag, has
either type $A$ or type $B$ depending on the tag and its type is prepended to
the typing context of the continuation process since it is the newest channel.

\begin{code}
   fork      : âˆ€{Î“ Î” Î“â‚ Î“â‚‚ A B} (p : Î“ â‰ƒ A âŠ— B , Î”) (q : Î” â‰ƒ Î“â‚ + Î“â‚‚) â†’
               Process (A âˆ· Î“â‚) â†’ Process (B âˆ· Î“â‚‚) â†’ Process Î“
\end{code}

A \AgdaInductiveConstructor{fork} process creates two fresh continuation
channels and spaws two continuation processes. Since context splitting is a
ternary relation, we need two splitting proofs $p$ and $q$ to isolate the type
$A \Ten B$ of channel on which the pair of continuation channels is sent and to
distribute the remaining channel across the two continuation processes.

\begin{code}
   join      : âˆ€{Î“ Î” A B} (p : Î“ â‰ƒ A â…‹ B , Î”) â†’
               Process (B âˆ· A âˆ· Î”) â†’ Process Î“
\end{code}

The \AgdaInductiveConstructor{join} process has a single continuation which uses
the pair of continuation channels received from a channel of type $A \Par B$.
Note that $B$ is prepended in front of $A$, somewhat implying that the second
continuation is bound \emph{after} the first even though, from a technical
standpoint, both continuations are bound simultaneously. We could have prepended
the types $A$ and $B$ also in the opposite order, provided that the reduction
rule \RFork (formalized in \Cref{sec:semantics-agda}) is suitably adjusted.

\begin{code}
   server    : âˆ€{Î“ Î” A} (p : Î“ â‰ƒ Â¡ A , Î”) (un : Un Î”) â†’
               Process (A âˆ· Î”) â†’ Process Î“
\end{code}

A \AgdaInductiveConstructor{server} constructor introduces a channel of type
$\OfCourse A$ given a continuation process that consumes a channel of type $A$
and a proof $\mathit{un}$ that every other channel in $\ContextD$ is
unrestricted.

\begin{code}
   client    : âˆ€{Î“ Î” A} (p : Î“ â‰ƒ Â¿ A , Î”) â†’ Process (A âˆ· Î”) â†’ Process Î“
   weaken    : âˆ€{Î“ Î” A} (p : Î“ â‰ƒ Â¿ A , Î”) â†’ Process Î” â†’ Process Î“
   contract  : âˆ€{Î“ Î” A} (p : Î“ â‰ƒ Â¿ A , Î”) â†’ Process (Â¿ A âˆ· Â¿ A âˆ· Î”) â†’ Process Î“
\end{code}

The constructors \AgdaInductiveConstructor{client},
\AgdaInductiveConstructor{weaken} and \AgdaInductiveConstructor{contract}
introduce a channel of type $\WhyNot A$ and follow the same pattern of the
previous process forms. Note that, in the case of
\AgdaInductiveConstructor{contract}, the contraction of $\WhyNot A$ applies to
the first two channels in the typing context of the continuation. This is
consistent with the fact that \Calculus uses an explicit prefix
$\Contract\x\y\z$ that models contraction and binds $y$ and $z$ in the
continuation process. In a pen-and-paper presentation, like the one by
Wadler~\citep{Wadler14}, it is arguably more convenient to have weaking and
contraction typing rules without the corresponding process forms.

\begin{code}
   cut       : âˆ€{Î“ Î“â‚ Î“â‚‚ A B} (d : Dual A B) (p : Î“ â‰ƒ Î“â‚ + Î“â‚‚) â†’
               Process (A âˆ· Î“â‚) â†’ Process (B âˆ· Î“â‚‚) â†’ Process Î“
\end{code}

A \AgdaInductiveConstructor{cut} process incorporates a duality proof for the
peer endpoints of the channel being restricted and a splitting proof that
distributes the free channels among the two parallel processes.

\end{AgdaAlign}

\begin{code}
#process : âˆ€{Î“ Î”} â†’ Î“ # Î” â†’ Process Î“ â†’ Process Î”
\end{code}
\begin{code}[hide]
#process Ï€ (link d p) with #one+ Ï€ p
... | Î”â€² , q , Ï€â€² with #singleton-inv Ï€â€²
... | refl = link d q
#process Ï€ close with #singleton-inv Ï€
... | refl = close
#process Ï€ (fail p) with #one+ Ï€ p
... | Î”â€² , q , Ï€â€² = fail q
#process Ï€ (wait p P) with #one+ Ï€ p
... | Î”â€² , q , Ï€â€² = wait q (#process Ï€â€² P)
#process Ï€ (select x p P) with #one+ Ï€ p
... | Î”â€² , q , Ï€â€² = select x q (#process (#next Ï€â€²) P)
#process Ï€ (case p P Q) with #one+ Ï€ p
... | Î”â€² , q , Ï€â€² = case q (#process (#next Ï€â€²) P) (#process (#next Ï€â€²) Q)
#process Ï€ (fork p q P Q) with #one+ Ï€ p
... | Î”â€² , pâ€² , Ï€â€² with #split Ï€â€² q
... | Î”â‚ , Î”â‚‚ , qâ€² , Ï€â‚ , Ï€â‚‚ = fork pâ€² qâ€² (#process (#next Ï€â‚) P) (#process (#next Ï€â‚‚) Q)
#process Ï€ (join p P) with #one+ Ï€ p
... | Î”â€² , q , Ï€â€² = join q (#process (#next (#next Ï€â€²)) P)
#process Ï€ (cut d p P Q) with #split Ï€ p
... | Î”â‚ , Î”â‚‚ , q , Ï€â‚ , Ï€â‚‚ = cut d q (#process (#next Ï€â‚) P) (#process (#next Ï€â‚‚) Q)
#process Ï€ (server p un P) with #one+ Ï€ p
... | Î”â€² , q , Ï€â€² = server q (#un Ï€â€² un) (#process (#next Ï€â€²) P)
#process Ï€ (client p P) with #one+ Ï€ p
... | Î”â€² , q , Ï€â€² = client q (#process (#next Ï€â€²) P)
#process Ï€ (weaken p P) with #one+ Ï€ p
... | Î”â€² , q , Ï€â€² = weaken q (#process Ï€â€² P)
#process Ï€ (contract p P) with #one+ Ï€ p
... | Î”â€² , q , Ï€â€² = contract q (#process (#next (#next Ï€â€²)) P)
\end{code}

\subsection{Operational Semantics}
\label{sec:semantics-agda}

