\section{Related Work}
\label{sec:related}

We have compared our formalization with others that have appeared in the
literature and for which we were able to retrieve the source code. We have
looked at those formalizations that include the following characteristics:
\begin{itemize}
\item syntax and reduction/evaluation semantics for a calculus with support for
    binary sessions, either natively or through their encoding in terms of
    linear channels~\cite{KobayashiPierceTurner99,Kobayashi02b};
\item a type system along with the usual typing preservation results;
\item a proof of global progress/deadlock freedom, for those type systems that
    enforce it.
\end{itemize}

\citet{GotoEtAl16} describe the formalization of a session-based variant of the
$\pi$-calculus which supports channel polymorphism. This is the oldest
formalization of a session-based calculus for which we were able to retrieve the
source code (the work of \citet{Gay01} predates this one, but its source code is
not publicly available any more).

\citet{Thiemann19} formalizes a subset of \GV~\citep{GayVasconcelos10}, a
functional language extended with session communication primitives, along with
an interpreter.

\citet{RouvoetPoulsenKrebbersVisser20} present a library of abstractions
inspired to separation logic aiding the formalization of interpreters for
computing models supported by linear type systems. One of the presented case
studies is the formalization of a fragment of \GV~\citep{Wadler14}.

% as case study for their approach based on separation logic, which we have
% partially taken inspiration from for the representation of processes
% (\cref{sec:context-agda,sec:process-agda}). Their formalization adopts the same
% intrinsically-typed representation of processes with nameless channels as our
% own, but their formalization focuses on the implementation of an interpreter (no
% small-step semantics is defined) and subject reduction is 

\citet{CastroFerreiraYoshida20} describe EMTST, a library for the formalization
of session type systems which includes as case studies the session calculus of
\citet{HondaVasconcelosKubo98} (called ``original system'') and a revised
version of it that is more amenable to be formalized using a locally nameless
representation of channels.

\citet{CicconePadovani20} formalize a variant of the linear
$\pi$-calculus~\cite{KobayashiPierceTurner99} that supports dependent types, so
as to enable the description of communication protocols whose structure depends
on the content of exchanged messages.

All the formalizations mentioned make use of context splitting. In contrast,
\citet{ZalakainDardha21} formalize a generalization of the linear $\pi$-calculus
which is parametric in a \emph{usage algebra} (to account for channel
sharing/linearity) and that is based on \emph{leftover typing}~\cite{}. The
basic idea is that a process is typed with respect to an \emph{input context},
which describes the overall available channels, and an \emph{output context},
which describes the remaining channels not consumed by the process. In this way,
it is possible to ``concatenate'' typing judgments instead of splitting them
beforehand.

Another work based on context splitting is the one by
\citet{JacobsBalzerKrebbers22}, who formalize a library of \emph{connectivity
graphs} for reasoning and enforcing deadlock freedom in a variant of
\GV~\citep{GayVasconcelos10,Wadler14}. This is the first formalization of
deadlock freedom for a calculus of sessions.

Motivated by the technical difficulties arising from the splitting of typing
contexts, \citet{SanoKavanaghPientka23} propose an alternative approach based on
\emph{linearity predicates}. The key idea is to treat typing contexts
structurally and to enforce the linear usage of channels by checking the
syntactical occurrence of channels within processes.

\citet{ZackonEtAl25} describe yet another approach to the handling of typing
contexts whereby channels are associated not just with a type but also with a
\emph{tag} (or \emph{multiplicity}) from a given resource algebra for describing
their availability. This approach streamlines context splitting in the sense
that contexts can be treated in an essentially structural way, except for tags
which are conveninently combined using operations from the resource algebra.

\newcommand{\YES}{$+$}
\newcommand{\NO}{$-$}
\newcommand{\MAYBE}{$\pm$}

\begin{table}[t]
    \newcommand{\textlabel}[1]{\rotatebox{90}{#1}}
    \caption{\label{tab:comparison} A summary of different formalizations of binary session calculi. All sizes are in kb.}
    \begin{minipage}{.9\textwidth}
    \begin{tabular}{@{}r@{~}@{~}c@{~~}c@{~}|@{~}c@{~~}c@{~~}c@{~~}c@{~}|@{~}r@{~~}r@{~~}r@{~~}r@{~~}r@{~}l@{}}
        \textbf{Formalization} &
        \textlabel{Proof assistant} &
        \textlabel{Calculus} &
        \textlabel{Channel linearity} &
        \textlabel{Channel names} &
        \textlabel{Intrinsically typed} &
        \textlabel{Continuations} &
        % \textlabel{Shared channels} &
        % \textlabel{Polymorphism} &
        \textlabel{Subject reduction} &
        \textlabel{Library} &
        \textlabel{Deadlock freedom} &
        \textlabel{Library} &
        \textlabel{\bf Total size} &
        \\
        \hline
        \citet{GotoEtAl16} &
        Coq &
        \SessionPI &
        splitting &
        loc. nameless &
        \NO &
        \NO &
        % \YES &
        % \YES &
        543 &
        \NO &
        \NO &
        \NO &
        \textbf{543} &
        \footnote{Includes shared and polymorphic channels. Excluded safety results.}
        \\
        \citet{Thiemann19} &
        Agda &
        \GV &
        splitting &
        co-de Bruijn &
        \YES &
        \MAYBE &
        % \YES &
        % \NO &
        177 &
        \NO &
        \NO &
        \NO &
        \textbf{177} &
        \footnote{Includes shared channels, recursive types, subtyping and the interpreter.}
        \\
        \citet{RouvoetPoulsenKrebbersVisser20} &
        Agda &
        \GV &
        splitting &
        co-de Bruijn &
        \YES &
        \MAYBE &
        % \NO &
        % \NO &
        27 &
        55 &
        \NO &
        \NO &
        \textbf{82} &
        \footnote{Includes type-preserving evaluator and library for proof-relevant separation algebra.}
        \\
        \citet{CastroFerreiraYoshida20} &
        Coq &
        \SessionPI &
        splitting &
        loc. nameless &
        \NO &
        \NO &
        % \YES &
        % \NO &
        204 &
        \NO &
        \NO &
        \NO &
        \textbf{204} &
        \footnote{Includes shared channels. Excluded original syntax.}
        \\
        \citet{CicconePadovani20} &
        Agda &
        \LinearPI & 
        splitting &
        co-de Bruijn &
        \YES &
        \YES &
        % \YES &
        % \NO &
        77 &
        \NO &
        \NO &
        \NO &
        \textbf{77} &
        \footnote{Includes shared channels, recursive and dependent session types.}
        \\
        \citet{ZalakainDardha21} &
        Agda &
        \LinearPI &
        leftovers &
        de Bruijn &
        \NO &
        \YES &
        % \YES &
        % \NO &
        82 &
        8 &
        \NO &
        \NO &
        \textbf{90} &
        \footnote{Includes shared channels and the library for algebra of types.}
        \\
        \citet{JacobsBalzerKrebbers22} &
        Coq &
        \GV &
        splitting &
        named &
        \NO &
        \MAYBE &
        % \NO &
        % \NO &
        68 &
        \NO &
        25 &
        171 &
        \textbf{264} &
        \footnote{Includes deadlock freedom and the library for connectivity graphs.}
        \\
        \citet{SanoKavanaghPientka23} &
        Beluga &
        \SCP &
        predicates &
        HOAS &
        \NO &
        \MAYBE &
        % \NO &
        % \NO &
        35 &
        \NO &
        \NO &
        \NO &
        \textbf{35}
        \\
        \citet{ZackonEtAl25} &
        Beluga &
        \CP &
        tags &
        HOAS &
        \NO &
        \NO &
        % \NO &
        % \NO &
        56 &
        73 &
        \NO &
        \NO &
        \textbf{129} &
        \footnote{Excluded correspondence between \CP and \SCP.}
        \\
        this work &
        Agda &
        \Calculus &
        splitting &
        co-de Bruijn &
        \YES &
        \YES &
        % \YES &
        % \YES &
        21 &
        \NO &
        15 &
        \NO &
        \textbf{36} &
        \footnote{Includes shared, polymorphic channels and deadlock freedom. Excluded safety results.}
    \end{tabular}
    \end{minipage}
\end{table}

\Cref{tab:comparison} summarizes a comparison of our formalization with the
aforementioned ones. The three leftmost colums list the reference papers (sorted
by publication date), the proof assistant and the formalized calculus.
%
For simplicity, we have grouped the calculi into classes identified by an
acronym. Some acronyms, like \CP~\cite{Wadler14} and
\GV~\cite{GayVasconcelos10,Wadler14} are well known in the literature on session
types. It should be noted that the actual calculus being formalized usually
differs from (typically, is a strict subset of) the one identified by the
acronym, but it retains some of its key features. We use \SessionPI to denote
(variants of) the session-based $\pi$-calculus presented by
\citet{HondaVasconcelosKubo98} and \LinearPI to denote (variants of) the linear
$\pi$-calculus~\cite{KobayashiPierceTurner99}, into which binary sessions can be
encoded using explicit continuation channels as described by
\citet{Kobayashi02b} and \citet{DardhaGiachinoSangiorgi17}. Finally, we use \SCP
for the structural version of \CP introduced by \citet{SanoKavanaghPientka23}
and \Calculus for our calculus, a linear version of \CP with explicit
continuations.

The four middle columns of \Cref{tab:comparison} report the relevant qualitative
aspects of the formalizations, namely the technique used to enforce the linear
usage of channels, the technique used to encode channels, whether the
formalization is intrinsically or extrinsically typed, and whether the calculus
makes use of continuation channels. Concerning the use of continuations, the
approaches based directly on the linear $\pi$-calculus (into which sessions can
be encoded) are marked with {\YES} and those based on a calculus with native
sessions are marked with {\NO}, as expected. The calculus \SCP is marked with
{\MAYBE} because, while not being strictly based on the linear $\pi$-calculus,
it makes use of explicit continuations for defining the linearity predicates
that check the linear usage of channels. Finally, all the approaches based on
\GV are also marked with \MAYBE. In principle, \emph{none} of these calculi
makes use of continuations. However, \GV is designed in such a way that each
session operation acting on a channel $s$ returns the result of the operation
(if any) \emph{along with the same channel $s$}. In this way, the type of $s$
can be ``updated'' to take into account the effect of the operation. As observed
by \citet{Padovani17}, this way of modelling the communication primitives is
virtually indistinguishable from one making use of explicit continuation
channels.

The rightmost columns of \Cref{tab:comparison} report the \emph{size} (in
kilobytes) of the formalizations as rough (and possibly questionable) estimates
of their complexity. Instead of counting line numbers, which may depend on code
indentation styles and syntactical constraints of the proof assistant being
used, we have counted the number of characters after comments have been removed
and spaces have been squeezed.\footnote{Sequences of two or more consecutive
space-like characters are collapsed into a single space. The squeezing is
obtained by running the command \texttt{tr -s [:space:] file} on Unix-like
systems.}
%
The reported sizes account for the source code of the formalization excluding
examples and any safety result, if present. We have noticed that the
interpretation of ``safety'' varies widely among the formalizations and, except
for our own, they all differ from the one stated in the linearity
challenge~\citep{CarboneEtAl24} when available.
%
Some formalization define \emph{libraries} which could be reused in different
contexts. In these cases, the size of the library is reported separately next to
the size of the part of the development that uses it.

In general, it is difficult to draw firm conclusions on the effectiveness of the
various approaches in addressing the linearity challenge because the
formalizations differ substantially in terms of reference calculus, feature
coverage, proof assistant, process/expression/channel representation, handling
of linearity. Also, most of them predate the publication of the linearity
challenge~\cite{CarboneEtAl24}, hence they are not necessarily targeted towards
that particular problem. However, some of
them~\cite{RouvoetPoulsenKrebbersVisser20,ZalakainDardha21,SanoKavanaghPientka23,ZackonEtAl25}
are explicitly motivated by the complexity arising from the linear usage of
resources/channels and from context splitting in particular.

Based on the available data, we can make the following observations.
%
Context splitting, which is very well represented, does not seem to be a good
indicator of the complexity of the formalization, since it spans the whole range
of formalization sizes. In particular, our formalization is based on context
splitting and covers full \CP~\cite{Wadler14}, yet it is by far the smallest
one.

The largest formalizations~\cite{GotoEtAl16,CastroFerreiraYoshida20} are also
the ones that adopt a locally nameless representation of channels. In this
formalizations channels are represented in two different ways, depending on
whether they are free or bound. This necessarily entails some duplication of
effort as well as some transformation machinery between the two representations
that contribute to the complexity of the formalization.
%
Other channel representations are not strong complexity indicators. Note that
the adoption of co-de Bruijn syntax implies the use of context splitting, hence
the two aspects are not completely independent.

There is no strong evidence that the intrinsically typed representation of
processes reduces the size of the formalization. As observed in
\Cref{sec:process-agda}, this choice may help reducing the overall number of
datatypes to be defined, but the definitions are necessarily more involved. In
the end, it seems plausible to speculate that the effort for representing
processes, types and typing rules is not substantially different overall.

Finally, it seems that the use of (explicit) continuations helps taming the
complexity of the formalization more than anything else. Indeed, the six
smallest formalizations (excluding the deadlock freedom results) -- with an
average size of around 62kb -- are all based on continuations, whether they are
explicit (\LinearPI, \SCP, \LCP) or ``virtual'' (\GV), while the remaining ones
are 263kb on average. This observation is in agreement with the observations we
made earlier in this paper concerning the difference between \emph{updating}
bindings versus \emph{removing and adding} bindings in a typing context. The
adoption of continuations enables a clean linear management of channels and
avoids the need for strong updates on the typing context.

% It is also interesting to note that
% whereby \SCP, which the authors~\citet{SanoKavanaghPientka23} do not relate
% directly to the linear $\pi$-calculus, relies on explicit continuations to tame
% the complexity of resource management. Our comparison suggests that this aspect,
% more than the structural treatment of contexts, 

% \citet{SanoKavanaghPientka23} do not relate it directly to the linear
% $\pi$-calculus.

% più che il trattamento strutturale dei contesti (ed evitare lo splitting) è
% l'uso delle continuazione a fare la differenza

In this work we have focused on models and theories of \emph{binary sessions},
but there are also formalizations of \emph{multiparty session types}, notably
those of \citet{JacobsBalzerKrebbers22a} and \citet{TiroreBengstonCarbone25},
which are notoriously more complex than those of binary session types. Just to
give an example, the formalization of \citet{TiroreBengstonCarbone25} amounts to
more than 1Mb of Coq code.
