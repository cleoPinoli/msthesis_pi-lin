\section{Related Work}
\label{sec:related}

We have compared our formalisation with others that have appeared in the
literature and for which we were able to retrieve the source code. We have
looked at those formalisations that include the following features:
\begin{itemize}
\item reduction/evaluation semantics for a calculus with support for binary
    sessions, either natively or through their encoding in terms of linear
    channels~\cite{KobayashiPierceTurner99,Kobayashi02b};
\item a type system along with the usual typing preservation results;
\item optionally, a proof of global progress/deadlock freedom.
\end{itemize}

\citet{GotoEtAl16} describe the formalisation of a session-based variant of the
$\pi$-calculus which supports channel polymorphism. This is the oldest
formalisation of a session-based calculus for which we were able to retrieve the
source code (the work of \citet{Gay01} predates this one, but its source code is
not publicly available any more).

\citet{Thiemann19} formalises a subset of \GV~\citep{GayVasconcelos10}, a
functional language extended with session communication primitives, along with
an interpreter. \citet{CicconePadovani20} have taken inspiration from this work
to formalise a variant of the linear
$\pi$-calculus~\cite{KobayashiPierceTurner99} that supports dependent types, so
as to enable the description of communication protocols whose structure depends
on the content of messages.

\citet{CastroFerreiraYoshida20} describe EMTST, a library for the formalisation
of session type systems that includes as case studies the session calculus of
\citet{HondaVasconcelosKubo98} (called ``original system'') and a revised
version of it that is more amenable to be formalised using a locally nameless
representation of channels.

\citet{RouvoetPoulsenKrebbersVisser20} present a library of abstractions
inspired to separation logic aiding the formalisation of interpreters for models
supported by linear type systems. One of the presented case studies is the
formalisation of a fragment of \GV~\citep{GayVasconcelos10,Wadler14}. The
separating conjunction introduced in \Cref{sec:context-agda} and the typing of
the constructors for the representation of processes in \Cref{sec:process-agda}
have been heavily inspired by this work. 

% as case study for their approach based on separation logic, which we have
% partially taken inspiration from for the representation of processes
% (\cref{sec:context-agda,sec:process-agda}). Their formalisation adopts the same
% intrinsically-typed representation of processes with nameless channels as our
% own, but their formalisation focuses on the implementation of an interpreter (no
% small-step semantics is defined) and subject reduction is 

\citet{JacobsBalzerKrebbers22} formalise a library of \emph{connectivity graphs}
for reasoning and enforcing deadlock freedom in a variant of
\GV~\citep{GayVasconcelos10,Wadler14}. This is the first formalisation of
deadlock freedom for a calculus of sessions.

All the formalisations mentioned so far make use of context splitting. In
contrast, \citet{ZalakainDardha21} formalise a generalisation of the linear
$\pi$-calculus which is parametric in a \emph{usage algebra} (to account for
channel sharing/linearity) and that is based on \emph{leftover
typing}~\cite{Allais17}. 
%
With leftover typing the judgments have the form $\wtl{P}\ContextC\ContextD$
where a process $P$ is typed with respect to an input context $\ContextC$, which
describes the overall available channels, and a context of leftovers
$\ContextD$, which describes the residual channels not consumed by the process.
In this way, it is possible to ``concatenate'' typing judgments by matching the
leftovers in one judgment with the input context of the subsequent one, with no
need for splitting. As \citet{ZalakainDardha21} nicely summarise, ``context
splits contain usage information that is already present in processes,'' and
therefore can be omitted. This is true provided that channels are named
(\citet{ZalakainDardha21} use de Bruijn indices to this aim). In fact, the co-de
Bruijn representation of processes~\cite{McBride18}, whereby channels are
nameless and context splitting is performed eagerly, can be seen as the ``dual
approach'' of leftover typing: channel names provide information that is already
present in their (singleton) typing context, hence they can be omitted from
contexts and processes.

Motivated by the technical difficulties arising from context splittings,
\citet{SanoKavanaghPientka23} define a structural version of \CP using an
approach based on \emph{linearity predicates}. The key idea is to treat typing
contexts structurally and to enforce the linear usage of channels by checking
their syntactical occurrence in processes. Interestingly, this approach relies
on the \emph{explicit naming of continuations} so as to precisely account for
the number of times a channel is actually used. \citet{SanoKavanaghPientka23} do
not connect their technique with the continuation-passing encoding of binary
sessions~\cite{Kobayashi02b,DardhaGiachinoSangiorgi17}, but the analogies are
evident even though the role of continuations differs.

\citet{ZackonEtAl25} describe yet another approach for managing typing contexts
whereby channels are associated not just with a type but also with a \emph{tag}
(or \emph{multiplicity}) from a given resource algebra. The tag summarises the
number of allowed usages of a particular channel, including the possibility that
the channel is not available. This approach streamlines context splitting since
contexts can be treated in an essentially structural way, except for tags which
are conveninently combined using operations from the resource algebra.

\newcommand{\YES}{$+$}
\newcommand{\NO}{$-$}
\newcommand{\MAYBE}{$\pm$}

\begin{table}[t]
    \newcommand\T{\hspace{1.25ex}}
    \newcommand{\textlabel}[1]{\rotatebox{90}{#1}}
    \caption{\label{tab:comparison} A summary of different formalisations of
    binary session calculi (sizes in kb).}
    \begin{minipage}{.95\textwidth}
    \begin{tabular}{@{}r@{\T}c@{\T}c@{\T}c@{\T}|@{\T}c@{\T}c@{\T}c@{\T}c@{\T}|@{\T}r@{\T}r@{\T}r@{\T}r@{\T}r@{\,}l@{}}
        \textbf{Formalisation} &
        \textlabel{Proof assistant} &
        \textlabel{Calculus} &
        \textlabel{Cut} &
        \textlabel{Channel linearity} &
        \textlabel{Channel names} &
        \textlabel{Intrinsically typed} &
        \textlabel{Continuations} &
        % \textlabel{Shared channels} &
        % \textlabel{Polymorphism} &
        \textlabel{Subject reduction} &
        \textlabel{Library} &
        \textlabel{Deadlock freedom} &
        \textlabel{Library} &
        \textlabel{\bf Total size} &
        \\
        \hline
        \citet{GotoEtAl16} &
        Coq &
        \SessionPI &
        \NO &
        splits &
        loc. nameless &
        \NO &
        \NO &
        % \YES &
        % \YES &
        543 &
        \NO &
        \NO &
        \NO &
        \textbf{543} &
        \footnote{Includes shared and polymorphic channels. Excluded safety results.}
        \\
        \citet{Thiemann19} &
        Agda &
        \GV &
        \NO &
        splits &
        co-de Bruijn &
        \YES &
        \MAYBE &
        % \YES &
        % \NO &
        177 &
        \NO &
        \NO &
        \NO &
        \textbf{177} &
        \footnote{Includes shared channels, recursive types, subtyping and the interpreter.}
        \\
        \citet{RouvoetPoulsenKrebbersVisser20} &
        Agda &
        \GV &
        \NO &
        splits &
        co-de Bruijn &
        \YES &
        \MAYBE &
        % \NO &
        % \NO &
        27 &
        55 &
        \NO &
        \NO &
        \textbf{82} &
        \footnote{Includes type-preserving evaluator and library for proof-relevant separation algebra.}
        \\
        \citet{CastroFerreiraYoshida20} &
        Coq &
        \SessionPI &
        \NO &
        splits &
        loc. nameless &
        \NO &
        \NO &
        % \YES &
        % \NO &
        204 &
        \NO &
        \NO &
        \NO &
        \textbf{204} &
        \footnote{Includes shared channels. Excluded original syntax.}
        \\
        \citet{CicconePadovani20} &
        Agda &
        \LinearPI & 
        \NO &
        splits &
        co-de Bruijn &
        \YES &
        \YES &
        % \YES &
        % \NO &
        77 &
        \NO &
        \NO &
        \NO &
        \textbf{77} &
        \footnote{Includes shared channels, recursive and dependent session types.}
        \\
        \citet{ZalakainDardha21} &
        Agda &
        \LinearPI &
        \NO &
        leftovers &
        de Bruijn &
        \NO &
        \YES &
        % \YES &
        % \NO &
        82 &
        8 &
        \NO &
        \NO &
        \textbf{90} &
        \footnote{Includes shared channels and the library for the algebra of types.}
        \\
        \citet{JacobsBalzerKrebbers22} &
        Coq &
        \GV &
        \YES &
        splits &
        named &
        \NO &
        \MAYBE &
        % \NO &
        % \NO &
        68 &
        \NO &
        25 &
        171 &
        \textbf{264} &
        \footnote{Includes deadlock freedom and the library for connectivity graphs.}
        \\
        \citet{SanoKavanaghPientka23} &
        Beluga &
        \SCP &
        \YES &
        predicates &
        HOAS &
        \NO &
        \MAYBE &
        % \NO &
        % \NO &
        35 &
        \NO &
        \NO &
        \NO &
        \textbf{35}
        \\
        \citet{ZackonEtAl25} &
        Beluga &
        \CP &
        \YES &
        tags &
        HOAS &
        \NO &
        \NO &
        % \NO &
        % \NO &
        56 &
        73 &
        \NO &
        \NO &
        \textbf{129} &
        \footnote{Excluded correspondence between \CP and \SCP.}
        \\
        this work &
        Agda &
        \Calculus &
        \YES &
        splits &
        co-de Bruijn &
        \YES &
        \YES &
        % \YES &
        % \YES &
        21 &
        \NO &
        15 &
        \NO &
        \textbf{36} &
        \footnote{Includes shared, polymorphic channels and deadlock freedom. Excluded safety results.}
    \end{tabular}
    \end{minipage}
\end{table}

\Cref{tab:comparison} reports a summary of the aforementioned formalisations and
also our own. The four leftmost columns list the reference papers (sorted by
publication date), the used proof assistant, the formalised calculus, and
whether the calculus features a cut in the style of linear logic, as opposed to
separate restriction and parallel composition.
%
For simplicity, we have grouped the calculi into classes identified by an
acronym. The acronyms \CP~\cite{Wadler14} and
\GV~\cite{GayVasconcelos10,Wadler14} refer to well-known calculi in the
literature on session types. The acronym \SessionPI refers to (variants of) the
session-based $\pi$-calculus presented by \citet{HondaVasconcelosKubo98} while
\LinearPI refers to (variants of) the linear
$\pi$-calculus~\cite{KobayashiPierceTurner99}. Finally, \SCP is the structural
version of \CP introduced by \citet{SanoKavanaghPientka23} and \Calculus is our
calculus.
%
It should be noted that the actual calculus being formalised usually differs
from (typically, is a strict subset of) the one identified by the acronym and
that the same acronym may identify different calculi. For example, the first
version of \GV described by \citet{GayVasconcelos10} is not based on linear
logic, whereas later versions~\cite{Wadler14} used \eg by
\citet{JacobsBalzerKrebbers22} are.
%
In any case, the acronym is meant to give an idea of the overall flavour of the
calculus.

The four middle columns of \Cref{tab:comparison} report the relevant qualitative
aspects of the formalisations, namely the technique for the management of typing
contexts, the representation of channels, whether the formalisation is
intrinsically or extrinsically typed, and whether the calculus makes use of
continuation channels. Concerning the use of continuations, the approaches based
directly on the linear $\pi$-calculus (into which sessions can be encoded) are
marked with {\YES} and those based on a calculus with native sessions are marked
with {\NO}. The calculus \SCP is marked with {\MAYBE} because, while not
directly inspired to the linear $\pi$-calculus, it makes use of explicit
continuations for defining the predicates that check the linear usage of
channels. Finally, all the approaches based on \GV are also marked with \MAYBE.
In principle, \emph{none} of these calculi makes use of continuations. However,
\GV is designed in such a way that each operation acting on a channel $s$ is a
function that returns the result of the operation (if any) \emph{along with the
same channel $s$}. In this way, the type of $s$ can be conveniently ``updated''
to take into account the effect of the operation. As observed by
\citet{Padovani17}, this semantics of the communication primitives is virtually
indistinguishable from one making use of explicit continuation channels.

The rightmost columns of \Cref{tab:comparison} report the size (in kilobytes) of
the formalisations as rough (and possibly questionable) estimates of their
complexity. Instead of counting line numbers, which may be affected by code
indentation styles and syntactical constraints of the proof assistant being
used, we have counted the number of characters after comments have been removed
and spaces have been squeezed.\footnote{Sequences of two or more consecutive
space-like characters are collapsed into a single space. The squeezing is
obtained by running the command \texttt{tr -s [:space:] file} on Unix-like
systems.}
%
The reported sizes account for the source code of the formalisation excluding
examples and any safety result, if present. We have noticed that the
interpretation of ``safety'' varies widely among the formalisations and, except
for our own, they all differ from the one stated in the linearity
challenge~\citep{CarboneEtAl24}.
%
Some
formalisations~\cite{RouvoetPoulsenKrebbersVisser20,ZalakainDardha21,JacobsBalzerKrebbers22,ZackonEtAl25}
define \emph{libraries} which can be reused in different contexts. In these
cases, the size of the library is reported separately next to the size of the
part of the development that uses it.

In general, it is difficult to draw firm conclusions on the effectiveness of the
various approaches in addressing the linearity challenge because the
formalisations differ widely for a variety of entangled factors. Also, most
formalisations predate the publication of the linearity
challenge~\cite{CarboneEtAl24}, hence they are not necessarily targeted to
solving that particular problem. However, some of
them~\cite{RouvoetPoulsenKrebbersVisser20,ZalakainDardha21,SanoKavanaghPientka23,ZackonEtAl25}
are explicitly motivated by the complexity arising from the linear usage of
resources/channels and from context splitting in particular.

Based on the available data, we can make the following observations.
%
The adoption of context splitting, which is very well represented, does not seem
to be a good indicator of the complexity of the formalisation. Indeed, the
formalisations based on context splitting span the whole range of sizes, from
the largest by \citet{GotoEtAl16} (543kb) to our own (21kb, without the proof of
deadlock freedom) which is also the only one supporting all the features of \CP.

The two largest formalisations~\cite{GotoEtAl16,CastroFerreiraYoshida20} are the
ones that adopt a locally nameless representation of channels. In these
formalisations channels are represented in two different ways, depending on
whether they are free or bound. This necessarily entails some duplication of
effort as well as some transformation machinery between the two representations
that contribute to the complexity of the formalisation.
%
Other channel representations are not strong complexity indicators. Note that
the adoption of co-de Bruijn syntax implies the use of context splitting, hence
the two aspects are not completely independent.

We found no strong evidence that the intrinsically typed representation of
processes reduces the size of the formalisation. As observed in
\Cref{sec:process-agda}, this choice helps reducing the overall number of
datatypes to be defined and makes some results trivial (\eg
\Cref{thm:type-safety} formalised by \AgdaFunction{type-safety}), but the
definitions are also more involved because they incorporate invariants and the
proofs of typing preservation. It is plausible to speculate that the effort for
representing processes, types and typing rules is not substantially different
overall.

Using the cut in the style of linear logic instead of separate restriction and
parallel composition simplifies the representation of channels (or session
endpoints). All the formalisations of calculi that adopt the cut tend to be
small (if we exclude the libraries), but this is not a general rule.

Finally, it seems that the use of (explicit) continuations affects the
complexity of the formalisation more than anything else. Indeed, the six
smallest formalisations (excluding the deadlock freedom results) -- with an
average size of around 62kb -- are all based on continuations, no matter if they
are explicit (\LinearPI, \SCP, \LCC) or ``virtual'' (\GV), while the remaining
ones are 263kb on average. This observation is in agreement with the
considerations we made earlier in this paper concerning the difference between
\emph{updating} bindings versus \emph{removing and adding} bindings in a typing
context. The use of continuations enables a cleaner management of typing
contexts since linear channels become true ``use-once'' resources and there is
no need for strong updates of their type.

% It is also interesting to note that whereby \SCP, which the
% authors~\citet{SanoKavanaghPientka23} do not relate directly to the linear
% $\pi$-calculus, relies on explicit continuations to tame the complexity of
% resource management. Our comparison suggests that this aspect, more than the
% structural treatment of contexts, 

% \citet{SanoKavanaghPientka23} do not relate it directly to the linear
% $\pi$-calculus.

% più che il trattamento strutturale dei contesti (ed evitare lo splitting) è
% l'uso delle continuazione a fare la differenza
