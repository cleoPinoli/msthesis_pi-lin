\section{Related Work}
\label{sec:related}

We have compared our formalisation with others of typed calculi that support
binary sessions either natively or through their encoding using
continuations~\cite{KobayashiPierceTurner99,Kobayashi02b}.

\citet{GotoEtAl16} describe the formalisation of a session-based variant of the
$\pi$-calculus which supports channel polymorphism. This is the oldest
formalisation of a session-based calculus for which we were able to retrieve the
source code (the work of \citet{Gay01} predates this one, but its source code is
not publicly available any more).

\citet{Thiemann19} formalises a subset of \GV~\citep{GayVasconcelos10}, a
functional language extended with session communication primitives, along with
an interpreter. \citet{CicconePadovani20} have taken inspiration from this work
to formalise a variant of the linear
$\pi$-calculus~\cite{KobayashiPierceTurner99} that supports dependent types, so
as to enable the description of communication protocols whose structure may
depend on the content of messages.

\citet{CastroFerreiraYoshida20} describe EMTST, a library for the formalisation
of session type systems that includes as case studies the session calculus of
\citet{HondaVasconcelosKubo98} (called ``original system'') and a revised
version of it that is more amenable to be formalised using a locally nameless
representation of channels.

\citet{RouvoetPoulsenKrebbersVisser20} present a library of abstractions
inspired to separation logic aiding the formalisation of interpreters for
languages with linear resources. One of the presented case studies is the
formalisation of a fragment of \GV~\citep{GayVasconcelos10,Wadler14}. 
%
Unlike the other formalisations we are discussing,
\citet{RouvoetPoulsenKrebbersVisser20} do not define a small-step semantics for
\GV which explains (in part) the small size of their development. However, since
their formalisation of \GV is intrinsically typed, the interpreter preserves
typing and therefore proves a form of subject reduction property.
%
The separating conjunction introduced in \Cref{sec:context-agda} and the typing
of the constructors for the representation of processes in
\Cref{sec:process-agda} have been adapted from this work of
\citet{RouvoetPoulsenKrebbersVisser20}.

% as case study for their approach based on separation logic, which we have
% partially taken inspiration from for the representation of processes
% (\cref{sec:context-agda,sec:process-agda}). Their formalisation adopts the same
% intrinsically-typed representation of processes with nameless channels as our
% own, but their formalisation focuses on the implementation of an interpreter (no
% small-step semantics is defined) and subject reduction is 

\citet{JacobsBalzerKrebbers22} formalise a library of \emph{connectivity graphs}
for reasoning and enforcing deadlock freedom in a variant of
\GV~\citep{GayVasconcelos10,Wadler14}. This is the first formalisation of
deadlock freedom for a calculus of sessions.

All the formalisations mentioned so far make use of context splitting. In
contrast, \citet{ZalakainDardha21} formalise a generalisation of the linear
$\pi$-calculus which is parametric in a \emph{usage algebra} (to account for
channel sharing/linearity) and that is based on \emph{leftover
typing}~\cite{Allais17}. 
%
Typing judgments have the form $\wtl{P}\ContextC\ContextD$ so that a process $P$
is typed with respect to an input context $\ContextC$, which describes all the
available channels, and a context of leftovers $\ContextD$, which describes the
residual channels not consumed by the process. In this way, it is possible to
``concatenate'' typing judgments by matching the leftovers in one judgment with
the input context of the subsequent one, with no need for splitting. As
\citet{ZalakainDardha21} nicely summarise, context splittings are not necessary
because they ``contain usage information that is already present in processes.''
This is true provided that channels are named (\citet{ZalakainDardha21} use de
Bruijn indices to this aim). In fact, the co-de Bruijn representation of
processes~\cite{McBride18}, whereby channels are nameless and context splitting
is performed eagerly, can be seen as the ``dual approach'' of leftover typing:
channel names provide information that is already present in their (singleton)
typing context, hence they can be omitted from contexts and processes.

Motivated by the technical difficulties arising from context splittings,
\citet{SanoKavanaghPientka23} define a structural version of \CP using an
approach based on \emph{linearity predicates}. The key idea is to treat typing
contexts structurally and to enforce the linear usage of channels by checking
their syntactical occurrence in processes. Interestingly, this approach relies
on the \emph{explicit naming of continuations} so as to precisely account for
the number of times a channel is actually used. \citet{SanoKavanaghPientka23} do
not connect their technique with the continuation-passing encoding of binary
sessions~\cite{Kobayashi02b,DardhaGiachinoSangiorgi17}, but the analogies are
evident even though the role of continuations differs.

\citet{ZackonEtAl25} describe a typing context management technique where
channels are associated not just with a type but also with an element -- called
\emph{tag} -- of a given resource algebra that summarises the number of allowed
usages of a particular channel, including the possibility that the channel is
not available. This approach streamlines context splitting since contexts can be
treated in an essentially structural way, except for tags which are
conveninently combined using operations from the resource algebra.

\newcommand{\YES}{$+$}
\newcommand{\NO}{$-$}
\newcommand{\MAYBE}{$\pm$}

\begin{table}[t]
    \newcommand\T{\hspace{1.25ex}}
    \newcommand{\textlabel}[1]{\rotatebox{90}{#1}}
    \caption{\label{tab:comparison} Overview of different formalisations of
    binary session calculi (sizes in kb).}
    \begin{minipage}{.95\textwidth}
    \begin{tabular}{@{}l@{\T}c@{\T}c@{\T}c@{\T}c@{\T}|c@{\T}c@{\T}c@{\T}|@{\T}r@{\T}r@{\T}r@{\T}r@{\T}r@{\,}l@{}}
        \text{Reference paper} &
        \text{Prover} &
        \textlabel{Calculus} &
        \textlabel{Cuts} &
        \textlabel{Continuations} &
        \text{Linearity} &
        \text{Channels} &
        \textlabel{Intrinsically typed} &
        % \textlabel{Shared channels} &
        % \textlabel{Polymorphism} &
        \textlabel{Subject reduction} &
        \textlabel{Library} &
        \textlabel{Deadlock freedom} &
        \textlabel{Library} &
        \textlabel{\bf Total size} &
        \\
        \hline
        \citet{GotoEtAl16} &
        Coq &
        \SessionPI &
        \NO &
        \NO &
        splits &
        loc. nameless &
        \NO &
        % \YES &
        % \YES &
        543 &
        \NO &
        \NO &
        \NO &
        \textbf{543} &
        \footnote{Includes shared and polymorphic channels. Excluded safety results.}
        \\
        \citet{Thiemann19} &
        Agda &
        \GV &
        \NO &
        \MAYBE &
        splits &
        co-de Bruijn &
        \YES &
        % \YES &
        % \NO &
        177 &
        \NO &
        \NO &
        \NO &
        \textbf{177} &
        \footnote{Includes shared channels, recursive types, subtyping and the interpreter.}
        \\
        \citet{RouvoetPoulsenKrebbersVisser20} &
        Agda &
        \GV &
        \NO &
        \MAYBE &
        splits &
        co-de Bruijn &
        \YES &
        % \NO &
        % \NO &
        27 &
        55 &
        \NO &
        \NO &
        \textbf{82} &
        \footnote{Includes type-preserving evaluator and library for proof-relevant separation algebra.}
        \\
        \citet{CastroFerreiraYoshida20} &
        Coq &
        \SessionPI &
        \NO &
        \NO &
        splits &
        loc. nameless &
        \NO &
        % \YES &
        % \NO &
        204 &
        \NO &
        \NO &
        \NO &
        \textbf{204} &
        \footnote{Includes shared channels. Excluded original syntax.}
        \\
        \citet{CicconePadovani20} &
        Agda &
        \LinearPI & 
        \NO &
        \YES &
        splits &
        co-de Bruijn &
        \YES &
        % \YES &
        % \NO &
        77 &
        \NO &
        \NO &
        \NO &
        \textbf{77} &
        \footnote{Includes shared channels, recursive and dependent session types.}
        \\
        \citet{ZalakainDardha21} &
        Agda &
        \LinearPI &
        \NO &
        \YES &
        leftovers &
        de Bruijn &
        \NO &
        % \YES &
        % \NO &
        82 &
        8 &
        \NO &
        \NO &
        \textbf{90} &
        \footnote{Includes shared channels and the library for the algebra of types.}
        \\
        \citet{JacobsBalzerKrebbers22} &
        Coq &
        \GV &
        \YES &
        \MAYBE &
        splits &
        named &
        \NO &
        % \NO &
        % \NO &
        68 &
        \NO &
        25 &
        171 &
        \textbf{264} &
        \footnote{Includes deadlock freedom and the library for connectivity graphs.}
        \\
        \citet{SanoKavanaghPientka23} &
        Beluga &
        \SCP &
        \YES &
        \MAYBE &
        predicates &
        HOAS &
        \NO &
        % \NO &
        % \NO &
        35 &
        \NO &
        \NO &
        \NO &
        \textbf{35}
        \\
        \citet{ZackonEtAl25} &
        Beluga &
        \CP &
        \YES &
        \NO &
        tags &
        HOAS &
        \NO &
        % \NO &
        % \NO &
        56 &
        73 &
        \NO &
        \NO &
        \textbf{129} &
        \footnote{Excluded correspondence between \CP and \SCP.}
        \\
        this &
        Agda &
        \Calculus &
        \YES &
        \YES &
        splits &
        co-de Bruijn &
        \YES &
        % \YES &
        % \YES &
        21 &
        \NO &
        15 &
        \NO &
        \textbf{36} &
        \footnote{Includes shared, polymorphic channels and deadlock freedom. Excluded safety results.}
    \end{tabular}
    \end{minipage}
\end{table}

\Cref{tab:comparison} shows an overview of the aforementioned formalisations
(sorted by publication date) including our own. The first five columns identify
the calculus being formalised. We provide its reference paper, the prover in
which it is formalised and an acronym that gives an idea of the flavour of the
calculus. We also specify whether the calculus features \emph{cuts} (that is,
the combination of restriction and parallel composition corresponding with the
cut of linear logic) and continuations.
%
\CP~\cite{Wadler14,GayVasconcelos25} and \GV~\cite{GayVasconcelos10,Wadler14}
are well-known acronyms in the literature on session types. \SessionPI refers to
(variants of) the session-based $\pi$-calculus presented by
\citet{HondaVasconcelosKubo98} while \LinearPI refers to (variants of) the
linear $\pi$-calculus~\cite{KobayashiPierceTurner99}. Finally, \SCP is the
structural version of \CP introduced by \citet{SanoKavanaghPientka23} and
\Calculus is our calculus.
%
We emphasize that the actual calculus being formalised usually differs from
(typically, is a strict subset of) the one identified by the acronym and that
the same acronym may sometimes refer to different versions of the same calculus.
In particular, \GV in a logical setting is described by \citet{Wadler14} but its
first (non-logical) version is due to \citet{GayVasconcelos10}.

Concerning the use of continuations, the approaches based directly on the linear
$\pi$-calculus (into which sessions can be encoded) are marked with {\YES} and
those based on a calculus with native sessions are marked with {\NO}. The
calculus \SCP is marked with {\MAYBE} because, while not directly inspired to
the linear $\pi$-calculus, it makes use of explicit continuations for defining
the predicates that check the linear usage of channels. Finally, all the
approaches based on \GV are also marked with \MAYBE. In principle, \emph{none}
of these calculi makes use of continuations. However, \GV is designed in such a
way that each operation acting on a channel $s$ is a function that returns the
result of the operation (if present) \emph{along with the same channel $s$}. In
this way, the type of $s$ can be conveniently ``updated'' to take into account
the effect of the operation. As observed by \citet{Padovani17}, this semantics
of the communication primitives is virtually indistinguishable from one making
use of explicit continuation channels.

The three middle columns of \Cref{tab:comparison} report the relevant
qualitative aspects of the formalisations, namely the management of typing
contexts, the representation of channels and whether processes are intrinsically
or extrinsically typed.

The rightmost columns report the size (in kilobytes) of the formalisations as
rough (and possibly questionable) estimates of their complexity. Papers
describing formalisations typically use ``lines of code'' as a measure of
development effort, but the number of lines may be affected by code indentation
styles and syntactical constraints of the proof assistant being used. For this
reason, we have preferred to count the total number of characters after comments
have been removed and spaces have been squeezed.\footnote{Sequences of two or
more consecutive space-like characters are collapsed into a single space. The
squeezing is obtained by running the command \texttt{tr -s [:space:] file} on
Unix-like systems.}
%
The reported sizes account for the source code of the formalisations excluding
examples and any safety result, if present. We have noticed that the
interpretation of ``safety'' varies widely among the formalisations and, except
for our own, they all differ from the one stated in the linearity
challenge~\citep{CarboneEtAl24}.
%
Some
formalisations~\cite{RouvoetPoulsenKrebbersVisser20,ZalakainDardha21,JacobsBalzerKrebbers22,ZackonEtAl25}
define \emph{libraries} which can be reused in different contexts. In these
cases, the size of the library is reported separately next to the size of the
part of the development that uses it.

In general, it is difficult to draw firm conclusions on the effectiveness of the
various approaches in addressing the linearity challenge because the
formalisations differ widely for a variety of entangled factors.
%
% Also, most formalisations predate the publication of the linearity
% challenge~\cite{CarboneEtAl24}, hence they are not necessarily targeted to
% solving that particular problem. However, some of
% them~\cite{RouvoetPoulsenKrebbersVisser20,ZalakainDardha21,SanoKavanaghPientka23,ZackonEtAl25}
% are explicitly motivated by the complexity arising from the linear usage of
% resources/channels and from context splitting in particular.
%
Looking at the available data, we can make the following observations.
%
The adoption of context splitting, which is very well represented, does not seem
to be a good indicator of the complexity of the formalisation. Indeed, the
formalisations based on context splitting span the whole range of sizes, from
the largest by \citet{GotoEtAl16} (543kb) to our own (21kb, without the proof of
deadlock freedom) which is also the only one supporting all the features of \CP.

The two largest formalisations~\cite{GotoEtAl16,CastroFerreiraYoshida20} are
also the ones that adopt a locally nameless representation of channels. In these
formalisations channels are represented in two different ways, depending on
whether they are free or bound. This entails some duplication of effort as well
as some transformation machinery between the two representations.
%
Other channel representations are not strong complexity indicators. Note that
the adoption of co-de Bruijn syntax implies the use of context splitting, hence
the two aspects are not completely independent.

There is no strong evidence that the intrinsically typed representation of
processes reduces the size of the formalisation. As observed in
\Cref{sec:process-agda}, this choice helps reducing the overall number of
datatypes to be defined and makes some results trivial (\eg
\Cref{thm:type-safety} formalised by \AgdaFunction{type-safety}), but the
definitions are also more involved because they incorporate invariants and the
proofs of typing preservation. We speculate that the effort for representing
processes, types and typing rules is not substantially impacted overall.

Using the cut in the style of linear logic instead of separate restriction and
parallel composition simplifies the representation of channels (or session
endpoints). All the formalisations of calculi that adopt the cut tend to be
small (if we exclude the libraries), but this is not a general rule.

Finally, it appears that the use of (explicit) continuations is related to the
complexity of the formalisation more than anything else. Indeed, the six
smallest formalisations (excluding the deadlock freedom results) -- with an
average size of around 62kb -- are all based on continuations, no matter if they
are explicit (\LinearPI, \SCP, \LCC) or ``virtual'' (\GV), while the remaining
ones are 263kb on average. This observation agrees with the considerations made
earlier in this paper concerning the difference between \emph{updating} bindings
versus \emph{removing and adding} bindings in a typing context. The use of
continuations enables a cleaner management of typing contexts since linear
channels are true ``use-once'' resources and there is no need to update their
type.
