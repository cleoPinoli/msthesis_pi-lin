\section{Related Work}
\label{sec:related}

We have compared our formalization with others that have appeared in the
literature and for which we were able to retrieve the source code. We have
looked at those formalizations that include the following characteristics:
\begin{itemize}
\item syntax and reduction/evaluation semantics for a calculus with support for
    binary sessions, either natively or through their encoding in terms of
    linear channels~\cite{KobayashiPierceTurner99,Kobayashi02b};
\item a type system along with the usual typing preservation results;
\item a proof of global progress/deadlock freedom, for those type systems that
    enforce it.
\end{itemize}

\citet{GotoEtAl16} describe the formalization of a session-based variant of the
$\pi$-calculus which supports channel polymorphism. This is the oldest
formalization of a session-based calculus for which we were able to retrieve the
source code (the work of \citet{Gay01} predates this one, but its source code is
not publicly available any more).

\citet{Thiemann19} formalizes a subset of \GV~\citep{GayVasconcelos10}, a
functional language extended with session communication primitives, along with
an interpreter.

\citet{RouvoetPoulsenKrebbersVisser20} present a library of abstractions
inspired to separation logic aiding the formalization of interpreters for
computing models supported by linear type systems. One of the presented case
studies is the formalization of a fragment of \GV~\citep{Wadler14}.

% as case study for their approach based on separation logic, which we have
% partially taken inspiration from for the representation of processes
% (\cref{sec:context-agda,sec:process-agda}). Their formalization adopts the same
% intrinsically-typed representation of processes with nameless channels as our
% own, but their formalization focuses on the implementation of an interpreter (no
% small-step semantics is defined) and subject reduction is 

\citet{CastroFerreiraYoshida20} describe EMTST, a library for the formalization
of session type systems which includes as case studies the session calculus of
\citet{HondaVasconcelosKubo98} (called ``original system'') and a revised
version of it that is more amenable to be formalized using a locally nameless
representation of channels.

\citet{CicconePadovani20} formalize a variant of the linear
$\pi$-calculus~\cite{KobayashiPierceTurner99} that supports dependent types, so
as to enable the description of communication protocols whose structure depends
on the content of exchanged messages.

All the formalizations mentioned make use of context splitting. In contrast,
\citet{ZalakainDardha21} formalize a generalization of the linear $\pi$-calculus
which is parametric in a \emph{usage algebra} (to account for channel
sharing/linearity) and that is based on \emph{leftover typing}~\cite{}. The
basic idea is that a process is typed with respect to an \emph{input context},
which describes the overall available channels, and an \emph{output context},
which describes the remaining channels not consumed by the process. In this way,
it is possible to ``concatenate'' typing judgments instead of splitting them
beforehand.

Another work based on context splitting is the one by
\citet{JacobsBalzerKrebbers22}, who formalize a library of \emph{connectivity
graphs} for reasoning and enforcing deadlock freedom in a variant of
\GV~\citep{GayVasconcelos10,Wadler14}. This is the first formalization of
deadlock freedom for a calculus of sessions.

Motivated by the technical difficulties arising from the splitting of typing
contexts, \citet{SanoKavanaghPientka23} propose an alternative approach based on
\emph{linearity predicates}. The key idea is to treat typing contexts
structurally and to enforce the linear usage of channels by checking the
syntactical occurrence of channels within processes.

\citet{ZackonEtAl25} describe yet another approach to the handling of typing
contexts whereby channels are associated not just with a type but also with a
\emph{tag} (or \emph{multiplicity}) from a given resource algebra for describing
their availability. This approach streamlines context splitting in the sense
that contexts can be treated in an essentially structural way, except for tags
which are conveninently combined using operations from the resource algebra.

\newcommand{\YES}{$+$}
\newcommand{\NO}{$-$}
\newcommand{\MAYBE}{$\pm$}

\begin{table}[t]
    \newcommand{\textlabel}[1]{\rotatebox{90}{#1}}
    \caption{\label{tab:comparison} A summary of different formalizations of binary session calculi. All sizes are in kb.}
    \begin{minipage}{.9\textwidth}
    \begin{tabular}{@{}r@{~}@{~}c@{~~}c@{~}|@{~}c@{~~}c@{~~}c@{~~}c@{~}|@{~}r@{~~}r@{~~}r@{~~}r@{~~}r@{~}l@{}}
        \textbf{Formalization} &
        \textlabel{Proof assistant} &
        \textlabel{Calculus} &
        \textlabel{Channel linearity} &
        \textlabel{Channel names} &
        \textlabel{Intrinsically typed} &
        \textlabel{Continuations} &
        % \textlabel{Shared channels} &
        % \textlabel{Polymorphism} &
        \textlabel{Subject reduction} &
        \textlabel{Library} &
        \textlabel{Deadlock freedom} &
        \textlabel{Library} &
        \textlabel{\bf Total size} &
        \\
        \hline
        \citet{GotoEtAl16} &
        Coq &
        \SessionPI &
        splitting &
        loc. nameless &
        \NO &
        \NO &
        % \YES &
        % \YES &
        543 &
        \NO &
        \NO &
        \NO &
        \textbf{543} &
        \footnote{Includes shared and polymorphic channels. Excluded safety results.}
        \\
        \citet{Thiemann19} &
        Agda &
        \GV &
        splitting &
        co-de Bruijn &
        \YES &
        \MAYBE &
        % \YES &
        % \NO &
        177 &
        \NO &
        \NO &
        \NO &
        \textbf{177} &
        \footnote{Includes shared channels, recursive types, subtyping and the interpreter.}
        \\
        \citet{RouvoetPoulsenKrebbersVisser20} &
        Agda &
        \GV &
        splitting &
        co-de Bruijn &
        \YES &
        \MAYBE &
        % \NO &
        % \NO &
        27 &
        55 &
        \NO &
        \NO &
        \textbf{82} &
        \footnote{Includes type-preserving evaluator and library for proof-relevant separation algebra.}
        \\
        \citet{CastroFerreiraYoshida20} &
        Coq &
        \SessionPI &
        splitting &
        loc. nameless &
        \NO &
        \NO &
        % \YES &
        % \NO &
        204 &
        \NO &
        \NO &
        \NO &
        \textbf{204} &
        \footnote{Includes shared channels. Excluded original syntax.}
        \\
        \citet{CicconePadovani20} &
        Agda &
        \LinearPI & 
        splitting &
        co-de Bruijn &
        \YES &
        \YES &
        % \YES &
        % \NO &
        77 &
        \NO &
        \NO &
        \NO &
        \textbf{77} &
        \footnote{Includes shared channels, recursive and dependent session types.}
        \\
        \citet{ZalakainDardha21} &
        Agda &
        \LinearPI &
        leftovers &
        de Bruijn &
        \NO &
        \YES &
        % \YES &
        % \NO &
        82 &
        8 &
        \NO &
        \NO &
        \textbf{90} &
        \footnote{Includes shared channels and the library for algebra of types.}
        \\
        \citet{JacobsBalzerKrebbers22} &
        Coq &
        \GV &
        splitting &
        named &
        \NO &
        \MAYBE &
        % \NO &
        % \NO &
        68 &
        \NO &
        25 &
        171 &
        \textbf{264} &
        \footnote{Includes deadlock freedom and the library for connectivity graphs.}
        \\
        \citet{SanoKavanaghPientka23} &
        Beluga &
        \SCP &
        predicates &
        HOAS &
        \NO &
        \MAYBE &
        % \NO &
        % \NO &
        35 &
        \NO &
        \NO &
        \NO &
        \textbf{35}
        \\
        \citet{ZackonEtAl25} &
        Beluga &
        \CP &
        tags &
        HOAS &
        \NO &
        \NO &
        % \NO &
        % \NO &
        56 &
        73 &
        \NO &
        \NO &
        \textbf{129} &
        \footnote{Excluded correspondence between \CP and \SCP.}
        \\
        this work &
        Agda &
        \Calculus &
        splitting &
        co-de Bruijn &
        \YES &
        \YES &
        % \YES &
        % \YES &
        21 &
        \NO &
        15 &
        \NO &
        \textbf{36} &
        \footnote{Includes shared, polymorphic channels and deadlock freedom. Excluded safety results.}
    \end{tabular}
    \end{minipage}
\end{table}

\Cref{tab:comparison} summarizes a comparison of our formalization with the
aforementioned ones. The three leftmost colums list the reference papers (sorted
by publication date), the proof assistant and the formalized calculus.
%
For simplicity, we have grouped the calculi into classes identified by an
acronym. Some acronyms, like \CP~\cite{Wadler14} and
\GV~\cite{GayVasconcelos10,Wadler14} are well known in the literature on session
types. It should be noted that the actual calculus being formalized usually
differs from (typically, is a strict subset of) the one identified by the
acronym, but it retains some of its key features. We use \SessionPI to denote
(variants of) the session-based $\pi$-calculus presented by
\citet{HondaVasconcelosKubo98} and \LinearPI to denote (variants of) the linear
$\pi$-calculus~\cite{KobayashiPierceTurner99}, into which binary sessions can be
encoded using explicit continuation channels as described by
\citet{Kobayashi02b} and \citet{DardhaGiachinoSangiorgi17}. Finally, we use \SCP
for the structural version of \CP introduced by \citet{SanoKavanaghPientka23}
and \Calculus for our calculus, a linear version of \CP with explicit
continuations.

The four middle columns of \Cref{tab:comparison} report the relevant qualitative
aspects of the formalizations, namely the technique used to enforce the linear
usage of channels, the technique used to encode channels, whether the
formalization is intrinsically or extrinsically typed, and whether the calculus
makes use of continuation channels. Concerning the use of continuations, the
approaches based directly on the linear $\pi$-calculus (into which sessions can
be encoded) are marked with {\YES} and those based on a calculus with native
sessions are marked with {\NO}, as expected. The calculus \SCP is marked with
{\MAYBE} because, while not being strictly based on the linear $\pi$-calculus,
it makes use of explicit continuations for defining the linearity predicates
that check the linear usage of channels. Finally, all the approaches based on
\GV are also marked with \MAYBE. In principle, \emph{none} of these calculi
makes use of continuations. However, \GV is designed in such a way that each
session operation acting on a channel $s$ returns the result of the operation
(if any) \emph{along with the same channel $s$}. In this way, the type of $s$
can be ``updated'' to take into account the effect of the operation. As observed
by \citet{Padovani17}, this way of modelling the communication primitives is
virtually indistinguishable from one making use of explicit continuation
channels.

The rightmost columns of \Cref{tab:comparison} report the \emph{size} (in
kilobytes) of the formalizations as rough (and possibly questionable) estimates
of their complexity. Instead of counting line numbers, which may depend on code
indentation styles and syntactical constraints of the proof assistant being
used, we have counted the number of characters after comments have been removed
and spaces have been squeezed.\footnote{Sequences of two or more consecutive
space-like characters are collapsed into a single space. The squeezing is
obtained by running the command \texttt{tr -s [:space:] file} on Unix-like
systems.}
%
The reported sizes account for the source code of the formalization excluding
examples and any ``safety'' result, if present. We have noticed that the
interpretation of ``safety'' varies widely among the formalizations and, except
for our own, they all differ from the one stated in the linearity
challenge~\citep{CarboneEtAl24} when available.
%
Some formalization define \emph{libraries} which could be reused in different
contexts. In these cases, the size of the library is reported separately next to
the size of the part of the development that uses it.

In general, it is difficult to draw firm conclusions on the effectiveness of the
various approaches because the formalizations differ substantially in terms of
reference calculus, feature coverage, proof assistant,
process/expression/channel representation, handling of linearity. Also, most of
them predate the linearity challenge~\cite{CarboneEtAl24}, hence they are not
necessarily targeted towards that particular problem. However, some of
them~\cite{RouvoetPoulsenKrebbersVisser20,ZalakainDardha21,SanoKavanaghPientka23,ZackonEtAl25}
are explicitly motivated by the complexity arising from the linear usage of
resources/channels and from context splitting in particular.

we can make some inference based on the available data.



paper di Marco a ECOOP (multiparty)