\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Unit using (tt)
open import Data.Sum using (inj₁; inj₂)
open import Data.Product using (_,_)
open import Data.List.Base using ([]; _∷_; [_])

open import Type
open import Context
open import Permutations
open import Process
\end{code}

\subsection{Structural Pre-Congruence}
\label{sec:congruence-agda}

We formalize structural precongruence as a binary relation between processes
that are well typed in the \emph{same} typing context. This entails that
structural precongruence preserves typing by definition.

\begin{AgdaAlign}
\begin{code}
data _⊒_ {Γ} : Proc Γ → Proc Γ → Set where
\end{code}

The datatype for $\pcong$ has one constructor for each of the structural
precongruence rules in \Cref{tab:semantics}. Since many aspects recur
repeatedly, we will focus on just a few representative rules starting from
\SComm.

\begin{code}
  s-comm :
    ∀{A Γ₁ Γ₂ P Q} (p : Γ ≃ Γ₁ + Γ₂) →
    cut {A} (P ⟨ p ⟩ Q) ⊒ cut (Q ⟨ +-comm p ⟩ P)
\end{code}

The constructor \AgdaInductiveConstructor{s-comm} models the commutativity
property of parallel composition. We use \AgdaFunction{+-comm} to compute the
proof of the splitting $\Splitting\ContextC{\Context_2}{\Context_1}$ from $p$.
%
Notice that this constructor also makes key use of the implicit rewriting rule
\AgdaFunction{dual-inv} described in \Cref{sec:type-agda}. Indeed $P$ and $Q$
have type $\AgdaDatatype{Proc}~(A~\AgdaInductiveConstructor{∷}~\Context_1)$ and
$\AgdaDatatype{Proc}~(\AgdaFunction{dual}~A~\AgdaInductiveConstructor{∷}~\Context_2)$,
respectively, but the \AgdaInductiveConstructor{cut} on the r.h.s. of
\AgdaInductiveConstructor{⊒} expects $P$ to have type
$\AgdaFunction{dual}~(\AgdaFunction{dual}~A)$. Thanks to
\AgdaFunction{dual-inv}, Agda considers these types equivalent without requiring
intricate substitutions in the index of \AgdaDatatype{Proc}.

\begin{code}[hide]
  s-link :
    ∀{A} (p : Γ ≃ [ A ] + [ dual A ]) →
    link (ch ⟨ p ⟩ ch) ⊒ link (ch ⟨ +-comm p ⟩ ch)
  s-fail :
    ∀{A Γ₁ Γ₂ Δ P} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ ⊤ ] + Δ) →
    let _ , _ , q′ = +-assoc-l p q in
    cut {A} (fail (ch ⟨ > q ⟩ tt) ⟨ p ⟩ P) ⊒ fail (ch ⟨ q′ ⟩ tt)
\end{code}

The constructor \AgdaInductiveConstructor{s-wait} models the \SWait rule:

\begin{code}
  s-wait :
    ∀{Γ₁ Γ₂ Δ A P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ ⊥ ] + Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} (wait (ch ⟨ > q ⟩ P) ⟨ p ⟩ Q) ⊒
    wait (ch ⟨ q′ ⟩ cut (P ⟨ p′ ⟩ Q))
\end{code}

There are two non-trivial aspects worth commenting. The first one concerns the
proof $(\AgdaInductiveConstructor{>}~q)$ used in the
\AgdaInductiveConstructor{wait} process before structural pre-congruence is
applied. To understand the meaning of this proof, we must recall three key
elements:
\begin{enumerate}
  \item
    $(\AgdaInductiveConstructor{wait}~(\AgdaInductiveConstructor{ch~⟨~>}~q~\AgdaInductiveConstructor{⟩}~P)$
    is a direct sub-process of the \AgdaInductiveConstructor{cut}, and therefore
    it is meant to be well typed in the context
    $A~\AgdaInductiveConstructor{∷}~\Context_1$.
  \item Being a \AgdaInductiveConstructor{wait} process, such context must
    contain a $\Bot$ type as per the typing rule \WaitRule. That is
    $\Splitting{A~\AgdaInductiveConstructor{∷}~\Context_1}{[\Bot]}{A~\AgdaInductiveConstructor{∷}~\ContextD}$
    for some $\ContextD$.
  \item The \SWait rule is applicable only provided that the channel restricted
    by the cut (say $x$, of type $A$) is different from the channel (say $y$, of
    type $\Bot$) consumed by the \AgdaInductiveConstructor{wait} process.
    %
    We enforce the side condition $x \ne y$ of \SWait (which we left implicit in
    \Cref{tab:semantics}) imposing that the type $A$ in front of
    $A~\AgdaInductiveConstructor{∷}~\Context_1$ necessarily comes from the right
    component of the splitting $[\Bot] + A~\AgdaInductiveConstructor{∷}~\Delta$
    through the use of \AgdaInductiveConstructor{>}.
\end{enumerate}

The other aspect that is worth commenting concerns the rearrangement of the
splittings in the process after the application of structural precongruence.
Overall, $p$ and $q$ prove the splittings $([\Bot] + \ContextD) + \ContextC_2$,
but the precongruence rule requires this splitting to be rearranged as $[\Bot] +
(\ContextD + \ContextC_2)$. That is, we need to apply the left-to-right
associativity property of context splitting which we called
\AgdaFunction{+-assoc-l} in \Cref{sec:context-agda}. The nested
\AgdaKeyword{let}-\AgdaKeyword{in} allows us to pattern match on the result of
the application $\AgdaFunction{+-assoc-l}~p~q$ and to extract the new proofs
$p'$ and $q'$ for the rearranged splittings.

The constructors \AgdaInductiveConstructor{s-select-l} and
\AgdaInductiveConstructor{s-select-r} model \SSelect when the selected tag is
respectively $\InTag_1$ and $\InTag_2$.
%
For example, for \AgdaInductiveConstructor{s-select-l} we have:

\begin{code}[hide]
  s-case :
    ∀{A B C Γ₁ Γ₂ Δ P Q R} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ B & C ] + Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} (case (ch ⟨ > q ⟩ (P , Q)) ⟨ p ⟩ R) ⊒
    case (ch ⟨ q′ ⟩ (cut (↭proc swap P ⟨ < p′ ⟩ R) ,
                     cut (↭proc swap Q ⟨ < p′ ⟩ R)))
\end{code}
\begin{code}
  s-select-l :
    ∀{Γ₁ Γ₂ Δ A B C P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ B ⊕ C ] + Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} (select (ch ⟨ > q ⟩ inj₁ P) ⟨ p ⟩ Q) ⊒
    select (ch ⟨ q′ ⟩ inj₁ (cut (↭proc swap P ⟨ < p′ ⟩ Q)))
\end{code}
\begin{code}[hide]
  s-select-r :
    ∀{Γ₁ Γ₂ Δ A B C P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ B ⊕ C ] + Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} (select (ch ⟨ > q ⟩ inj₂ P) ⟨ p ⟩ Q) ⊒
    select (ch ⟨ q′ ⟩ inj₂ (cut (↭proc swap P ⟨ < p′ ⟩ Q)))
\end{code}

Here the process
$(\AgdaInductiveConstructor{select}~(\AgdaInductiveConstructor{ch ⟨
>}~q~\AgdaInductiveConstructor{⟩})~\AgdaInductiveConstructor{inj₁}~P)$, that is
$\Select\y\LeftTag\z.P$, is found under a cut for $x : A$ and is using some
channel $y : B \Plus C$ to send the tag $\InTag_1$.
%
Unlike \AgdaInductiveConstructor{wait}, which consumes the channel it operates
on, the continuation process $P$ uses a fresh continuation channel $z : B$.
Therefore, $P$ is required to be well typed in the context
$B~\AgdaInductiveConstructor{∷}~A~\AgdaInductiveConstructor{∷}~\ContextD$, where
the type of the continuation $z$ comes before the type of the restricted channel
$x$.
%
After structural precongruence is applied, however, the type $B$ of the
continuation channel $z$ ends up behind that of the restricted channel $x$,
because now the two channels are introduced in the opposite order. Therefore, we
need to rename the channels in $P$ so that it is well typed in the context
$A~\AgdaInductiveConstructor{∷}~B~\AgdaInductiveConstructor{∷}~\ContextD$. Such
renaming is achieved applying the function \AgdaFunction{↭proc} to the
\AgdaInductiveConstructor{swap} permutation and to the process $P$.

\begin{code}[hide]
  s-join :
    ∀{Γ₁ Γ₂ Δ A B C P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ B ⅋ C ] + Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} (join (ch ⟨ > q ⟩ P) ⟨ p ⟩ Q) ⊒
    join (ch ⟨ q′ ⟩ cut (↭proc (↭shift {A} {C ∷ B ∷ []}) P ⟨ < < p′ ⟩ Q))
\end{code}

We also discuss the modeling of the \SForkL rule, which is interesting because of
its complex side conditions:

\begin{code}
  s-fork-l :
    ∀{Γ₁ Γ₂ Δ Δ₁ Δ₂ A B C P Q R}
    (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ B ⊗ C ] + Δ) (r : Δ ≃ Δ₁ + Δ₂) →
    let _ , p′ , q′ = +-assoc-l p q in
    let _ , p′′ , r′ = +-assoc-l p′ r in
    let _ , q′′ , r′′ = +-assoc-r r′ (+-comm p′′) in
    cut {A} (fork (ch ⟨ > q ⟩ (P ⟨ < r ⟩ Q)) ⟨ p ⟩ R) ⊒
    fork (ch ⟨ q′ ⟩ (cut (↭proc swap P ⟨ < q′′ ⟩ R) ⟨ r′′ ⟩ Q))
\end{code}

Recall from \Cref{tab:semantics} that we want to apply this rule on a process of
the form $\Cut[A]\x{\Fork\y\u\v{P}{Q}}{R}$ when $x \in \fn{P}$. We capture this
condition by means of the splitting $(\AgdaInductiveConstructor{<}~r)$, meaning
that the type $A$ of $x$ ends up in the typing context for $P$ and not in the
one for $Q$.
%
The symmetric rule \SForkR is modeled by another constructor
\AgdaInductiveConstructor{s-fork-r}, not shown here but similar to
\AgdaInductiveConstructor{s-fork-l} except that
$(\AgdaInductiveConstructor{<}~r)$ is replaced by
$(\AgdaInductiveConstructor{>}~r)$.

\begin{code}[hide]
  s-fork-r :
    ∀{Γ₁ Γ₂ Δ Δ₁ Δ₂ A B C P Q R}
    (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ B ⊗ C ] + Δ) (r : Δ ≃ Δ₁ + Δ₂) →
    let _ , p′ , q′ = +-assoc-l p q in
    let _ , p′′ , r′ = +-assoc-l p′ r in
    cut {A} (fork (ch ⟨ > q ⟩ (P ⟨ > r ⟩ Q)) ⟨ p ⟩ R) ⊒
    fork (ch ⟨ q′ ⟩ (P ⟨ r′ ⟩ cut (↭proc swap Q ⟨ < p′′ ⟩ R)))
  s-all :
    ∀{A B Γ₁ Γ₂ Δ F Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ `∀ B ] + Δ) ->
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} (all (ch ⟨ > q ⟩ F) ⟨ p ⟩ Q) ⊒
    all (ch ⟨ q′ ⟩ λ X → cut (↭proc swap (F X) ⟨ (< p′) ⟩ Q))
  s-ex :
    ∀{A B C Γ₁ Γ₂ Δ P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ `∃ B ] + Δ) ->
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} (ex {_} {C} (ch ⟨ > q ⟩ P) ⟨ p ⟩ Q) ⊒
    ex (ch ⟨ q′ ⟩ cut (↭proc swap P ⟨ < p′ ⟩ Q))
  s-server :
    ∀{A B Γ₁ Γ₂ Δ₁ P Q}
    (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ `! B ] + Δ₁) (r : Γ₂ ≃ [] + Γ₂)
    (un₁ : Un Δ₁) (un₂ : Un Γ₂) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {`? A} (server (ch ⟨ > q ⟩ (un-∷ un₁ , P)) ⟨ p ⟩ server (ch ⟨ < r ⟩ (un₂ , Q))) ⊒
    server (ch ⟨ q′ ⟩ (∗-un (un₁ ⟨ p′ ⟩ un₂) , cut (↭proc swap P ⟨ (< p′) ⟩ server (ch ⟨ < r ⟩ (un₂ , Q)))))
  s-client :
    ∀{A B Γ₁ Γ₂ Δ P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ `? B ] + Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} (client (ch ⟨ > q ⟩ P) ⟨ p ⟩ Q) ⊒
    client (ch ⟨ q′ ⟩ cut (↭proc swap P ⟨ < p′ ⟩ Q))
  s-weaken :
    ∀{A B Γ₁ Γ₂ Δ P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ `? B ] + Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} (weaken (ch ⟨ (> q) ⟩ P) ⟨ p ⟩ Q) ⊒ weaken (ch ⟨ q′ ⟩ cut (P ⟨ p′ ⟩ Q))
  s-contract :
    ∀{A B Γ₁ Γ₂ Δ P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ≃ [ `? B ] + Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} (contract (ch ⟨ > q ⟩ P) ⟨ p ⟩ Q) ⊒
    contract (ch ⟨ q′ ⟩ cut (↭proc (↭shift {A} {`? B ∷ `? B ∷ []}) P ⟨ < < p′ ⟩ Q))
\end{code}

Finally, in \Cref{sec:semantics} we have colloquially defined $\pcong$ as a
``\emph{pre-congruence}'', implying that it is reflexive, transitive relation
and that it is is preserved by some forms of calculus. In the formalization we
have to be precise and we introduce specific rules:

\begin{code}
  s-refl  : ∀{P} → P ⊒ P
  s-tran  : ∀{P Q R} → P ⊒ Q → Q ⊒ R → P ⊒ R
  s-cong  : ∀{Γ₁ Γ₂ A P Q P′ Q′} (p : Γ ≃ Γ₁ + Γ₂) →
            P ⊒ Q → P′ ⊒ Q′ → cut {A} (P ⟨ p ⟩ P′) ⊒ cut (Q ⟨ p ⟩ Q′)
\end{code}

Note that we define a single congruence rule \AgdaInductiveConstructor{s-cong}
that allows us to apply $\pcong$ within cuts, but not underneath prefixes. This
limited form of pre-congruence turns out to be sufficient for the development
that follows.
\end{AgdaAlign}
