\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Product using (_×_; _,_; ∃; ∃-syntax)
open import Data.List.Base using (List; []; _∷_; [_]; _++_)

open import Type
open import Context
open import Permutations
open import Process
\end{code}

\subsection{Structural Pre-Congruence}
\label{sec:congruence-agda}

We formalize structural precongruence as a binary relation between processes
that are well typed in the \emph{same} typing context. This entails that
structural precongruence preserves typing by definition.

\begin{AgdaAlign}
\begin{code}
data _⊒_ {Γ} : Process Γ → Process Γ → Set where
\end{code}

The datatype for $\pcong$ has one constructor for each of the structural
precongruence rules in \Cref{tab:semantics}. Since many aspects recur
repeatedly, we will focus on just a few representative rules starting from
\SComm.

\begin{code}
  s-comm :
    ∀{A Γ₁ Γ₂ P Q} (p : Γ ≃ Γ₁ + Γ₂) →
    cut {A} p P Q ⊒ cut (+-comm p) Q P
\end{code}

The constructor \AgdaInductiveConstructor{s-comm} models the commutativity
property of parallel composition. We use \AgdaFunction{+-comm} to compute the
proof of the splitting $\Splitting\ContextC{\Context_2}{\Context_1}$ from $p$
respectively.
%
Notice that this constructor also makes key use of the implicit rewriting rule
\AgdaFunction{dual-inv} described in \Cref{sec:type-agda}. Indeed $P$ and $Q$
have type $\AgdaDatatype{Process}~(A~\AgdaInductiveConstructor{∷}~\Context_1)$
and
$\AgdaDatatype{Process}~(\AgdaFunction{dual}~A~\AgdaInductiveConstructor{∷}~\Context_2)$,
respectively, but the \AgdaInductiveConstructor{cut} on the r.h.s. of
\AgdaInductiveConstructor{⊒} expects $P$ to have type
$\AgdaFunction{dual}~(\AgdaFunction{dual}~A)$. Thanks to
\AgdaFunction{dual-inv}, Agda considers these types equivalent without requiring
intricate substitutions in the index of a data type.

\begin{code}[hide]
  s-link :
    ∀{A} (p : Γ ≃ [ A ] + [ dual A ]) → link p ⊒ link (+-comm p)
  s-fail :
    ∀{A Γ₁ Γ₂ Δ P} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ ⊤ ⊳ Δ) →
    let _ , _ , q′ = +-assoc-l p q in
    cut {A} p (fail (> q)) P ⊒ fail q′
\end{code}

The constructor \AgdaInductiveConstructor{s-wait} models the \SWait rule:

\begin{code}
  s-wait :
    ∀{Γ₁ Γ₂ Δ A P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ ⊥ ⊳ Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} p (wait (> q) P) Q ⊒ wait q′ (cut p′ P Q)
\end{code}

There are two non-trivial aspects worth commenting. The first one concerns the
proof $(\AgdaInductiveConstructor{>}~q)$ used in the
\AgdaInductiveConstructor{wait} process before structural precongruence is
applied. To understand the meaning of this proof, we must recall three key
elements:
\begin{enumerate}
  \item
    $(\AgdaInductiveConstructor{wait}~(\AgdaInductiveConstructor{>}~q)~P)$ is a
    direct sub-process of the \AgdaInductiveConstructor{cut}, and therefore it
    is meant to be well typed in the context
    $A~\AgdaInductiveConstructor{∷}~\Context_1$.
  \item Being a \AgdaInductiveConstructor{wait} process, such context must
    contain a $\Bot$ type as per the typing rule \WaitRule. That is
    $\Splitting{A~\AgdaInductiveConstructor{∷}~\Context_1}{[\Bot]}{A~\AgdaInductiveConstructor{∷}~\ContextD}$
    for some $\ContextD$.
  \item The \SWait rule is applicable only provided that the channel restricted
    by the cut (say $x$, of type $A$) is different from the channel (say $y$, of
    type $\Bot$) consumed by the \AgdaInductiveConstructor{wait} process.
    %
    We enforce the side condition $x \ne y$ of \SWait imposing that the type $A$
    in front of $A~\AgdaInductiveConstructor{∷}~\Context_1$ necessarily comes
    from the right component of the splitting $[\Bot] +
    A~\AgdaInductiveConstructor{∷}~\Delta$ through the use of
    \AgdaInductiveConstructor{>}.
\end{enumerate}

The other aspect that is worth commenting concerns the rearrangement of the
splittings in the process after the application of structural precongruence.
Overall, $p$ and $q$ prove the splittings $([\Bot] + \ContextD) + \ContextC_2$,
but the precongruence rule requires this splitting to be rearranged as $[\Bot] +
(\ContextD + \ContextC_2)$. That is, we need to apply the left-to-right
associativity property of context splitting which we called
\AgdaFunction{+-assoc-l} in \Cref{sec:context-agda}. The nested
\AgdaKeyword{let}-\AgdaKeyword{in} allows us to pattern match the result of the
application $\AgdaFunction{+-assoc-l}~p~q$ and to extract the new proofs $p'$
and $q'$ for the rearranged splittings.

The constructors \AgdaInductiveConstructor{s-left} and
\AgdaInductiveConstructor{s-right} model \SSelect when the selected tag is
respectively $\Tag_1$ and $\Tag_2$.

\begin{code}[hide]
  s-case :
    ∀{A B C Γ₁ Γ₂ Δ P Q R} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ B & C ⊳ Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} p (case (> q) P Q) R ⊒ case q′ (cut (< p′) (↭process swap P) R)
                                           (cut (< p′) (↭process swap Q) R)
\end{code}
\begin{code}
  s-left :
    ∀{Γ₁ Γ₂ Δ A B C P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ B ⊕ C ⊳ Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} p (left (> q) P) Q ⊒ left q′ (cut (< p′) (↭process swap P) Q)
\end{code}
\begin{code}[hide]
  s-right :
    ∀{Γ₁ Γ₂ Δ A B C P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ B ⊕ C ⊳ Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} p (right (> q) P) Q ⊒ right q′ (cut (< p′) (↭process swap P) Q)
\end{code}

Here the process
$(\AgdaInductiveConstructor{left}~(\AgdaInductiveConstructor{>}~q)~P)$, which is
found under a cut for $x : A$, is using some channel $y : B \Plus C$ to send the
tag $\Tag_1$.
%
Unlike \AgdaInductiveConstructor{wait}, which consumes the channel it operates
on, the continuation process $P$ will be using a fresh continuation channel $z :
B$. Therefore, $P$ is required to be well typed in the context
$B~\AgdaInductiveConstructor{∷}~A~\AgdaInductiveConstructor{∷}~\ContextD$, where
the type of the continuation sits on top of the type of the restricted channel.
%
After structural precongruence is applied, however, the type $B$ of the
continuation channel $z$ ends up underneath that of the restricted channel $x$,
because now the two channels are introduced in the opposite order. Therefore, we
are in a situation where we need to turn $P$ into a process that is well typed
in the context
$A~\AgdaInductiveConstructor{∷}~B~\AgdaInductiveConstructor{∷}~\ContextD$. This
is achieved applying the function \AgdaFunction{↭process} to the
\AgdaInductiveConstructor{swap} permutation, which swaps the two topmost types
in a typing context, and finally to the process $P$.

We also show the modeling of the \SForkL rule, which is interesting because of
its complex side conditions:

\begin{code}[hide]
  s-join :
    ∀{Γ₁ Γ₂ Δ A B C P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ B ⅋ C ⊳ Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} p (join (> q) P) Q ⊒
    join q′ (cut (< < p′) (↭process (↭shift {A} {C ∷ B ∷ []}) P) Q)
\end{code}
\begin{code}
  s-fork-l :
    ∀{Γ₁ Γ₂ Δ Δ₁ Δ₂ A B C P Q R}
    (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ B ⊗ C ⊳ Δ) (r : Δ ≃ Δ₁ + Δ₂) →
    let _ , p′ , q′ = +-assoc-l p q in
    let _ , p′′ , r′ = +-assoc-l p′ r in
    let _ , q′′ , r′′ = +-assoc-r r′ (+-comm p′′) in
    cut {A} p (fork (> q) (< r) P Q) R ⊒
    fork q′ r′′ (cut (< q′′) (↭process swap P) R) Q
\end{code}

Recall from \Cref{tab:semantics} that we want to apply this rule on a process of
the form $\Cut[A]\x{\Fork\y\u\v{P}{Q}}{R}$ when $x \in \fn{P}$. We capture this
condition by means of the splitting $(\AgdaInductiveConstructor{<}~r)$, meaning
that the type $A$ of $x$ ends up in the typing context for $P$ and not in the
one for $Q$.
%
The symmetric rule \SForkR is modeled by another constructor
\AgdaInductiveConstructor{s-fork-r}, not shown here but similar to
\AgdaInductiveConstructor{s-fork-l} except that
$(\AgdaInductiveConstructor{<}~r)$ is replaced by
$(\AgdaInductiveConstructor{>}~r)$.

\begin{code}[hide]
  s-fork-r :
    ∀{Γ₁ Γ₂ Δ Δ₁ Δ₂ A B C P Q R}
    (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ B ⊗ C ⊳ Δ) (r : Δ ≃ Δ₁ + Δ₂) →
    let _ , p′ , q′ = +-assoc-l p q in
    let _ , p′′ , r′ = +-assoc-l p′ r in
    cut {A} p (fork (> q) (> r) P Q) R ⊒
    fork q′ r′ P (cut (< p′′) (↭process swap Q) R)
  s-all :
    ∀{A B Γ₁ Γ₂ Δ F Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ `∀ B ⊳ Δ) ->
    let _ , p' , q' = +-assoc-l p q in
    cut {A} p (all (> q) F) Q ⊒ all q' λ σ → cut (< p') (↭process swap (F σ)) Q
  s-ex :
    ∀{A B C Γ₁ Γ₂ Δ P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ `∃ B ⊳ Δ) ->
    let _ , p' , q' = +-assoc-l p q in
    cut {A} p (ex {_} {C} (> q) P) Q ⊒ ex q' (cut (< p') (↭process swap P) Q)
  s-server :
    ∀{A B Γ₁ Γ₂ Δ₁ P Q}
    (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ `! B ⊳ Δ₁) (r : Γ₂ ≃ [] + Γ₂)
    (un₁ : Un Δ₁) (un₂ : Un Γ₂) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {`? A} p (server (> q) (un-∷ un₁) P) (server (< r) un₂ Q) ⊒
    server q′ (+-un p′ un₁ un₂) (cut (< p′) (↭process swap P) (server (< r) un₂ Q))
  s-client :
    ∀{A B Γ₁ Γ₂ Δ P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ `? B ⊳ Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} p (client (> q) P) Q ⊒ client q′ (cut (< p′) (↭process swap P) Q)
  s-weaken :
    ∀{A B Γ₁ Γ₂ Δ P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ `? B ⊳ Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} p (weaken (> q) P) Q ⊒ weaken q′ (cut p′ P Q)
  s-contract :
    ∀{A B Γ₁ Γ₂ Δ P Q} (p : Γ ≃ Γ₁ + Γ₂) (q : Γ₁ ∋ `? B ⊳ Δ) →
    let _ , p′ , q′ = +-assoc-l p q in
    cut {A} p (contract (> q) P) Q ⊒
    contract q′ (cut (< < p′) (↭process (↭shift {A} {`? B ∷ `? B ∷ []}) P) Q)
\end{code}

Finally, in \Cref{sec:semantics} we have colloquially defined $\pcong$ as a
``\emph{pre-congruence}'', implying that it is reflexive, transitive relation
and that it is is preserved by some forms of calculus. In the formalization we
have to be precise and we introduce specific rules:

\begin{code}
  s-refl  : ∀{P} → P ⊒ P
  s-tran  : ∀{P Q R} → P ⊒ Q → Q ⊒ R → P ⊒ R
  s-cong  : ∀{Γ₁ Γ₂ A P Q P′ Q′} (p : Γ ≃ Γ₁ + Γ₂) →
            P ⊒ Q → P′ ⊒ Q′ → cut {A} p P P′ ⊒ cut p Q Q′
\end{code}

Note that we define a single congruence rule \AgdaInductiveConstructor{s-cong}
that allows us to apply $\pcong$ within cuts, but not underneath prefixes. This
limited form of pre-congruence turns out to be sufficient for the development
that follows.
\end{AgdaAlign}
