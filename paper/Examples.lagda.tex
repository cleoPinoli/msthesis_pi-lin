\subsection{Examples}
\label{sec:examples}

\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Function using (_$_)
open import Data.Sum using (injâ‚; injâ‚‚)
open import Data.Product using (_Ã—_; _,_; âˆƒ; âˆƒ-syntax; curry)
open import Data.Fin using (zero; suc; #_)
open import Data.List.Base using ([]; _âˆ·_; [_])
open import Relation.Unary

open import Type
open import Context
open import Permutations
open import Process
open import DeadlockFreedom using (deadlock-freedom)
\end{code}

In this section we revisit and expand the processes discussed in
\Cref{ex:booleans,ex:echo} and show their encoding in our formalisation. The
encoding of $\Bool$ is straightforward

\begin{code}
ğ”¹ : Type
ğ”¹ = ğŸ™ âŠ• ğŸ™
\end{code}
and the boolean constants are encoded thus:
\begin{code}
True : Proc [ ğ”¹ ]
True = select (ch âŸ¨ < â‰« âŸ© injâ‚ (close ch))

False : Proc [ ğ”¹ ]
False = select (ch âŸ¨ < â‰« âŸ© injâ‚‚ (close ch))
\end{code}

We take advantage of the host language for programming higher-order processes.
For example, we can define a conditional process thus:

\begin{code}
If_Else : âˆ€[ Proc â‡’ Proc â‡’ (dual ğ”¹ âˆ·_) âŠ¢ Proc ]
If P Else Q = curryâˆ— case ch (< â‰«) ( wait (ch âŸ¨ < â‰« âŸ© P)
                                   , wait (ch âŸ¨ < â‰« âŸ© Q))
\end{code}

A term $\AgdaFunction{If}~P~\AgdaFunction{Else}~Q$ is a process that waits for a
boolean value (\cf the $\AgdaFunction{dual}~\mathbb{B}$ type at the front of its
typing context) and continues as either $P$ or $Q$ depending on whether it
receives true or false. We use \AgdaFunction{curryâˆ—} (defined in
\Cref{sec:context-agda}) to curry the constructor
\AgdaInductiveConstructor{case} so that we can supply its arguments one by one
saving a few parentheses and reducing clutter.

Next we define a process $\AgdaFunction{Drop}~P$ that consumes a boolean and
continues as $P$ regardless of its value.

\begin{code}
Drop : âˆ€[ Proc â‡’ (dual ğ”¹ âˆ·_) âŠ¢ Proc ]
Drop P = If P Else P
\end{code}

Using these higher-order forms, it is easy to define the usual boolean
connectives.

\begin{code}
!!_ : Proc [ ğ”¹ ] â†’ Proc [ ğ”¹ ]
!!_ B = curryâˆ— cut B â‰« (If False Else True)

_&&_ _||_  : Proc [ ğ”¹ ] â†’ Proc [ ğ”¹ ] â†’ Proc [ ğ”¹ ]
A && B   =  curryâˆ— cut A â‰« $
            curryâˆ— cut B â‰« $
            If (curryâˆ— link ch (< â‰«) ch) Else (Drop False)
A || B   = !! ((!! A) && (!! B))
\end{code}

The function \AgdaFunction{\$} (defined in Agda's standard library) is just a
visible function application operator. We use it as a ``separator'' so that we
can flatten deeply nested expressions and save a bunch of parentheses.
%
We have chosen to define the disjunction \AgdaFunction{||} from the conjunction
\AgdaFunction{\&\&} and negation \AgdaFunction{!!} using De Morgan's laws.

If we wish to test our definitions, we can implement a simple evaluator using
the deadlock freedom property. We have not proved a termination result, but
since linear logic enjoys cut elimination we can safely annotate the evaluator
as terminating.

\begin{code}
{-# TERMINATING #-}
eval : âˆ€[ Proc â‡’ Proc ]
eval P with deadlock-freedom P
... | injâ‚ (Q , _ , _)  = Q
... | injâ‚‚ (Q , _)      = eval Q
\end{code}

Now if we ask Agda to normalise the goal
$\AgdaFunction{eval}~(\AgdaFunction{False}~\AgdaFunction{||}~\AgdaFunction{False})$
we obtain
$\AgdaInductiveConstructor{select}~(\AgdaInductiveConstructor{ch~âŸ¨~<~â€¢~âŸ©~injâ‚‚}~(\AgdaInductiveConstructor{close~ch}))$,
that is the definition of \AgdaFunction{False}, as expected.

For the encoding of the polymorphic echo server (\Cref{ex:echo}), we start by
encoding its type $\OfCourse(\forall\X.\dual\X \Par (X \Ten \One))$:

\begin{code}
ServerT : Type
ServerT = `! (`âˆ€ (rav (# 0) â…‹ (var (# 0) âŠ— ğŸ™)))
\end{code}

The notation $\AgdaFunction{\#}~n$ is defined in Agda's standard library and
creates an element of \AgdaDatatype{Fin} from the natural number $n$.
%
We now encode the server
\begin{code}
Server : Proc [ ServerT ]
Server = curry (curryâˆ— server ch (< â‰«)) un-[] $
         curryâˆ— all ch (< â‰«) Î» X â†’
         curryâˆ— join ch (< â‰«) $
         curryâˆ— (curryâˆ— fork ch (< â‰«)) (curryâˆ— link ch (< > â€¢) ch) (< â‰«) $
         close ch
\end{code}
and the client that sends true to it
\begin{code}
Client : Proc (dual ServerT âˆ· ğ”¹ âˆ· [])
Client = curryâˆ— client ch (< â‰«) $
         curryâˆ— (ex {_} {ğ”¹}) ch (< â‰«) $
         curryâˆ— (curryâˆ— fork ch (< â‰«)) True â‰« $
         curryâˆ— join ch (< â‰«) $
         curryâˆ— wait ch (< â‰«) $
         curryâˆ— link ch (< > â€¢) ch
\end{code}

We define a main process that connects server and client
\begin{code}
Main : Proc [ ğ”¹ ]
Main = curryâˆ— cut Client (< â€¢) Server
\end{code}
and then ask Agda to normalize \AgdaFunction{Main}, which yields
\AgdaFunction{True} as expected.
