\section{Examples}
\label{sec:examples}

\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Function using (_$_)
open import Data.Sum using (injâ‚; injâ‚‚)
open import Data.Product using (_Ã—_; _,_; âˆƒ; âˆƒ-syntax)
open import Data.Fin using (zero; suc; #_)
open import Data.List.Base using ([]; _âˆ·_; [_])
open import Relation.Unary

open import Type
open import Context
open import Permutations
open import Process
open import DeadlockFreedom using (deadlock-freedom)
\end{code}

In this section we illustrate a few simple examples of processes encoded in our
formalization. We start by encoding the type of a boolean value being produced
as a choice between ``going left'' (which we interpret as true) and ``going
right'' (which we interpret as false).

\begin{code}
ğ”¹ : Type
ğ”¹ = ğŸ™ âŠ• ğŸ™
\end{code}

The boolean constants are processes that perform one of these choices.

\begin{code}
true : Proc [ ğ”¹ ]
true = select (ch âŸ¨ < â‰« âŸ© injâ‚ (close ch))

false : Proc [ ğ”¹ ]
false = select (ch âŸ¨ < â‰« âŸ© injâ‚‚ (close ch))
\end{code}

We can use the host language for programming higher-order processes. For
example, we can define a conditional process thus:

\begin{code}
if_else : âˆ€{Î“} â†’ Proc Î“ â†’ Proc Î“ â†’ Proc (dual ğ”¹ âˆ· Î“)
if P else Q = curryâˆ— case ch (< â‰«) ( wait (ch âŸ¨ < â‰« âŸ© P)
                                   , wait (ch âŸ¨ < â‰« âŸ© Q))
\end{code}

A term $\AgdaFunction{if}~P~\AgdaFunction{else}~Q$ is a process that waits for a
boolean value (\cf the $\AgdaFunction{dual}~\mathbb{B}$ type at the front of its
typing context) and continues as either $P$ or $Q$ depending on whether it
receives true or false. We use \AgdaFunction{curryâˆ—} (defined in
\Cref{sec:context-agda}) to curry the constructor
\AgdaInductiveConstructor{case} so that we can supply its arguments one by one
saving a few parentheses and reducing clutter.

Next we define a process $\AgdaFunction{drop}~P$ that consumes a boolean and
continues as $P$ regardless of its value.

\begin{code}
drop : âˆ€{Î“} â†’ Proc Î“ â†’ Proc (dual ğ”¹ âˆ· Î“)
drop P = if P else P
\end{code}

Using these higher-order forms, it is easy to define the usual boolean
connectives.

\begin{code}
!!_ : Proc [ ğ”¹ ] â†’ Proc [ ğ”¹ ]
!!_ B = curryâˆ— cut B â‰« (if false else true)

_&&_ _||_  : Proc [ ğ”¹ ] â†’ Proc [ ğ”¹ ] â†’ Proc [ ğ”¹ ]
A && B   =  curryâˆ— cut A â‰« $
            curryâˆ— cut B â‰« $
            if (curryâˆ— link ch (< â‰«) ch) else (drop false)
A || B   = !! ((!! A) && (!! B))
\end{code}

The function \AgdaFunction{\$} is defined in Agda's standard library and denotes
function application. We use it here as ``separator'' to save a few parentheses.
%
Note the use of \AgdaInductiveConstructor{cut}s for combining a process that
produces a boolean value with a process that consumes a boolean value and the
use of \AgdaInductiveConstructor{link} for copying a boolean value from one
channel to another. 
%
Here we have chosen to define the disjunction \AgdaFunction{||} from the
conjunction \AgdaFunction{\&\&} and negation \AgdaFunction{!!} using De Morgan's
laws.

If we wish to test our definitions, we can implement a simple evaluator using
the deadlock freedom property. We have not proved a termination result, but
since linear logic enjoys cut elimination we can safely annotate the evaluator
as terminating.

\begin{code}
{-# TERMINATING #-}
eval : âˆ€{Î“} â†’ Proc Î“ â†’ Proc Î“
eval P with deadlock-freedom P
... | injâ‚ (Q , _ , _)  = Q
... | injâ‚‚ (Q , _)      = eval Q
\end{code}

Now if we ask Agda to normalize the goal
$\AgdaFunction{eval}~(\AgdaFunction{false}~\AgdaFunction{||}~\AgdaFunction{false})$
we obtain
$\AgdaInductiveConstructor{select}~(\AgdaInductiveConstructor{ch~âŸ¨~<~â€¢~âŸ©~injâ‚‚}~(\AgdaInductiveConstructor{close~ch}))$,
that is the definition of \AgdaFunction{false}, as expected.

For the example that follows, it is convenient to introduce the linear
implication connective according to the standard definition $A \multimap B
\eqdef \dual{A} \Par B$.

\begin{code}
_âŠ¸_ : âˆ€{n} â†’ PreType n â†’ PreType n â†’ PreType n
A âŠ¸ B = dual A â…‹ B
\end{code}

Below we define a persistent, polymorphic echo \AgdaInductiveConstructor{server}
that waits for a value and sends it back unchanged. The server is polymorphic in
the sense that the type of the value is arbitrary and denoted by the type
variable $X$. The notation $\AgdaFunction{\#}~n$ is defined in Agda's standard
library and creates an element of \AgdaDatatype{Fin} from the natural number
$n$.

\begin{code}
echo : let X = var (# 0) in
       Proc [ `! (`âˆ€ (X âŠ¸ X)) ]
echo = curryâˆ— server ch (< â‰«)
             ( un-[]
             , curryâˆ— all ch (< â‰«) Î» X â†’
               curryâˆ— join ch (< â‰«) $
               curryâˆ— link ch (< â‰«) ch)
\end{code}

We can test the server by connecting it with a \AgdaInductiveConstructor{client}
that sends true to it.

\begin{code}
echo-true : Proc [ ğ”¹ ]
echo-true = curryâˆ— cut echo â‰« $
            curryâˆ— client ch (< â‰«) $
            curryâˆ— ex ch (< â‰«) $
            curryâˆ— fork ch (< â‰«) $ true âŸ¨ â‰« âŸ© curryâˆ— link ch (< â‰«) ch
\end{code}

If we ask Agda to evaluate this process we obtain \AgdaFunction{true}, as
expected.

From these examples it should be clear that writing \Calculus processes in Agda
is not entirely straightforward, but it is still doable with a little effort.
The lack of names (for channels) clearly obfuscates the code, but the context
splittings that must be provided are usually small and fairly easy to
understand. Most importantly, the use of \AgdaFunction{â‰«} helps truncating
context splittings as soon as the seeked channel has been reached.
%
Either way, the formalization is meant to study the meta-theory of \Calculus
rather than implementing a user-friendly DSL for it.
