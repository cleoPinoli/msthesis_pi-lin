\section{Examples}
\label{sec:examples}

\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Sum hiding (reduce; swap)
open import Data.Product using (_Ã—_; _,_; âˆƒ; âˆƒ-syntax)
open import Data.Nat using (â„•; zero; suc)
open import Data.Fin using (zero; suc; #_)
open import Data.List.Base using (List; []; _âˆ·_; [_]; _++_)
open import Function using (_$_)
open import Data.Maybe

open import Type
open import Context
open import Permutations
open import Process
open import DeadlockFreedom using (deadlock-freedom)
\end{code}

In this section we illustrate a few simple examples of processes. We start by
encoding the type of a boolean value being produced as a choice between ``going
left'' (which we interpret as true) and ``going right'' (which we interpret as
false).

\begin{code}
ğ”¹ : Type
ğ”¹ = ğŸ™ âŠ• ğŸ™
\end{code}

The boolean constants are processes that perform one of these choices.

\begin{code}
true : Process [ ğ”¹ ]
true = left (< â‰«) close

false : Process [ ğ”¹ ]
false = right (< â‰«) close
\end{code}

We can use the host language for programming higher-order processes. For
example, we can define a conditional process thus:

\begin{code}
if_else : âˆ€{Î“} â†’ Process Î“ â†’ Process Î“ â†’ Process (dual ğ”¹ âˆ· Î“)
if P else Q = case (< â‰«) (wait (< â‰«) P) (wait (< â‰«) Q)
\end{code}

A term $\AgdaFunction{if}~P~\AgdaFunction{else}~Q$ is a process that waits for a
boolean value (\cf the $\AgdaFunction{dual}~\mathbb{B}$ type at the front of its
typing context) and continues as either $P$ or $Q$ depending on whether it
receives true or false.
%
We can then define a process $\AgdaFunction{drop}~P$ that waits for consumes a
boolean and continues as $P$ regardless of its value.

\begin{code}
drop : âˆ€{Î“} â†’ Process Î“ â†’ Process (dual ğ”¹ âˆ· Î“)
drop P = if P else P
\end{code}

Using these higher-order forms, it is easy to define the usual boolean
connectives.

\begin{code}
!!_ : Process [ ğ”¹ ] â†’ Process [ ğ”¹ ]
!!_ B = cut â‰« B (if false else true)

_&&_ _||_  : Process [ ğ”¹ ] â†’ Process [ ğ”¹ ] â†’ Process [ ğ”¹ ]
A && B   = cut â‰« A (cut â‰« B (if (link (< â‰«)) else (drop false)))
A || B   = !! ((!! A) && (!! B))
\end{code}

Note the use of \AgdaInductiveConstructor{cut}s for combining a process that
produces a boolean value with a process that consumes a boolean value and the
use of \AgdaInductiveConstructor{link} for copying a boolean value from one
channel to another. 
%
Here we have chosen to define the disjunction \AgdaFunction{||} from the
conjunction \AgdaFunction{\&\&} and negation \AgdaFunction{!!} using De Morgan's
laws.

If we wish to test our definitions, we can implement a simple (lazy) evaluator
using the deadlock freedom property. We have not proved a termination result,
but since linear logic enjoys cut elimination we can safely annotate the
evaluator as terminating.

\begin{code}
{-# TERMINATING #-}
eval : âˆ€{Î“} â†’ Process Î“ â†’ Process Î“
eval P with deadlock-freedom P
... | injâ‚ (Q , _ , _)  = Q
... | injâ‚‚ (Q , _)      = eval Q
\end{code}

Now if we ask Agda to normalize the goal
$\AgdaFunction{eval}~(\AgdaFunction{false}~\AgdaFunction{||}~\AgdaFunction{false})$
we obtain
$\AgdaInductiveConstructor{right}~(\AgdaInductiveConstructor{<}~\AgdaInductiveConstructor{â€¢})~\AgdaInductiveConstructor{close}$,
that is the definition of \AgdaFunction{false}, as expected.

For the example that follows, it is convenient to introduce the linear
implication connective according to the standard definition $A \multimap B
\eqdef \dual{A} \Par B$.

\begin{code}
_âŠ¸_ : âˆ€{n} â†’ PreType n â†’ PreType n â†’ PreType n
A âŠ¸ B = dual A â…‹ B
\end{code}

Below we define a persistent, polymorphic echo \AgdaInductiveConstructor{server}
that waits for a value and sends it back unchanged. The server is polymorphic in
the sense that the type of the value is arbitrary and denoted by the type
variable $X$. The notation $\AgdaFunction{\#}~n$ is defined in Agda's standard
library and creates an element of \AgdaDatatype{Fin} from the natural number
$n$. The function \AgdaFunction{\$} is also defined in the standard library and
denotes function application. We use it here as ``command separator'' to save a
few parentheses.

\begin{code}
echo :  let X = var (# 0) in
        Process [ `! (`âˆ€ (X âŠ¸ X)) ]
echo =  server (< â‰«) un-[] $
        all (< â‰«) Î» X â†’
        join (< â‰«) $
        link (< â‰«)
\end{code}

We can test the server by connecting it with a \AgdaInductiveConstructor{client}
that sends true to it.

\begin{code}
echo-true : Process [ ğ”¹ ]
echo-true = cut â‰« echo (client (< â‰«) $
                       ex (< â‰«) $
                       fork (< â‰«) â‰« true (link (< â‰«)))
\end{code}

If we ask Agda to evaluate this process we obtain
$\AgdaInductiveConstructor{left}~(\AgdaInductiveConstructor{<}~\AgdaInductiveConstructor{â€¢})~\AgdaInductiveConstructor{close}$,
that is the definition of \AgdaFunction{true} as expected.

From these examples it should be clear that writing \Calculus processes in Agda
is not entirely straightforward, but it is still doable with a little effort.
The lack of names (for channels) clearly obfuscates the code, but the context
splittings that must be provided are usually small and fairly easy to
understand. Most importantly, the use of \AgdaFunction{â‰«} helps truncating
context splittings as soon as the seeked channel has been reached.
%
Either way, the formalization is meant to study the meta-theory of \Calculus
rather than implementing a user-friendly DSL for it.

% \begin{code}
% âŠ—-comm : let X = var (# 1) in
%          let Y = var (# 0) in
%          Process [ `âˆ€ (`âˆ€ ((X âŠ— Y) âŠ¸ (Y âŠ— X))) ]
% âŠ—-comm = all (< â‰«) Î» X â†’
%          all (< â‰«) Î» Y â†’
%          join (< â‰«) $
%          join (> < â‰«) $
%          fork (> > < â‰«) (< â‰«)
%               (link (< â‰«))
%               (link (< â‰«))
% \end{code}
