\subsection{Examples}
\label{sec:examples}

\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Function using (_$_)
open import Data.Sum using (injâ‚; injâ‚‚)
open import Data.Product using (_Ã—_; _,_; âˆƒ; âˆƒ-syntax; curry)
open import Data.Fin using (zero; suc; #_)
open import Data.List.Base using ([]; _âˆ·_; [_])
open import Relation.Unary

open import Type
open import Context
open import Permutations
open import Process
open import DeadlockFreedom using (deadlock-freedom)
\end{code}

In this section we revisit and expand the processes discussed in
\Cref{ex:booleans,ex:echo} and show their encoding in our formalisation. The
encoding of $\Bool$ is straightforward

\begin{code}
ğ”¹ : Type
ğ”¹ = ğŸ™ âŠ• ğŸ™
\end{code}
and the boolean constants are encoded thus:
\begin{code}
True : Proc [ ğ”¹ ]
True = select (ch âŸ¨ < â‰« âŸ© injâ‚ (close ch))

False : Proc [ ğ”¹ ]
False = select (ch âŸ¨ < â‰« âŸ© injâ‚‚ (close ch))
\end{code}

We take advantage of the host language for programming higher-order processes.
For example, we can define a conditional process thus:

\begin{code}
If_Else : âˆ€[ Proc â‡’ Proc â‡’ (dual ğ”¹ âˆ·_) âŠ¢ Proc ]
If P Else Q = curryâˆ— case ch (< â‰«) (  wait (ch âŸ¨ < â‰« âŸ© P)
                                   ,  wait (ch âŸ¨ < â‰« âŸ© Q))
\end{code}

A term $\AgdaFunction{If}~P~\AgdaFunction{Else}~Q$ is a process that waits for a
boolean value (\cf the $\AgdaFunction{dual}~\mathbb{B}$ type at the front of its
typing context) and continues as either $P$ or $Q$ depending on whether it
receives true or false. We use \AgdaFunction{curryâˆ—} (defined in
\Cref{sec:context-agda}) to curry the constructor
\AgdaInductiveConstructor{case} so that we can supply its arguments one by one
saving a few parentheses and reducing clutter (more on this in \Cref{rem:curry}
at the end of this section).

Next we define a process $\AgdaFunction{Drop}~P$ that consumes a boolean and
continues as $P$ regardless of its value.

\begin{code}
Drop : âˆ€[ Proc â‡’ (dual ğ”¹ âˆ·_) âŠ¢ Proc ]
Drop P = If P Else P
\end{code}

Using these higher-order forms, it is easy to define the usual boolean
connectives.

\begin{code}
!! : Proc [ ğ”¹ ] â†’ Proc [ ğ”¹ ]
!! B = curryâˆ— cut B â‰« (If False Else True)

_&&_ _||_  : Proc [ ğ”¹ ] â†’ Proc [ ğ”¹ ] â†’ Proc [ ğ”¹ ]
A && B   =  curryâˆ— cut A â‰« $
            curryâˆ— cut B â‰« $
            If curryâˆ— link ch (< â‰«) ch Else (Drop False)
A || B   =  !! (!! A && !! B)
\end{code}

The function \AgdaFunction{\$} (defined in Agda's standard library) is just a
low-precedence, visible function application operator. We use it as a separator
to flatten deeply nested expressions and save a bunch of parentheses.
%
For the sake of illustration, we have chosen to define the disjunction
\AgdaFunction{||} from the conjunction \AgdaFunction{\&\&} and negation
\AgdaFunction{!!} using De Morgan's laws.

To test our definitions, we implement a simple evaluator using the deadlock
freedom property. We have not proved a termination result, but since linear
logic enjoys cut elimination we can safely annotate the evaluator as
terminating.

\begin{code}
{-# TERMINATING #-}
eval : âˆ€[ Proc â‡’ Proc ]
eval P with deadlock-freedom P
... | injâ‚ (Q , _ , _)  = Q
... | injâ‚‚ (Q , _)      = eval Q
\end{code}

Now if we ask Agda to normalise the goal
$\AgdaFunction{eval}~(\AgdaFunction{False}~\AgdaFunction{||}~\AgdaFunction{False})$
we obtain
$\AgdaInductiveConstructor{select}~(\AgdaInductiveConstructor{ch~âŸ¨~<~â€¢~âŸ©~injâ‚‚}~(\AgdaInductiveConstructor{close~ch}))$,
that is the definition of \AgdaFunction{False}, as expected.

For the encoding of the polymorphic echo server (\Cref{ex:echo}), we start by
encoding its type $\OfCourse(\forall\X.\dual\X \Par (X \Ten \One))$:

\begin{code}
ServerT : Type
ServerT = `! (`âˆ€ (rav (# 0) â…‹ (var (# 0) âŠ— ğŸ™)))
\end{code}

The notation $\AgdaFunction{\#}~n$ (defined in Agda's standard library) creates
an element of \AgdaDatatype{Fin} from the natural number $n$. Here it is used to
create the de Bruijn index of the type variable $X$.
%
We now encode the server
\begin{code}
Server : Proc [ ServerT ]
Server = curry (curryâˆ— server ch (< â‰«)) un-[] $
         curryâˆ— all ch (< â‰«) Î» X â†’
         curryâˆ— join ch (< â‰«) $
         curryâˆ— (curryâˆ— fork ch (< â‰«)) (curryâˆ— link ch (< > â€¢) ch) (< â‰«) $
         close ch
\end{code}
and the client that sends true to it
\begin{code}
Client : Proc (dual ServerT âˆ· ğ”¹ âˆ· [])
Client = curryâˆ— client ch (< â‰«) $
         curryâˆ— (ex {_} {ğ”¹}) ch (< â‰«) $
         curryâˆ— (curryâˆ— fork ch (< â‰«)) True â‰« $
         curryâˆ— join ch (< â‰«) $
         curryâˆ— wait ch (< â‰«) $
         curryâˆ— link ch (< > â€¢) ch
\end{code}

To test our definitions, we compose client and server in parallel
\begin{code}
Main : Proc [ ğ”¹ ]
Main = curryâˆ— cut Client (< â€¢) Server
\end{code}
and then ask Agda to normalize \AgdaFunction{Main}, which yields
\AgdaFunction{True} as expected.

\begin{remark}
    \label{rem:curry}
    Writing processes in Agda would be more pleasant if the constructors of the
    data type \AgdaDatatype{Proc} were naturally curried, instead of currying
    them on demand with \AgdaFunction{curryâˆ—} as we do here.
    %
    Below is the naturally curried constructor \AgdaInductiveConstructor{fork}
    of a hypothetical data type \AgdaDatatype{Proc'}, obtained by expanding the
    definition of separating conjunction:
\begin{code}[hide]
data Proc' : Context â†’ Set where
\end{code}
\begin{code}
  fork : âˆ€{A B Î“ Î” Î˜ Î˜â‚ Î˜â‚‚} â†’ Ch (A âŠ— B) Î” â†’ Î“ â‰ƒ Î” + Î˜ â†’
         Proc' (A âˆ· Î˜â‚) â†’ Î˜ â‰ƒ Î˜â‚ + Î˜â‚‚ â†’ Proc' (B âˆ· Î˜â‚‚) â†’ Proc' (A âŠ— B âˆ· Î“)
\end{code}

    This version of \AgdaInductiveConstructor{fork} is fully curried, but also
    less readable than the one we gave in \Cref{sec:process-agda} because of the
    (now visible) context splittings. We can recover some clarity and still
    obtain a curried version of \AgdaInductiveConstructor{fork} using
    (literally) the magic wand:
\begin{code}[hide]
data Proc'' : Context â†’ Set where
\end{code}
\begin{code}
  fork : âˆ€{A B} â†’
         âˆ€[ Ch (A âŠ— B) â‡’ (A âˆ·_) âŠ¢ Proc'' â”€âˆ— (B âˆ·_) âŠ¢ Proc'' â”€âˆ— Proc'' ]
\end{code}

    However, the first arrow must be a plain implication \AgdaFunction{â‡’} and
    not a magic wand to account for the appropriate amount of context
    splittings. We found this formulation of the constructors harder to explain
    and motivate in \Cref{sec:process-agda}.
    %
    Since none of the alternative definitions of \AgdaDatatype{Proc} was fully
    satisfactory, we preferred the most elegant version of the data type at the
    expense of additional clutter in this section.
    %
    \eoe
\end{remark}
