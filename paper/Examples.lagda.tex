\subsection{Examples}
\label{sec:examples}

\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Function using (_$_)
open import Data.Sum using (injâ‚; injâ‚‚)
open import Data.Product using (_Ã—_; _,_; âˆƒ; âˆƒ-syntax)
open import Data.Fin using (zero; suc; #_)
open import Data.List.Base using ([]; _âˆ·_; [_])
open import Relation.Unary

open import Type
open import Context
open import Permutations
open import Process
open import DeadlockFreedom using (deadlock-freedom)
\end{code}

In this section we revisit and expand the sample processes discussed in
\Cref{ex:booleans,ex:echo} and show their encoding in our formalisation. The
encoding of $\Bool$ is straightforward.

\begin{code}
ğ”¹ : Type
ğ”¹ = ğŸ™ âŠ• ğŸ™
\end{code}

The boolean constants are encoded thus:
\begin{code}
True : Proc [ ğ”¹ ]
True = select (ch âŸ¨ < â‰« âŸ© injâ‚ (close ch))

False : Proc [ ğ”¹ ]
False = select (ch âŸ¨ < â‰« âŸ© injâ‚‚ (close ch))
\end{code}

We can take advantage of the host language for programming higher-order
processes. For example, we can define a conditional process thus:

\begin{code}
If_Else : âˆ€[ Proc â‡’ Proc â‡’ (dual ğ”¹ âˆ·_) âŠ¢ Proc ]
If P Else Q = curryâˆ— case ch (< â‰«) ( wait (ch âŸ¨ < â‰« âŸ© P)
                                   , wait (ch âŸ¨ < â‰« âŸ© Q))
\end{code}

A term $\AgdaFunction{If}~P~\AgdaFunction{Else}~Q$ is a process that waits for a
boolean value (\cf the $\AgdaFunction{dual}~\mathbb{B}$ type at the front of its
typing context) and continues as either $P$ or $Q$ depending on whether it
receives true or false. We use \AgdaFunction{curryâˆ—} (defined in
\Cref{sec:context-agda}) to curry the constructor
\AgdaInductiveConstructor{case} so that we can supply its arguments one by one
saving a few parentheses and reducing clutter.

Next we define a process $\AgdaFunction{Drop}~P$ that consumes a boolean and
continues as $P$ regardless of its value.

\begin{code}
Drop : âˆ€[ Proc â‡’ (dual ğ”¹ âˆ·_) âŠ¢ Proc ]
Drop P = If P Else P
\end{code}

Using these higher-order forms, it is easy to define the usual boolean
connectives.

\begin{code}
!!_ : Proc [ ğ”¹ ] â†’ Proc [ ğ”¹ ]
!!_ B = curryâˆ— cut B â‰« (If False Else True)

_&&_ _||_  : Proc [ ğ”¹ ] â†’ Proc [ ğ”¹ ] â†’ Proc [ ğ”¹ ]
A && B   =  curryâˆ— cut A â‰« $
            curryâˆ— cut B â‰« $
            If (curryâˆ— link ch (< â‰«) ch) Else (Drop False)
A || B   = !! ((!! A) && (!! B))
\end{code}

The function \AgdaFunction{\$} is defined in Agda's standard library and denotes
function application. We use it here as ``separator'' to save a few parentheses.
%
Note the use of \AgdaInductiveConstructor{cut}s for combining a process that
produces a boolean value with a process that consumes a boolean value and the
use of \AgdaInductiveConstructor{link} for copying a boolean value from one
channel to another. 
%
Here we have chosen to define the disjunction \AgdaFunction{||} from the
conjunction \AgdaFunction{\&\&} and negation \AgdaFunction{!!} using De Morgan's
laws.

If we wish to test our definitions, we can implement a simple evaluator using
the deadlock freedom property. We have not proved a termination result, but
since linear logic enjoys cut elimination we can safely annotate the evaluator
as terminating.

\begin{code}
{-# TERMINATING #-}
eval : âˆ€[ Proc â‡’ Proc ]
eval P with deadlock-freedom P
... | injâ‚ (Q , _ , _)  = Q
... | injâ‚‚ (Q , _)      = eval Q
\end{code}

Now if we ask Agda to normalise the goal
$\AgdaFunction{eval}~(\AgdaFunction{False}~\AgdaFunction{||}~\AgdaFunction{False})$
we obtain
$\AgdaInductiveConstructor{select}~(\AgdaInductiveConstructor{ch~âŸ¨~<~â€¢~âŸ©~injâ‚‚}~(\AgdaInductiveConstructor{close~ch}))$,
that is the definition of \AgdaFunction{False}, as expected.

For the encoding of the echo server (\Cref{ex:echo}), recall that the server is
polymorphic in the sense that the type $X$ of the value it receives is
arbitrary. The notation $\AgdaFunction{\#}~n$ is defined in Agda's standard
library and creates an element of \AgdaDatatype{Fin} from the natural number
$n$.

\begin{code}
Echo : let X = var (# 0) in
       Proc [ `! (`âˆ€ (X â…‹ (dual X âŠ— ğŸ™))) ]
Echo = curryâˆ— server ch (< â‰«)
             ( un-[]
             , curryâˆ— all ch (< â‰«) Î» X â†’
               curryâˆ— join ch (< â‰«) $
               curryâˆ— (curryâˆ— fork ch (< â‰«)) (curryâˆ— link ch (< > â€¢) ch) (< â‰«) $
               close ch )
\end{code}

We can test the server by connecting it with a \AgdaInductiveConstructor{client}
that sends true to it.

\begin{code}
Echo-True : Proc [ ğ”¹ ]
Echo-True = curryâˆ— cut Echo â‰« $
            curryâˆ— client ch (< â‰«) $
            curryâˆ— (ex {_} {dual ğ”¹}) ch (< â‰«) $
            curryâˆ— (curryâˆ— fork ch (< â‰«)) True â‰« $
            curryâˆ— join ch (< â‰«) $
            curryâˆ— wait ch (< â‰«) $
            curryâˆ— link ch (< > â€¢) ch
\end{code}

If we ask Agda to evaluate this process we obtain \AgdaFunction{True}, as
expected.

From these examples it should be clear that writing \Calculus processes in Agda
is not entirely straightforward and requires a little effort. The lack of names
(for channels) clearly obfuscates the code, but the context splittings that must
be provided are usually small and fairly easy to understand. Most importantly,
the use of \AgdaFunction{â‰«} helps truncating context splittings as soon as the
seeked channel has been reached.
%
Either way, the formalisation is meant to study the meta-theory of \Calculus
rather than implementing a user-friendly DSL for it.
