\subsection{Type Safety}
\label{sec:safety-agda}

\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.List.Base using ([]; _âˆ·_; [_])
open import Relation.Unary

open import Type
open import Context
open import Process
open import Congruence
open import DeadlockFreedom
\end{code}

We have seen that type safety is a simple instance of deadlock freedom, which is
made even simpler to formalise in our development where processes are
intrinsically typed. We start by defining reduction contexts as processes with a
single hole. In our intrinsically-typed formalisation, reduction contexts are
parameterised by the typing context $\ContextD$ of the hole, which is invariant,
and indexed by the typing context $\ContextC$ of the whole reduction context:

\begin{code}
data ReductionContext (Î” : Context) : Context â†’ Set where
  hole   : ReductionContext Î” Î”
  cut-l  : âˆ€{A} â†’ âˆ€[  ((A âˆ·_) âŠ¢ ReductionContext Î”) âˆ— ((dual A âˆ·_) âŠ¢ Proc) â‡’
                      ReductionContext Î” ]
  cut-r  : âˆ€{A} â†’ âˆ€[  ((A âˆ·_) âŠ¢ Proc) âˆ— ((dual A âˆ·_) âŠ¢ ReductionContext Î”) â‡’
                      ReductionContext Î” ]
\end{code}

The constructor \AgdaInductiveConstructor{hole} builds a hole, as the name
implies.
%
The constructors \AgdaInductiveConstructor{cut-l} and
\AgdaInductiveConstructor{cut-r} build reduction contexts where the hole is
found in the left (respectively, right) sub-term of a cut, as per the grammar of
reduction contexts given in \Cref{sec:properties}.

Substitution inside a reduction context $\ReductionContext$ is a straightforward
function $\AgdaFunction{\_âŸ¦\_âŸ§}$ that operates recursively on the structure of
$\ReductionContext$:

\begin{code}
_âŸ¦_âŸ§ : âˆ€{Î“ Î”} â†’ ReductionContext Î” Î“ â†’ Proc Î” â†’ Proc Î“
hole               âŸ¦ P âŸ§ = P
cut-l (ğ’ âŸ¨ p âŸ© Q)  âŸ¦ P âŸ§ = cut ((ğ’ âŸ¦ P âŸ§) âŸ¨ p âŸ© Q)
cut-r (Q âŸ¨ p âŸ© ğ’)  âŸ¦ P âŸ§ = cut (Q âŸ¨ p âŸ© (ğ’ âŸ¦ P âŸ§))
\end{code}

This notion of process substitution preserves typing by construction thanks to
the fact that both processes and reduction contexts are intrinsically typed.

A process $P$ is well formed if every unguarded sub-process $Q$ in it is alive.

\begin{code}
WellFormed : âˆ€{Î“} â†’ Proc Î“ â†’ Set
WellFormed {Î“} P = âˆ€{Î”} {ğ’ : ReductionContext Î” Î“} {Q : Proc Î”} â†’
                   P âŠ’ (ğ’ âŸ¦ Q âŸ§) â†’ Alive Q
\end{code}

The proof of type safety ends up being a trivial application of
\AgdaFunction{deadlock-freedom}, since the process $Q$ in the hole of a
reduction context is well typed by construction.

\begin{code}
type-safety : âˆ€{Î“} (P : Proc Î“) â†’ WellFormed P
type-safety P {_} {_} {Q} _ = deadlock-freedom Q
\end{code}