\section{Type Safety}
\label{sec:safety-agda}

\begin{code}[hide]
open import Data.Sum
open import Data.Product using (_,_)
open import Relation.Nullary using (¬_; contradiction)
open import Data.List.Base using ([]; _∷_; [_])

open import Type
open import Context
open import Process
open import Congruence
open import Reduction
open import DeadlockFreedom
\end{code}

We have seen that type safety is a simple instance of deadlock freedom, which is
made even simpler to formalize in our development where processes are
intrinsically typed. We start by defining reduction contexts as processes with a
single hole. In our intrinsically-typed formalization, reduction contexts are
typed and indexed by two typing contexts $\ContextD$ and $\ContextC$. The latter
is the typing context under which the reduction context as a whole is well
typed. The former is the typing context of the hole, which is invariant for a
given reduction context and therefore specified as a parameter of the data type:

\begin{code}
data ReductionContext (Δ : Context) : Context → Set where
  hole   : ReductionContext Δ Δ
  cut-l  : ∀{Γ Γ₁ Γ₂ A B} (d : Dual A B) (p : Γ ≃ Γ₁ + Γ₂) →
           ReductionContext Δ (A ∷ Γ₁) → Process (B ∷ Γ₂) →
           ReductionContext Δ Γ
  cut-r  : ∀{Γ Γ₁ Γ₂ A B} (d : Dual A B) (p : Γ ≃ Γ₁ + Γ₂) →
           Process (A ∷ Γ₁) → ReductionContext Δ (B ∷ Γ₂) →
           ReductionContext Δ Γ
\end{code}

Substitution inside a reduction context $\ReductionContext$ is a straightforward
function $\AgdaFunction{\_⟦\_⟧}$ that operates recursively on the structure of
$\ReductionContext$:

\begin{code}
_⟦_⟧ : ∀{Γ Δ} → ReductionContext Δ Γ → Process Δ → Process Γ
hole ⟦ P ⟧           = P
cut-l d p 𝒞 Q ⟦ P ⟧  = cut d p (𝒞 ⟦ P ⟧) Q
cut-r d p Q 𝒞 ⟦ P ⟧  = cut d p Q (𝒞 ⟦ P ⟧)
\end{code}

A process $P$ is well formed if every unguarded sub-process $Q$ in it is alive.

\begin{code}
WellFormed        : ∀{Γ} → Process Γ → Set
WellFormed {Γ} P  = ∀{Δ} {𝒞 : ReductionContext Δ Γ} {Q : Process Δ} →
                    P ⊒ (𝒞 ⟦ Q ⟧) → Alive Q
\end{code}

The proof of type safety ends up being a trivial application of
\AgdaFunction{deadlock-freedom}.

\begin{code}
type-safety : ∀{Γ} (P : Process Γ) → WellFormed P
type-safety P {_} {_} {Q} _ = deadlock-freedom Q
\end{code}