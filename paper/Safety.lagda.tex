\section{Type Safety}
\label{sec:safety-agda}

\begin{code}[hide]
open import Data.Sum
open import Data.Product using (_,_)
open import Relation.Nullary using (Â¬_; contradiction)
open import Data.List.Base using ([]; _âˆ·_; [_])

open import Type
open import Context
open import Process
open import Congruence
open import Reduction
open import DeadlockFreedom
\end{code}

We have seen that type safety is a simple instance of deadlock freedom, which is
made even simpler to formalize in our development where processes are
intrinsically typed. We start by defining reduction contexts as processes with a
single hole. In our intrinsically-typed formalization, reduction contexts are
typed and indexed by two typing contexts $\ContextD$ and $\ContextC$. The latter
is the typing context under which the reduction context as a whole is well
typed. The former is the typing context of the hole, which is invariant for a
given reduction context and therefore specified as a parameter of the data type:

\begin{code}
data ReductionContext (Î” : Context) : Context â†’ Set where
  hole   : ReductionContext Î” Î”
  cut-l  : âˆ€{Î“ Î“â‚ Î“â‚‚ A B} (d : Dual A B) (p : Î“ â‰ƒ Î“â‚ + Î“â‚‚) â†’
           ReductionContext Î” (A âˆ· Î“â‚) â†’ Process (B âˆ· Î“â‚‚) â†’
           ReductionContext Î” Î“
  cut-r  : âˆ€{Î“ Î“â‚ Î“â‚‚ A B} (d : Dual A B) (p : Î“ â‰ƒ Î“â‚ + Î“â‚‚) â†’
           Process (A âˆ· Î“â‚) â†’ ReductionContext Î” (B âˆ· Î“â‚‚) â†’
           ReductionContext Î” Î“
\end{code}

Substitution inside a reduction context $\ReductionContext$ is a straightforward
function $\AgdaFunction{\_âŸ¦\_âŸ§}$ that operates recursively on the structure of
$\ReductionContext$:

\begin{code}
_âŸ¦_âŸ§ : âˆ€{Î“ Î”} â†’ ReductionContext Î” Î“ â†’ Process Î” â†’ Process Î“
hole âŸ¦ P âŸ§           = P
cut-l d p ğ’ Q âŸ¦ P âŸ§  = cut d p (ğ’ âŸ¦ P âŸ§) Q
cut-r d p Q ğ’ âŸ¦ P âŸ§  = cut d p Q (ğ’ âŸ¦ P âŸ§)
\end{code}

A process $P$ is well formed if every unguarded sub-process $Q$ in it is alive.

\begin{code}
WellFormed        : âˆ€{Î“} â†’ Process Î“ â†’ Set
WellFormed {Î“} P  = âˆ€{Î”} {ğ’ : ReductionContext Î” Î“} {Q : Process Î”} â†’
                    P âŠ’ (ğ’ âŸ¦ Q âŸ§) â†’ Alive Q
\end{code}

The proof of type safety ends up being a trivial application of
\AgdaFunction{deadlock-freedom}.

\begin{code}
type-safety : âˆ€{Î“} (P : Process Î“) â†’ WellFormed P
type-safety P {_} {_} {Q} _ = deadlock-freedom Q
\end{code}