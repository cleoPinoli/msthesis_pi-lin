\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Product using (_×_; _,_; ∃; ∃-syntax)
open import Data.List.Base using (List; []; _∷_; [_]; _++_)
open import Relation.Unary
open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong)

open import Type
\end{code}

\subsection{Context Representation}
\label{sec:context-agda}

We are going to adopt a nameless representation of channels. Hence, typing
contexts are represented as lists of types, where the (polymorphic) type
\AgdaDatatype{List} and its constructors \AgdaInductiveConstructor{[]} and
\AgdaInductiveConstructor{\_∷\_} are defined in the module
\AgdaModule{Data.List} of Agda's standard library. We will keep using
$\ContextC$, $\ContextD$ and $\ContextE$ to range over typing contexts, even
though in the Agda formalisation they are lists and not finite maps as in
\Cref{sec:typing-rules}.

\begin{code}
Context : Set
Context = List Type
\end{code}

The most important operation concerning typing contexts is \emph{splitting}. The
splitting of $\ContextC$ into $\ContextD$ and $\ContextE$, which we denote by
$\Splitting\ContextC\ContextD\ContextE$, represents the fact that $\ContextC$
contains all the types contained in $\ContextD$ and $\ContextE$, preserving both
their overall multiplicity and also their relative order within $\ContextD$ and
$\ContextE$. A \emph{proof} of $\Splitting\ContextC\ContextD\ContextE$ shows how
the types in $\ContextC$ are distributed in $\ContextD$ and $\ContextE$ from
left to right.

\begin{code}[hide]
infix  4 _≃_+_
infixr 8 _─∗_
infixr 9 _∗_
\end{code}
\begin{code}
data _≃_+_ : Context → Context → Context → Set where
  •   : [] ≃ [] + []
  <_  : ∀{A Γ Δ Θ} → Γ ≃ Δ + Θ → A ∷ Γ ≃ A ∷ Δ + Θ
  >_  : ∀{A Γ Δ Θ} → Γ ≃ Δ + Θ → A ∷ Γ ≃ Δ + A ∷ Θ
\end{code}

When splitting a context $\Context$ into $\ContextD + \ContextE$, for each type
in $\Context$ we use one of the prefix operators \AgdaInductiveConstructor{<}
and \AgdaInductiveConstructor{>} to indicate whether the type is meant to be
placed in $\ContextD$ or in $\ContextE$. Once we reach the end of the typing
context, we use the constructor \AgdaInductiveConstructor{•} to build the
trivial splitting of the empty context into two empty partitions.
%
For example, below is a proof of the splitting $\Splitting{[A, B, C,
D]}{[B]}{[A, C, D]}$.

\begin{code}[hide]
module _ where
  postulate A B C D : Type
\end{code}
\begin{code}
  splitting-example₁ : (A ∷ B ∷ C ∷ D ∷ []) ≃ [ B ] + (A ∷ C ∷ D ∷ [])
  splitting-example₁ = > < > > •
\end{code}

It is easy to see that splitting is commutative and that the empty context/list
is both a left and right unit of splitting.

\begin{code}
+-comm    : ∀{Γ Δ Θ} → Γ ≃ Δ + Θ → Γ ≃ Θ + Δ
≫         : ∀{Γ} → Γ ≃ [] + Γ
≪         : ∀{Γ} → Γ ≃ Γ + []
\end{code}
\begin{code}[hide]
+-comm • = •
+-comm (< p) = > (+-comm p)
+-comm (> p) = < (+-comm p)

++≃+ : ∀{Γ Δ} → Γ ++ Δ ≃ Γ + Δ
++≃+ {[]}    {[]}    = •
++≃+ {[]}    {_ ∷ _} = > ++≃+
++≃+ {_ ∷ _} {_}     = < ++≃+

≫ = ++≃+ {[]}

≪ = +-comm ≫
\end{code}

Context splitting is also associative. If we write $\ContextD + \ContextE$ for
some $\ContextC$ such that $Γ ≃ Δ + Θ$, then we can prove that $Γ_1 + (Γ_2 +
Γ_3) = (Γ_1 + Γ_2) + Γ_3$.

\begin{code}
+-assoc-r  : ∀{Γ Δ Θ Δ′ Θ′} → Γ ≃ Δ + Θ → Θ ≃ Δ′ + Θ′ →
             ∃[ Γ′ ] Γ′ ≃ Δ + Δ′ × Γ ≃ Γ′ + Θ′
+-assoc-l  : ∀{Γ Δ Θ Δ′ Θ′} → Γ ≃ Δ + Θ → Δ ≃ Δ′ + Θ′ →
             ∃[ Γ′ ] Γ′ ≃ Θ′ + Θ × Γ ≃ Δ′ + Γ′
\end{code}
\begin{code}[hide]
+-assoc-r • • = [] , • , •
+-assoc-r (< p) q with +-assoc-r p q
... | _ , p′ , q′ = _ , < p′ , < q′
+-assoc-r (> p) (< q) with +-assoc-r p q
... | _ , p′ , q′ = _ , > p′ , < q′
+-assoc-r (> p) (> q) with +-assoc-r p q
... | _ , p′ , q′ = _ , p′ , > q′

+-assoc-l p q with +-assoc-r (+-comm p) (+-comm q)
... | Δ , r , p′ = Δ , +-comm r , +-comm p′
\end{code}

\begin{code}[hide]
+-empty-l : ∀{Γ Δ} → Γ ≃ [] + Δ → Γ ≡ Δ
+-empty-l • = refl
+-empty-l (> p) = cong (_ ∷_) (+-empty-l p)
\end{code}

When proving a splitting $\Splitting\ContextC{[A]}\ContextE$ where the left
partition is a singleton $[A]$, it may be convenient to use \AgdaFunction{≫} as
a shortcut for a sequence of applications of \AgdaInductiveConstructor{>} once
the $A$ type has been reached in $\ContextC$. For instance,
\AgdaFunction{splitting-example₁} can be written equivalently and in a more
compact way as shown below. More usages of \AgdaFunction{≫} will be provided in
\Cref{sec:examples}.

\begin{code}[hide]
module _ where
\end{code}
\begin{code}
  splitting-example₂ : (A ∷ B ∷ C ∷ D ∷ []) ≃ [ B ] + (A ∷ C ∷ D ∷ [])
  splitting-example₂ = > < ≫
\end{code}

\begin{table}[t]
  \begin{tabular}{|lll|}
    \hline
    \textbf{Notation} & \textbf{Definition} & \textbf{Meaning} \\
    \hline
    $\AgdaFunction{Pred}~A~ℓ$ & $A \to \AgdaDatatype{Set}~ℓ$ & predicate over $A$ \\
    $\AgdaFunction{∀[}~P~\AgdaFunction]$ & $\forall\{x\} \to P~x$ & implicit universality \\
    $P~\AgdaFunction{⇒}~Q$ & $\lambda x \to P~x \to Q~x$ & implication \\
    $P~\AgdaFunction{∪}~Q$ & $\lambda x \to P~x~\AgdaDatatype{⊎}~Q~x$ & disjunction \\
    $P~\AgdaFunction{∩}~Q$ & $\lambda x \to P~x~\AgdaDatatype{×}~Q~x$ & conjunction \\
    $f~\AgdaFunction{⊢}~P$ & $\lambda x \to P~(f~x)$ & update \\
    $\AgdaFunction{U}$ & $\lambda x \to \AgdaModule{Data.Unit}.\AgdaDatatype{⊤}$ & universal
    set \\
    $\AgdaFunction{⋂[}~X~\AgdaFunction{:}~A~\AgdaFunction]~P$ & $\lambda x \to (X : A) \to P~X~x$ & infinitary conjunction \\
    \hline
  \end{tabular}
  \caption{\label{tab:predicates} Useful definitions in Agda's \AgdaModule{Relation.Unary} module.}
\end{table}

From now on we will make extensive use of predicates over contexts. For this
reason, it is worth recalling in \Cref{tab:predicates} a number of definitions
from the module \AgdaModule{Relation.Unary} of Agda's standard library.
%
We begin using these definitions for building a few abstractions inspired to
separation logic~\cite{OHearnPym99} that allow us to hide context splittings, at
least in some cases.
%
Following~\citet{RouvoetPoulsenKrebbersVisser20}, we define the \emph{separating
conjunction} $P \sand Q$ of two predicates $P$ and $Q$ over contexts:
\begin{code}
data _∗_ (P Q : Pred Context _) (Γ : Context) : Set where
  _⟨_⟩_ : ∀{Δ Θ} → P Δ → Γ ≃ Δ + Θ → Q Θ → (P ∗ Q) Γ
\end{code}

If $P$ and $Q$ are predicates over contexts, the predicate $P \sand Q$ holds for
those contexts $\ContextC$ that can be split into $\ContextD$ and $\ContextE$ so
that $P$ holds for $\ContextD$ and $Q$ holds for $\ContextE$.
%
The constructor \AgdaInductiveConstructor{\_⟨\_⟩\_} has three explicit arguments
witnessing the splitting $\Splitting\ContextC\ContextD\ContextE$ along with
proofs of $P~\ContextD$ and $Q~\ContextE$.
%
The use of metavariables $P$ and $Q$ for denoting predicates over contexts is
appropriate: as we will see shortly, in our formalisation processes are indeed
an example of predicate over typing contexts.

Along with \AgdaDatatype{∗} we define the \emph{separating implication} (also
known as ``magic wand'')
\begin{code}
_─∗_ : Pred Context _ → Pred Context _ → Context → Set
(P ─∗ Q) Δ = ∀{Θ Γ} → Γ ≃ Δ + Θ → P Θ → Q Γ
\end{code}
and prove that \AgdaFunction{─∗} can be used to curry \AgdaDatatype{∗}:
\begin{code}
curry∗ : ∀{P Q R} → ∀[ P ∗ Q ⇒ R ] → ∀[ P ⇒ Q ─∗ R ]
curry∗ F px σ qx = F (px ⟨ σ ⟩ qx)
\end{code}

To conclude the implementation of typing contexts, we define a predicate
\AgdaDatatype{Un} that holds for \emph{unrestricted} contexts, those solely made
of types of the form $?A$. We need this predicate in the definition of a server,
which must comply with the typing rule \ServerRule in \Cref{tab:typing-rules}.

\begin{code}
data Un : Context → Set where
  un-[]  : Un []
  un-∷   : ∀{A} → ∀[ Un ⇒ (`? A ∷_) ⊢ Un ]
\end{code}

The empty context is trivially unrestricted. A non-empty context is unrestricted
if its head has the form $\WhyNot A$ for some $A$ and provided that its tail is
unrestricted as well.
%
It is easy to prove that $\ContextC$ is unrestricted if so are $\ContextD$ and
$\ContextE$ when $\Splitting\ContextC\ContextD\ContextE$:

\begin{code}
∗-un : ∀[ Un ∗ Un ⇒ Un ]
\end{code}
\begin{code}[hide]
∗-un (un-[] ⟨ • ⟩ un-[])    = un-[]
∗-un (un-∷ un ⟨ < σ ⟩ un′)  = un-∷ (∗-un (un ⟨ σ ⟩ un′))
∗-un (un ⟨ > σ ⟩ un-∷ un′)  = un-∷ (∗-un (un ⟨ σ ⟩ un′))
\end{code}
