\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Product using (_×_; _,_; ∃; ∃-syntax)
open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong; cong₂)
open import Data.List.Base using (List; []; _∷_; [_]; _++_; map)

open import Type
\end{code}

\subsection{Context Representation}
\label{sec:context-agda}

We are going to adopt a nameless representation of channels whereby a channel is
identified by its position in a typing context. This representation is akin to
using De Bruijn indices, except that the index, instead of being represented
explicitly by a natural number, is computable from the \emph{proof} that the
type of the channel belong to the typing context.
%
Typing contexts are represented using \emph{lists} of types, where the
(polymorphic) \AgdaDatatype{List} type is defined in Agda's standard library.

\begin{code}
Context : Set
Context = List Type
\end{code}

The most important operation concerning typing contexts is \emph{splitting}. The
splitting of $\ContextC$ into $\ContextD$ and $\ContextE$, which is denoted by
$\Splitting\ContextC\ContextD\ContextE$, represents the fact that $\ContextC$
contains all the types contained in $\ContextD$ and $\ContextE$, preserving both
their overall \emph{multiplicity} and also their relative \emph{order} within
$\ContextD$ and $\ContextE$. A \emph{proof} of
$\Splitting\ContextC\ContextD\ContextE$ shows how the types in $\ContextC$ are
distributed in $\ContextD$ and $\ContextE$ from left to right.

\begin{code}[hide]
infix 4 _≃_+_ _∋_⊳_
\end{code}
\begin{code}
data _≃_+_ : Context → Context → Context → Set where
  •   : [] ≃ [] + []
  <_  : ∀{A Γ Δ Θ} → Γ ≃ Δ + Θ → A ∷ Γ ≃ A ∷ Δ + Θ
  >_  : ∀{A Γ Δ Θ} → Γ ≃ Δ + Θ → A ∷ Γ ≃ Δ + A ∷ Θ
\end{code}

When splitting a context $\Context$ into $\ContextD + \ContextE$,
for each type in $\Context$ we use one of the prefix operators \AgdaInductiveConstructor{<\_} and \AgdaInductiveConstructor{>\_} to indicate whether it is meant to be placed in $\ContextD$ or $\ContextE$,
respectively.
%
As an example, below is the splitting of the context $[A, B, C, D]$ into $[B] + [A, C, D]$.

\begin{code}[hide]
module _ where
  postulate A B C D : Type
\end{code}
\begin{code}
  splitting-example₁ : (A ∷ B ∷ C ∷ D ∷ []) ≃ (B ∷ []) + (A ∷ C ∷ D ∷ [])
  splitting-example₁ = > < > > •
\end{code}

Context splitting enjoys a number of expected properties. In particular, it is
easy to see that splitting is commutative and that the empty context is both a
left and right unit of splitting.

\begin{code}
+-comm    : ∀{Γ Δ Θ} → Γ ≃ Δ + Θ → Γ ≃ Θ + Δ
≫         : ∀{Γ} → Γ ≃ [] + Γ
≪         : ∀{Γ} → Γ ≃ Γ + []
\end{code}
\begin{code}[hide]
+-comm • = •
+-comm (< p) = > (+-comm p)
+-comm (> p) = < (+-comm p)

++≃+ : ∀{Γ Δ} → Γ ++ Δ ≃ Γ + Δ
++≃+ {[]}    {[]}    = •
++≃+ {[]}    {_ ∷ _} = > ++≃+
++≃+ {_ ∷ _} {_}     = < ++≃+

≫ = ++≃+ {[]}

≪ = +-comm ≫
\end{code}

Context splitting is also associative in a sense that is made precise below. If
we write $\ContextD + \ContextE$ for some $\ContextC$ such that $Γ ≃ Δ + Θ$, then
we can prove that $Γ_1 + (Γ_2 + Γ_3) = (Γ_1 + Γ_2) + Γ_3$.

\begin{code}
+-assoc-r  : ∀{Γ Δ Θ Δ′ Θ′} → Γ ≃ Δ + Θ → Θ ≃ Δ′ + Θ′ →
             ∃[ Γ′ ] Γ′ ≃ Δ + Δ′ × Γ ≃ Γ′ + Θ′
+-assoc-l  : ∀{Γ Δ Θ Δ′ Θ′} → Γ ≃ Δ + Θ → Δ ≃ Δ′ + Θ′ →
             ∃[ Γ′ ] Γ′ ≃ Θ′ + Θ × Γ ≃ Δ′ + Γ′
\end{code}
\begin{code}[hide]
+-assoc-r • • = [] , • , •
+-assoc-r (< p) q with +-assoc-r p q
... | _ , p′ , q′ = _ , < p′ , < q′
+-assoc-r (> p) (< q) with +-assoc-r p q
... | _ , p′ , q′ = _ , > p′ , < q′
+-assoc-r (> p) (> q) with +-assoc-r p q
... | _ , p′ , q′ = _ , p′ , > q′

+-assoc-l p q with +-assoc-r (+-comm p) (+-comm q)
... | Δ , r , p′ = Δ , +-comm r , +-comm p′
\end{code}

It is often the case that the context $\ContextD$ in a splitting
$\Splitting\ContextC\ContextD\ContextE$ is a singleton list $[A]$. We use this
particular splitting to describe the presence of a channel of type $A$ in
$\ContextC$ and giving a name $\ContextE$ to the residual context. For this
particular case, we introduce a dedicated notation that allows us to write this
case in a more compact and meaningful way, as
$\SimpleSplitting\ContextC{A}\ContextE$.

\begin{code}
_∋_⊳_ : Context → Type → Context → Set
Γ ∋ A ⊳ Δ = Γ ≃ [ A ] + Δ
\end{code}
\begin{code}[hide]
+-empty-l : ∀{Γ Δ} → Γ ≃ [] + Δ → Γ ≡ Δ
+-empty-l • = refl
+-empty-l (> p) = cong (_ ∷_) (+-empty-l p)
\end{code}

Note that, when specifying a splitting $\SimpleSplitting\ContextC{A}\ContextE$,
it may be convenient to use \AgdaFunction{≫} as a shortcut for a sequence of
applications of \AgdaInductiveConstructor{>\_} after the $A$ type has been
reached. For instance, the same sample splitting shown earlier can be written
equivalently and in a more compact way as shown below. More examples will be
given in \Cref{sec:examples}.

\begin{code}[hide]
module _ where
\end{code}
\begin{code}
  splitting-example₂ : (A ∷ B ∷ C ∷ D ∷ []) ∋ B ⊳ (A ∷ C ∷ D ∷ [])
  splitting-example₂ = > < ≫
\end{code}

To conclude the modeling of typing contexts, we define a predicate $\AgdaDatatype{Un}~\Context$ that holds
whenever $\Context$ is \emph{unrestricted}, namely when it is made of types of
the form $?A$. We will need this predicate in the definition of a server, which
must obey the typing rule \ServerRule of \Cref{tab:typing-rules}.

\begin{code}
data Un : Context → Set where
  un-[]  : Un []
  un-∷   : ∀{A Γ} → Un Γ → Un (`? A ∷ Γ)
\end{code}

It is a simple fact that the merging of two unrestricted contexts
$\Context_1$ and $\Context_2$ results in an unrestricted context.\Luca{Serve?}

\begin{code}
+-un : ∀{Γ Γ₁ Γ₂} → Γ ≃ Γ₁ + Γ₂ → Un Γ₁ → Un Γ₂ → Un Γ
\end{code}
\begin{code}[hide]
+-un • un-[] un-[] = un-[]
+-un (< p) (un-∷ un₁) un₂ = un-∷ (+-un p un₁ un₂)
+-un (> p) un₁ (un-∷ un₂) = un-∷ (+-un p un₁ un₂)
\end{code}