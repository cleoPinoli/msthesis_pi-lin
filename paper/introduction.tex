\section{Introduction}
\label{sec:introduction}

The Concurrent Calculi Formalisation Benchmark~\citep{CarboneEtAl24} is a
collection of challenges concerning the mechanisation of formal models of
concurrent and distributed programming languages.
%
These models often make use of distinctive features that set them apart from the
formal models of \emph{sequential} programming languages, such as the adoption
of substructural (linear, affine) type systems, the dynamic scope of first-class
channels in systems of communicating processes, the need for coinductive
definitions and proof methods for describing and reasoning on possibly infinite
behaviors.
%
The benchmark aims at identifying effective formalization techniques that take
these features into account so as to foster the adoption of machine-checked
proofs in research work concerning concurrent and distributed programming
languages.

One of the challenges in the benchmark, henceforth called \emph{linearity
challenge}, concerns the formalization of a \emph{session calculus}.
%
Sessions and session types~\citep{Honda93,HondaVasconcelosKubo98,HuttelEtAl16}
are established formalisms for the static analysis of distributed programs based
on peer-to-peer communication channels. Every session type system revolves
around three key ideas: (1) session endpoints are \emph{linear resources} that
cannot be discarded or duplicated without compromising some safety and liveness
properties of a program; (2) the type of a session endpoint is \emph{updated}
after each use to reflect the state of the interaction it describes; (3) peer
session endpoints are meant to be used in complementary ways so as to guarantee
the absence of communication errors and, to some extent, progress of the
interaction.
%
The linearity challenge is motivated by the observation that the proper handling
of linear resources in a formalization often requires a large number of complex
auxiliary definitions and technical results that divert from the main problem
under consideration. One of the alleged culprits of such unwanted complexity is
\emph{context splitting}, namely the operation that partitions a typing context
in such a way that the linear resources described therein end up in only one of
the partitions. This observation has led to the development of various
alternatives to context splitting including leftover
typing~\cite{ZalakainDardha21}, the use of linearity
predicates~\cite{SanoKavanaghPientka23} and tagged contexts~\cite{ZackonEtAl25}.

This paper presents a solution to the linearity challenge.
%
The calculus that we formalize, dubbed \Calculus, and the one in the challenge
description differ for two key aspects.
%
First of all, the challenge only considers a minimal calculus of first-order
sessions, whereas \LCP is a fully-featured calculus that includes support for
higher-order, polymorphic, linear and shared channels. Also, \LCP is closely
related to \CP~\citep{Wadler14} and its type system coincides with the proof
system of classical linear logic.
%
The second difference is that the calculus in the challenge is equipped with
\emph{native} sessions, whereas \LCP features shared channels, which are
unrestricted, and linear channels, which are meant to be used for a
\emph{single} communication. Structured sessions involving the exchange of
several messages can be modeled using \emph{explicit continuations} according to
the well-known encoding of (binary) sessions into linear
channels~\citep{KobayashiPierceTurner99,Kobayashi02b,DardhaGiachinoSangiorgi17}.
%
Overall, \LCP has the same expressive power of \CP, but is a lower-level
calculus in which sessions are encodable instead of being featured natively.

Compared to the other analogous formalizations of session/linear
calculi~\cite{GotoEtAl16,Thiemann19,CicconePadovani20,CastroFerreiraYoshida20,RouvoetPoulsenKrebbersVisser20,ZalakainDardha21,JacobsBalzerKrebbers22,SanoKavanaghPientka23,ZackonEtAl25},
the one we present here is both the most complete (in terms of features
supported by the calculus) and the most streamlined (in terms of code size). It
is also one of only two formalizations that prove the deadlock freedom property
for a session calculus, and it does so with substantially less code than the
existing formalization~\cite{JacobsBalzerKrebbers22}.

We acknowledge that \LCP is not 

The differences between \LCP and the calculus are functional to the simplicity
of its formalization.

the outcome of our investigation are somehow surprising in the sense that the
premises of the challenge and the assumption that the main technical challenge
is the representation of contexts

congetturiamo che la semplicità della formalizzazione derivi dalle
caratteristiche del calcolo più che dalle tecniche utilizzate, che alla fine
sono piuttosto standard.

We value these aspects of \Calculus because their combined effect allows us to
obtain a remarkably simple formalization.
%
The fact of working with a calculus based on linear logic prevents \emph{by
construction} the same (sequential) process to own both endpoints of a session.
This situation is clearly undesirable since it does not correspond to a useful
pattern of interaction (every meaningful session requires its endpoints to be
used by parallel processes) and is a potential source of deadlocks.
%
From the standpoint of the formalization, where the representation of channel
names is a primary design choice, it spares us the need to \emph{distinguish}
the two endpoints of a session, \eg by means of polarities~\citep{GayHole05} or
by using different names connected by the same
binder~\citep{Vasconcelos12,GayVasconcelos25}.
%
Also, the fact of working with a calculus with \emph{linear} channels and
explicit continuations spares us the need to \emph{update} the type of channels
in typing contexts. When a channel is used it is effectively consumed, therefore
its type can be \emph{removed} from the typing context and the type of the
continuation channel is \emph{added} back to the typing context. As is turns
out, removing and adding types is easier than updating them. Even more so
considering that the type of continuation channels can be conveniently added
\emph{at the beginning} of a typing context, since such channels are fresh by
definition.

BISOGNA PARLARE DI RELATED WORK

The rest of the paper is structured as follows. \Cref{sec:calculus} describes
the syntax and the operational semantics of \Calculus and states the properties
of well-typed processes that we formalize and prove. \Cref{sec:agda} outlines
the essential aspects of the formalization with particular emphasis on the
representation of channel names and typing contexts. \Cref{sec:conclusion}
summarizes our contributions, discusses some extensions and future work. The
formalization has been carried out using Agda and its full code is available
from a public\Luca{Related work? Confronto con altre formalizzazioni?}
repository.\footnote{\url{https://github.com/boystrange/LinearityChallenge/tree/main/cp}}

