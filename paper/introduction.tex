\section{Introduction}
\label{sec:introduction}

The Concurrent Calculi Formalisation Benchmark~\citep{CarboneEtAl24} is a
collection of challenges concerning the mechanisation of formal models of
concurrent and distributed programming languages.
%
These models often make use of distinctive features that set them apart from the
formal models of \emph{sequential} programming languages, such as the adoption
of substructural (linear, affine) type systems, the dynamic scope of first-class
channels in systems of communicating processes, the need for coinductive
definitions and proof methods for describing and reasoning on possibly infinite
behaviors.
%
The benchmark aims at identifying effective formalisation techniques that take
these features into account so as to foster the adoption of machine-checked
proofs in research work concerning concurrent and distributed programming
languages.

One of the challenges in the benchmark, henceforth called \emph{linearity
challenge}, concerns the formalisation of a \emph{minimal calculus of sessions}.
%
Sessions and session types~\citep{Honda93,HondaVasconcelosKubo98,HuttelEtAl16}
are established abstractions for the static analysis of distributed programs
based on peer-to-peer communication channels. Every session type system revolves
around three key ideas: (1) session endpoints are \emph{linear resources} that
cannot be discarded or duplicated without compromising some safety and liveness
properties of a program; (2) the type of a session endpoint is \emph{updated}
after each use to reflect the state of the interaction it describes; (3) peer
session endpoints are meant to be used in complementary ways so as to guarantee
the absence of communication errors and, to some extent, progress of the
interaction.
%
The linearity challenge is motivated by the observation that the proper
management of linear resources in a formalisation often requires a large number
of auxiliary definitions and technical results that divert from the main problem
under study~\cite{CarboneEtAl24}. One of the alleged culprits of such complexity
is \emph{context splitting}, namely the operation that partitions a typing
context in such a way that the linear resources described therein end up in only
one of the partitions. This observation has led to the exploration of various
alternative techniques including leftover typing~\cite{ZalakainDardha21}, the
use of linearity predicates~\cite{SanoKavanaghPientka23} and tagged
contexts~\cite{ZackonEtAl25}.

In this paper we approach the linearity challenge from a different angle:
\emph{instead of proposing new techniques that make it easy to formalise the
calculus in the challenge, we propose a (relatively) new calculus that is easy
to formalise with the existing techniques}.
%
More specifically, we describe a calculus called \LCP whose type system
coincides with the proof system of classical linear logic and that features
\emph{linear channels} instead of sessions. Linear channels are meant to be used
for a \emph{single} communication. Structured communications involving the
exchange of several messages within the same session are modeled in \LCP using
\emph{explicit continuations} according to the well-known encoding of (binary)
sessions into the linear
$\pi$-calculus~\citep{KobayashiPierceTurner99,Kobayashi02b,DardhaGiachinoSangiorgi17}.
%
Overall, \LCP is a linear version of \CP~\cite{Wadler14} in which sessions are
encoded instead of being featured natively.

The logical foundations of \LCP and the use of explicit continuations play an
important role in taming the complexity of the formalisation.
%
Using a calculus based on linear logic prevents \emph{by construction} the same
(sequential) process to own both endpoints of a session. This situation is
clearly undesirable since it does not correspond to a useful pattern of
interaction (every meaningful session requires its endpoints to be used by
parallel processes) and is a potential source of deadlocks.
%
From the standpoint of the formalisation, where the representation of channels
is a primary design choice, it spares us the need to distinguish the two
endpoints of a session, \eg by means of
polarities~\citep{GayHole05,ZalakainDardha21} or by using different names
connected by the same binder~\citep{Vasconcelos12,GayVasconcelos25}.
%
Using a calculus with linear channels and explicit continuations spares us the
need to \emph{update} the type of channels in typing contexts. Once a channel
has been used it is effectively consumed, therefore its type can be
\emph{removed} from the typing context and the type of the continuation channel
is \emph{added} back to the typing context. As is turns out, removing and adding
types is easier than updating them. Even more so considering that the type of
continuation channels must be added \emph{at the beginning} of a typing context,
since such channels are fresh by definition.

The formalisation of \LCP that we obtain is both the most complete (in terms of
features supported by the calculus) and the most streamlined (in terms of code
size) among the known formalisations of session/linear
calculi~\cite{GotoEtAl16,Thiemann19,CastroFerreiraYoshida20,CicconePadovani20,RouvoetPoulsenKrebbersVisser20,SanoKavanaghPientka23,JacobsBalzerKrebbers22,ZackonEtAl25,ZalakainDardha21}.
It is also one of only two formalisations that prove the deadlock freedom
property for a session calculus~\cite{JacobsBalzerKrebbers22} and it does so
with substantially less code.

The rest of the paper is organised as follows.
%
\Cref{sec:calculus} describes the syntax and the operational semantics of \LCP
and states the properties of well-typed processes that we formalise and prove,
namely typing preservation, deadlock freedom and runtime safety.
%
\Cref{sec:agda} presents the Agda formalisation and illustrates its key aspects
with particular emphasis on the representation of channels and of typing
contexts. We assume that the reader is somewhat familiar about Agda but we
recall the lesser known definitions from Agda's standard library.
%
\Cref{sec:related} discusses related work more in detail by providing a
qualitative and quantitative comparison between the known formalisations of
session/linear calculi.
%
\Cref{sec:conclusion} summarises our contributions and discusses ongoing and
future work.

The formalisation has been checked with Agda 2.8.0 and the code is available on
GitHub at \url{https://github.com/boystrange/LinearityChallenge/tree/main/lcp}.

