\section{Introduction}
\label{sec:introduction}

The Concurrent Calculi Formalisation Benchmark~\citep{CarboneEtAl24} is a
collection of challenges concerning the mechanisation of core models of
concurrent and distributed programming languages.
%
These models often make use of distinctive features that set them apart from the
models of sequential programming languages, such as the adoption of
substructural (linear, affine) type systems, the dynamic scope of first-class
channels in systems of communicating processes, the need for coinductive
definitions and proof methods for describing and reasoning on possibly infinite
behaviours.
%
The benchmark aims at identifying effective formalisation techniques that take
these features into account so as to foster the adoption of machine-checked
proofs in research work concerning concurrent and distributed programming
languages.

One of the challenges in the benchmark, henceforth called \emph{linearity
challenge}, concerns the formalisation of a \emph{minimal calculus of sessions}.
%
Sessions and session
types~\citep{Honda93,HondaVasconcelosKubo98,HuttelEtAl16,GayVasconcelos25} are
established abstractions for the static analysis of distributed programs based
on peer-to-peer communications. Every session type system revolves around three
key ideas: (1) session endpoints are \emph{linear resources} that cannot be
discarded or duplicated without compromising some safety and liveness properties
of a program; (2) the type of a session endpoint is \emph{updated} after each
use to reflect the state of the protocol it describes; (3) peer session
endpoints are meant to be used in complementary ways so as to guarantee the
absence of communication errors and, to some extent, progress of the
interaction.
%
The linearity challenge is based on the observation that the proper management
of linear resources in a formalisation often requires a large number of
auxiliary definitions and technical results that divert from the main problem
under study~\cite{CarboneEtAl24}. One of the alleged culprits of such complexity
is \emph{context splitting}, namely the operation that partitions a typing
context in such a way that the linear resources described therein end up in only
one of the partitions. This observation has led to the exploration of various
alternative techniques including leftover typing~\cite{ZalakainDardha21}, the
use of linearity predicates~\cite{SanoKavanaghPientka23} and tagged
contexts~\cite{ZackonEtAl25}.

In this paper we approach the linearity challenge from a different angle:
\emph{instead of proposing new techniques that make it easy to formalise the
calculus in the challenge, we propose a (relatively) new calculus that is easy
to formalise with the existing techniques}.
%
More specifically, we describe the Linear Calculus of Continuations (\LCC) whose
type system coincides with the proof system of classical linear logic and that
features \emph{linear channels} instead of sessions. While a session endpoint
can be used \emph{multiple times} (sequentially), linear channels must be used
\emph{exactly once}. \LCC retains the expressiveness of other session calculi
thanks to \emph{explicit continuations}, which enable the encoding of (binary)
sessions is terms of linear
channels~\citep{Kobayashi02b,DardhaGiachinoSangiorgi17}: each message exchanged
on a linear channel may include one or two fresh channels -- the
\emph{continuations} -- on which the rest of the conversation takes place.
%
Overall, \LCC is nothing but a low-level version of \CP~\cite{Wadler14} --
Wadler's calculus of sessions based on classical linear logic -- such that
sessions can be encoded instead of being featured natively.

The logical foundations of \LCC and the use of explicit continuations play an
important role in taming the complexity of the formalisation.
%
Working with a calculus based on linear logic prevents \emph{by construction}
the same (sequential) process to own both endpoints of a session. This situation
is clearly undesirable since it does not correspond to a useful pattern of
interaction (every meaningful session requires its endpoints to be used by
parallel processes) and is a potential source of deadlocks.
%
From the standpoint of the formalisation, where the representation of channels
is a primary design choice, it spares us the need to distinguish the two
endpoints of a session, \eg by means of
polarities~\citep{GayHole05,ZalakainDardha21} or by using different names
connected by the same binder~\citep{Vasconcelos12,GayVasconcelos25}.
%
Using a calculus with linear channels and explicit continuations spares us the
need to \emph{update} the type of channels in typing contexts. Once a channel
has been used it is effectively consumed, therefore its type can be
\emph{removed} from the typing context and the type of the continuation channel
is \emph{added} back to the typing context. As is turns out, removing and adding
types is easier than updating them. Even more so considering that the type of
continuation channels must be added \emph{at the beginning} of a typing context,
since such channels are fresh by definition.

The formalisation of \LCC that we obtain is both the most complete (in terms of
features supported by the calculus) and the most streamlined (in terms of code
size) among the known formalisations of session/linear
calculi~\cite{GotoEtAl16,Thiemann19,CastroFerreiraYoshida20,CicconePadovani20,RouvoetPoulsenKrebbersVisser20,SanoKavanaghPientka23,JacobsBalzerKrebbers22,ZackonEtAl25,ZalakainDardha21}.
It is also one of only two formalisations that prove the deadlock freedom
property for a session calculus~\cite{JacobsBalzerKrebbers22} and it does so
with substantially less code.

The rest of the paper is organised as follows.
%
\Cref{sec:calculus} describes the syntax and the operational semantics of \LCC
and states the properties of well-typed processes that we formalise and prove,
namely typing preservation, deadlock freedom and runtime safety.
%
\Cref{sec:agda} illustrates the key aspects of the Agda formalisation with
particular emphasis on the representation of channels and of typing contexts. We
assume that the reader is somewhat familiar about Agda but we recall the lesser
known definitions from Agda's standard library.
%
\Cref{sec:related} discusses related work more in detail by providing a
qualitative and quantitative comparison between the known formalisations of
session/linear calculi.
%
\Cref{sec:conclusion} summarises our contributions and discusses ongoing and
future work.

The formalisation has been checked with Agda 2.8.0 and the code is available on
in a public repository on GitHub~\cite{PadovaniRaffaelli25}.

