\section{Introduction}
\label{sec:introduction}

The Concurrent Calculi Formalisation Benchmark~\citep{CarboneEtAl24} is a
collection of challenges concerning the mechanisation of formal models of
concurrent and distributed programming languages.
%
These models often make use of distinctive features that set them apart from the
formal models of \emph{sequential} programming languages, such as the adoption
of substructural (linear, affine) type systems, the dynamic scope of first-class
channels in systems of communicating processes, the need for coinductive
definitions and proof methods for describing and reasoning on possibly infinite
behaviors.
%
The benchmark aims at identifying effective formalization techniques that take
these features into account so as to foster the adoption of machine-checked
proofs in research work concerning concurrent and distributed programming
languages.

One of the challenges in the benchmark, henceforth called \emph{linearity
challenge}, concerns the formalization of a \emph{session calculus}.
%
Sessions and session types~\citep{Honda93,HondaVasconcelosKubo98,HuttelEtAl16}
are established formalisms for the static analysis of distributed programs based
on peer-to-peer communication channels. Every session type system revolves
around three key ideas: (1) session endpoints are \emph{linear resources} that
cannot be discarded or duplicated without compromising some safety and liveness
properties of a program; (2) the type of a session endpoint is \emph{updated}
after each use to reflect the state of the interaction it describes; (3) peer
session endpoints are meant to be used in complementary ways so as to guarantee
the absence of communication errors and, to some extent, progress of the
interaction.
%
The linearity challenge is motivated by the observation that the proper handling
of linear resources in a formalization often requires a large number of complex
auxiliary definitions and technical results that divert from the main problem
under consideration. One of the alleged culprits of such unwanted complexity is
\emph{context splitting}, namely the operation that partitions a typing context
in such a way that the linear resources described therein end up in only one of
the partitions. This observation has led to the development of various
alternatives to context splitting including leftover
typing~\cite{ZalakainDardha21}, the use of linearity
predicates~\cite{SanoKavanaghPientka23} and tagged contexts~\cite{ZackonEtAl25}.

This paper proposes a logical and linear solution of the linearity challenge. By
``logical and linear solution'' we mean that the calculus that we formalize,
dubbed \Calculus, and the one in the challenge description differ for two key
aspects.
%
First of all, the challenge considers an \emph{ad hoc}, minimal calculus of
first-order sessions, whereas \LCP is a fully-featured calculus that supports
higher-order, polymorphic, linear and shared channels. Also, \LCP is closely
related to \CP~\citep{Wadler14} and its type system coincides with the proof
system of classical linear logic.
%
The second difference is that the calculus in the challenge is equipped with
\emph{native} sessions, whereas \LCP features linear channels that are meant to
be used for a \emph{single} communication. Structured sessions involving the
exchange of several messages can be modeled using \emph{explicit continuations}
according to the well-known encoding of (binary) sessions into linear
channels~\citep{KobayashiPierceTurner99,Kobayashi02b,DardhaGiachinoSangiorgi17}.
%
Overall, \LCP is a lower-level calculus in which sessions are encodable instead
of being featured natively, but it has the same expressive power of \CP.

We value these differences between \LCP and the calculus in the challenge
description because we think that they contribute to the simplicity of the
formalization more than the adopted formalization techniques, which end up being
fairly standard.\Luca{Our work fits the spirit of the challenge identifying not
only the most appropriate techniques but also the most appropriate models that
aid the formalization of concurrent/distributed models of computation.}
%
The fact of working with a calculus based on linear logic prevents \emph{by
construction} the same (sequential) process to own both endpoints of a session.
This situation is clearly undesirable since it does not correspond to a useful
pattern of interaction (every meaningful session requires its endpoints to be
used by parallel processes) and is a potential source of deadlocks.
%
From the standpoint of the formalization, where the representation of channel
names is a primary design choice, it spares us the need to \emph{distinguish}
the two endpoints of a session, \eg by means of polarities~\citep{GayHole05} or
by using different names connected by the same
binder~\citep{Vasconcelos12,GayVasconcelos25}.
%
Also, the fact of working with a calculus with \emph{linear} channels and
explicit continuations spares us the need to \emph{update} the type of channels
in typing contexts. When a channel is used it is effectively consumed, therefore
its type can be \emph{removed} from the typing context and the type of the
continuation channel is \emph{added} back to the typing context. As is turns
out, removing and adding types is easier than updating them. Even more so
considering that the type of continuation channels can be conveniently added
\emph{at the beginning} of a typing context, since such channels are fresh by
definition.

% Compared to the other analogous formalizations of session/linear
% calculi~\cite{GotoEtAl16,Thiemann19,CicconePadovani20,CastroFerreiraYoshida20,RouvoetPoulsenKrebbersVisser20,ZalakainDardha21,JacobsBalzerKrebbers22,SanoKavanaghPientka23,ZackonEtAl25},
% the one we present here is both the most complete (in terms of features
% supported by the calculus) and the most streamlined (in terms of code size). It
% is also one of only two formalizations that prove the deadlock freedom property
% for a session calculus, and it does so with substantially less code than the
% existing formalization~\cite{JacobsBalzerKrebbers22}.

\subparagraph*{Structure of the paper.}
%
\Cref{sec:calculus} describes the syntax and the operational semantics of \LCP
and states the properties of well-typed processes that we formalize and prove,
namely typing preservation, deadlock freedom and runtime safety.
%
\Cref{sec:agda} presents a roadmap of the Agda formalization and discusses its
key aspects with particular emphasis on the representation of channel names and
of typing contexts.
%
\Cref{sec:examples} illustrates a few examples of \LCP processes as they are
represented in Agda and shows how to use Agda as an interpreter for \LCP.
%
\Cref{sec:related} discusses related work more in detail by providing a
qualitative and quantitative comparison between the known formalizations of
session/linear calculi, including the one for \LCP.
%
\Cref{sec:conclusion} summarizes our contributions and discusses some ongoing
and future work.

The formalization has been carried out using Agda and the source code is
available on Github at
\url{https://github.com/boystrange/LinearityChallenge/tree/main/lcp}.

