\subsection{Examples}
\label{sec:examples}

\begin{code}[hide]%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--rewriting}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Function}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}\$\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Sum}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj‚ÇÅ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{inj‚ÇÇ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}√ó\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{‚àÉ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{‚àÉ-syntax}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{curry}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Fin}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\#\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.List.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}‚à∑\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[\AgdaUnderscore{}]}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Unary}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Type}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Context}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Permutations}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Process}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{DeadlockFreedom}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{deadlock-freedom}\AgdaSymbol{)}\<%
\end{code}

In this section we revisit and expand the processes discussed in
\Cref{ex:booleans,ex:echo} and show their encoding in our formalisation. The
encoding of $\Bool$ is straightforward

\begin{code}%
\>[0]\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\\
\>[0]\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ùüô}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚äï}}\AgdaSpace{}%
\AgdaInductiveConstructor{ùüô}\<%
\end{code}
and the boolean constants are encoded thus:
\begin{code}%
\>[0]\AgdaFunction{True}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\<%
\\
\>[0]\AgdaFunction{True}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{select}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚ü®}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚ü©}}\AgdaSpace{}%
\AgdaInductiveConstructor{inj‚ÇÅ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{close}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSymbol{))}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{False}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\<%
\\
\>[0]\AgdaFunction{False}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{select}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚ü®}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚ü©}}\AgdaSpace{}%
\AgdaInductiveConstructor{inj‚ÇÇ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{close}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSymbol{))}\<%
\end{code}

We take advantage of the host language for programming higher-order processes.
For example, we can define a conditional process thus:

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{If\AgdaUnderscore{}Else}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{‚àÄ[}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚áí}}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚áí}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{dual}\AgdaSpace{}%
\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚à∑\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚ä¢}}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaFunction{]}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{If}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Else}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{case}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSymbol{)}%
\>[103I]\AgdaSymbol{(}\AgdaSpace{}%
\AgdaInductiveConstructor{wait}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚ü®}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚ü©}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[103I]%
\>[35]\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{wait}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚ü®}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚ü©}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{))}\<%
\end{code}

A term $\AgdaFunction{If}~P~\AgdaFunction{Else}~Q$ is a process that waits for a
boolean value (\cf the $\AgdaFunction{dual}~\mathbb{B}$ type at the front of its
typing context) and continues as either $P$ or $Q$ depending on whether it
receives true or false. We use \AgdaFunction{curry‚àó} (defined in
\Cref{sec:context-agda}) to curry the constructor
\AgdaInductiveConstructor{case} so that we can supply its arguments one by one
saving a few parentheses and reducing clutter.

Next we define a process $\AgdaFunction{Drop}~P$ that consumes a boolean and
continues as $P$ regardless of its value.

\begin{code}%
\>[0]\AgdaFunction{Drop}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{‚àÄ[}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚áí}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{dual}\AgdaSpace{}%
\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚à∑\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚ä¢}}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaFunction{]}\<%
\\
\>[0]\AgdaFunction{Drop}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{If}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Else}}\AgdaSpace{}%
\AgdaBound{P}\<%
\end{code}

Using these higher-order forms, it is easy to define the usual boolean
connectives.

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{!!\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{!!\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{cut}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{If}}\AgdaSpace{}%
\AgdaFunction{False}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Else}}\AgdaSpace{}%
\AgdaFunction{True}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}\&\&\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}||\AgdaUnderscore{}}}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\<%
\\
\>[0]\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\&\&}}\AgdaSpace{}%
\AgdaBound{B}%
\>[9]\AgdaSymbol{=}%
\>[12]\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{cut}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\<%
\\
%
\>[12]\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{cut}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\<%
\\
%
\>[12]\AgdaOperator{\AgdaFunction{If}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{link}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Else}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Drop}\AgdaSpace{}%
\AgdaFunction{False}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{||}}\AgdaSpace{}%
\AgdaBound{B}%
\>[9]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{!!}}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaOperator{\AgdaFunction{!!}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\&\&}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{!!}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{))}\<%
\end{code}

The function \AgdaFunction{\$} (defined in Agda's standard library) is just a
visible function application operator. We use it as a ``separator'' so that we
can flatten deeply nested expressions and save a bunch of parentheses.
%
We have chosen to define the disjunction \AgdaFunction{||} from the conjunction
\AgdaFunction{\&\&} and negation \AgdaFunction{!!} using De Morgan's laws.

If we wish to test our definitions, we can implement a simple evaluator using
the deadlock freedom property. We have not proved a termination result, but
since linear logic enjoys cut elimination we can safely annotate the evaluator
as terminating.

\begin{code}%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{TERMINATING}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{‚àÄ[}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚áí}}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaFunction{]}\<%
\\
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{deadlock-freedom}\AgdaSpace{}%
\AgdaBound{P}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj‚ÇÅ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Q}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}%
\>[24]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{Q}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj‚ÇÇ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Q}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}%
\>[24]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{Q}\<%
\end{code}

Now if we ask Agda to normalise the goal
$\AgdaFunction{eval}~(\AgdaFunction{False}~\AgdaFunction{||}~\AgdaFunction{False})$
we obtain
$\AgdaInductiveConstructor{select}~(\AgdaInductiveConstructor{ch~‚ü®~<~‚Ä¢~‚ü©~inj‚ÇÇ}~(\AgdaInductiveConstructor{close~ch}))$,
that is the definition of \AgdaFunction{False}, as expected.

For the encoding of the polymorphic echo server (\Cref{ex:echo}), we start by
encoding its type $\OfCourse(\forall\X.\dual\X \Par (X \Ten \One))$:

\begin{code}%
\>[0]\AgdaFunction{ServerT}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\\
\>[0]\AgdaFunction{ServerT}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`!}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`‚àÄ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{rav}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\#}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚Öã}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{var}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\#}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚äó}}\AgdaSpace{}%
\AgdaInductiveConstructor{ùüô}\AgdaSymbol{)))}\<%
\end{code}

The notation $\AgdaFunction{\#}~n$ is defined in Agda's standard library and
creates an element of \AgdaDatatype{Fin} from the natural number $n$. Here it is
used to create the de Bruijn index of the type variable $X$.
%
We now encode the server
\begin{code}%
\>[0]\AgdaFunction{Server}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaFunction{ServerT}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\<%
\\
\>[0]\AgdaFunction{Server}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[243I]\AgdaFunction{curry}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{server}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaInductiveConstructor{un-[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\<%
\\
\>[.][@{}l@{}]\<[243I]%
\>[9]\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{all}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\<%
\\
%
\>[9]\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{join}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\<%
\\
%
\>[9]\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{fork}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{link}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{>}}\AgdaSpace{}%
\AgdaInductiveConstructor{‚Ä¢}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\<%
\\
%
\>[9]\AgdaInductiveConstructor{close}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\<%
\end{code}
and the client that sends true to it
\begin{code}%
\>[0]\AgdaFunction{Client}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{dual}\AgdaSpace{}%
\AgdaFunction{ServerT}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚à∑}}\AgdaSpace{}%
\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{‚à∑}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{Client}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[288I]\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{client}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\<%
\\
\>[.][@{}l@{}]\<[288I]%
\>[9]\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ex}\AgdaSpace{}%
\AgdaSymbol{\{\AgdaUnderscore{}\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaFunction{ùîπ}\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\<%
\\
%
\>[9]\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{fork}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaFunction{True}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\<%
\\
%
\>[9]\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{join}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\<%
\\
%
\>[9]\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{wait}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaFunction{‚â´}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\<%
\\
%
\>[9]\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{link}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{>}}\AgdaSpace{}%
\AgdaInductiveConstructor{‚Ä¢}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{ch}\<%
\end{code}

To test our definitions we compose client and server in parallel
\begin{code}%
\>[0]\AgdaFunction{Main}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Proc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaFunction{ùîπ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\<%
\\
\>[0]\AgdaFunction{Main}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{curry‚àó}\AgdaSpace{}%
\AgdaInductiveConstructor{cut}\AgdaSpace{}%
\AgdaFunction{Client}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{<}}\AgdaSpace{}%
\AgdaInductiveConstructor{‚Ä¢}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{Server}\<%
\end{code}
and then ask Agda to normalize \AgdaFunction{Main}, which yields
\AgdaFunction{True} as expected.
