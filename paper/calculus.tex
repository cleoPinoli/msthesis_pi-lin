\section{\Calculus}
\label{sec:calculus}

\subsection{Syntax}
\label{sec:syntax}

\begin{table}
    \caption{Syntax of \Calculus.}\label{tab:syntax}
    \begin{tabular}{c}
        \begin{math}
            \displaystyle
            \begin{array}[t]{rcll}
                P, Q & ::= & \Link\x\y            & \text{link} \\
                    & | & \Fail\x                 & \text{fail} \\
                    & | & \Close\x                & \text{close} \\
                    & | & \Wait\x.P               & \text{wait} \\
                    & | & \Select\x{\InTag_i}\z.P & \text{select} \\
                    & | & \Case\x\z{P}{Q}         & \text{branch} \\
                    & | & \Fork\x\y\z{P}{Q}       & \text{fork} \\
                    & | & \Join\x\y\z.P           & \text{join} \\
                    & | & \Server\x\y.P           & \text{accept} \\
                    & | & \Client\x\y.P           & \text{request} \\
                    & | & \Weaken\x.P             & \text{weaken} \\
                    & | & \Contract\x\y\z.P       & \text{contract} \\
                    & | & \Cut\x{P}{Q}            & \text{cut} \\
            \end{array}
        \end{math}
    \end{tabular}
\end{table}

The calculus of pure sessions that is formalized in our development is dubbed
\Calculus and is a linear version of \CP~\citep{Wadler14,GayVasconcelos25}. Its
syntax makes use of an infinite set of \emph{channel names}, ranged over by $x$,
$y$ and $z$, and is shown in Table~\ref{tab:syntax}.
%
A link $\Link\x\y$ denotes the merging of the $x$ and $y$ channels, so that
every message sent on one of the channels is forwarded to the other. This form
is useful for modeling \emph{free outputs}, as we will see later.\Luca{Mettere
esempio!}
%
The $\Close\x$ and $\Wait\x.P$ processes respectively model the output and input
of a termination signal on the channel $x$. The former process has no
continuation, while the latter process continues as $P$ once the signa has been
received.
%
The $\Fail\x$ process denotes a runtime error concerning the channel $x$.
%
The $\Select\x{\InTag_i}\z.P$ and $\Case\x\z{Q_1}{Q_2}$ processes respectively
denote the output and input of a label $\InTag_i$ along with a fresh
continuation $z$ on the channel $x$. Depending on the label $\InTag_i$, the
receiver continues as $Q_i$. In practice it is useful to consider arbitrary
(domain-specific) sets of tags instead of the canonical two $\InTag_1$ and
$\InTag_2$. This generalization has no substantial impact on the formalization,
so we stick to the classical case of ``binary choices'' in line with the usual
presentations of linear logic.
%
The $\Fork\x\y\z{P}{Q}$ and $\Join\x\y\z.R$ processes respectively denote the
output and input of a pair of fresh channels $y$ and $z$ on the channel $x$. The
former process forks into $P$ and $Q$, each using $y$ and $z$ respectively. The
latter process continues as $R$. These forms are often used in conjunction with
links to model \emph{free outputs}, but can also be used to model bifurcating
sessions whereby a sequential protocol continues as two parallel sub-protocols.

Next we have process forms dealing with shared (non-linear) channels. The
$\Server\x\y.P$ and $\Client\x\y.P$ processes respectively denote \emph{servers}
and \emph{clients} acting on the $x$. Each request (from a client) spawns a copy
of the server's body using the continuation channel $y$. The process
$\Weaken\x.P$ denotes an explicit \emph{weakening}, that is a client that does
\emph{not} use the server waiting on $x$. The process $\Contract\x\y\z.P$
denotes an explicit \emph{contraction}, that is a client that uses the server
$x$ multiple times on the channels $y$ and $z$.

\emph{Cuts} of the form $\Cut\x{P}{Q}$ represent the parallel composition of $P$
and $Q$ connected by a channel $x$.

The notions of free and bound names are fairly standard. Just bear in mind that
all action prefixes bind continuation channels in (some) continuation processes.
In particular, $\Select\x{\Tag_i}\z.P$ binds $z$ in $P$, $\Case\x\z{P}{Q}$ binds
$z$ in both $P$ and $Q$, $\Fork\x\y\z{P}{Q}$ binds $y$ in $P$ but not in $Q$ and
$z$ in $Q$ but not in $P$, and $\Join\x\y\z.P$ binds both $y$ and $z$ in $P$.
%
Also, $\Server\x\y.P$ and $\Client\x\y.P$ bind $y$ in $P$ and
$\Contract\x\y\z.P$ binds $y$ and $z$ in $P$.
%
We write $\fn{P}$ for the set of channel names occurring free in $P$ and we
identify processes up to renaming of bound names.

\subsection{Operational Semantics}
\label{sec:semantics}

\begin{table}
    \caption{Operational semantics of \Calculus.}
    \label{tab:semantics}
    \begin{tabular}{@{}c@{}}
        \begin{math}
            \displaystyle
            \begin{array}{rrcll}
            \SLink &
            \Link\x\y & \pcong & \Link\y\x \\
            \SComm &
            \Cut\x{P}{Q} & \pcong & \Cut\x{Q}{P} \\
            \SFail &
            \Cut\x{\Fail\y}{P} & \pcong & \Fail\y & x \ne y \\
            \SWait &
            \Cut\x{\Wait\y.P}{Q} & \pcong & \Wait\y.\Cut\x{P}{Q} & x \ne y \\
            \SSelect &
            \Cut\x{\Select\y{\InTag_i}\z.P}{Q} & \pcong & \Select\y{\InTag_i}\z.\Cut\x{P}{Q} & x \ne y,z \\
            \SCase &
            \Cut\x{\Case\y\z{P}{Q}}{R} & \pcong & \Case\y\z{\Cut\x{P}{R}}{\Cut\x{Q}{R}} & x \ne y,z \\
            \SForkL &
            \Cut\x{\Fork\y\u\v{P}{Q}}{R} & \pcong & \Fork\y\u\v{\Cut\x{P}{R}}{Q} & x \in \fn{P}\setminus\set{y,u,v} \\
            \SForkR &
            \Cut\x{\Fork\y\u\v{P}{Q}}{R} & \pcong & \Fork\y\u\v{P}{\Cut\x{Q}{R}} & x \in \fn{Q}\setminus\set{y,u,v} \\
            \SJoin &
            \Cut\x{\Join\y\u\v.P}{Q} & \pcong & \Join\y\u\v.\Cut\x{P}{Q} & x \ne y,u,v \\
            \SClient &
            \Cut\x{\Client\y\z.P}{Q} & \pcong & \Client\y\z.\Cut\x{P}{Q} & x \ne y,z \\
            \SWeaken &
            \Cut\x{\Weaken\y.P}{Q} & \pcong & \Weaken\y.\Cut\x{P}{Q} & x \ne y \\
            \SContract &
            \Cut\x{\Contract\y\u\v.P}{Q} & \pcong & \Contract\y\u\v.\Cut\x{P}{Q} & x \ne y,u,v \\
            \SServer &
            \Cut\x{\Server\y\u.P}{\Server\x\v.Q} & \pcong & \Server\y\u.\Cut\x{P}{\Server\x\v.Q} & x \ne y,u \\
            \\
            \RLink &
            \Cut\x{\Link\x\y}{P} & \red & P\subst\y\x \\
            \RClose &
            \Cut\x{\Close\x}{\Wait\x.P} & \red & P \\
            \RSelect &
            \Cut\x{\Select\x{\Tag_i}\z.P}{\Case\x\z{Q_1}{Q_2}} & \red & \Cut\z{P}{Q_i} & i\in\set{1,2} \\
            \RFork &
            \Cut\x{\Fork\x\y\z{P}{Q}}{\Join\x\y\z.R} & \red & \Cut\y{P}{\Cut\z{Q}{R}} \\
            \RConnect &
            \Cut\x{\Server\x\y.P}{\Client\x\y.Q} & \red & \Cut\y{P}{Q} \\
            \RWeaken &
            \Cut\x{\Server\x\y.P}{\Weaken\x.Q} & \red & \Weaken{\seqof\z}.Q
            & \fn{P} = \set{y,\seqof\z} \\
            \RContract &
            \Cut\x{\Server\x\y.P}{\Contract\x{x'}{x''}.Q} & \red &
            \multicolumn{2}{l}{
                \Contract{\seqof\z}{\seqof\z'}{\seqof\z''}.\Cut{x'}{
                    \Server{x'}\y.P'
                }{
                    \Cut{x''}{
                        \Server{x''}\y.P''
                    }{
                        Q
                    }
                }
                ~^*
            }
            \\
            \RCut &
            \Cut\x{P}{R} & \red & \Cut\x{Q}{R} & P \red Q \\
            \RCong &
            P & \red & Q & P \pcong R \red Q \\
            \\
            \multicolumn{5}{c}{
                ~^*
                \fn{P} = \set{y,\seqof\z},
                P' = P\subst{\seqof\z'}{\seqof\z},
                P'' = P\subst{\seqof\z''}{\seqof\z}
            }
            \end{array}
        \end{math}
    \end{tabular}
\end{table}

The operational semantics of \Calculus is shown in Table~\ref{tab:semantics} and
is given by two relations: a \emph{structural pre-congruence} relation $\pcong$
and a \emph{reduction} relation $\red$. Structural pre-congruence relates
processes that we consider to be essentially indistinguishable. Reduction
relates processes in which a communication occurs. In some presentations of
linear logic~\cite{Doumane}, these relations are respectively dubbed
\emph{external} and \emph{internal} reductions. Let us describe the two
relations more in detail.

Structural pre-congruence is the least pre-congruence defined by rule
\rulename{s-*} rules.
%
\SLink and \SComm assert that links and parallel compositions are symmetric. The
remaining rules, when read from left to right, push a cut on $x$ underneath the
topmost prefix on $y$ of one of its sub-processes when $x \ne y$. These rules
are key to float input/output actions to the top-level of a process, so that
they can interact with corresponding complementary actions in the context
surrounding the process.
%
Note that some rules have additional side-conditions preventing bound names to
become free.\Luca{Non proprio, sono tutti nomi bound.} Also, there are two
versions of \SForkL and \SForkR depending on which of the two continuations $P$
and $Q$ contains occurrences of the restricted channel $x$.
%
Notably and somewhat surprisingly, there is no pre-congruence rule asserting
that parallel composition is associative. While this is a sound and expected
property of parallel composition, it turns out to be inessential for proving all
of the properties of \Calculus that we consider. We leave it out in light of the
forthcoming formalization of the calculus, in which every simplification is
welcome, although standard presentations of classical linear logic admit such
reduction~\cite{Doumane17}.

The reduction rules \RLink, \RClose, \RSelect and \RFork are in one-to-one
correspondence with the well-known reductions of session calculi and the cut
reductions of linear logic. \RLink eliminates a link $\Link\x\y$ by unifying $x$
and $y$. \RClose closes a session $x$ when a termination signal is exchanged on
$x$. \RSelect and \RFork respectively model the communication of a tag $\Tag_i$
and of a fresh channel $y$. Since channels are linear in \Calculus, each
non-terminating communication carries along a \emph{fresh continuation} $z$ on
which the rest of the conversation may take place, in line with the semantics of
the linear $\pi$-calculus~\cite{KobayashiPierceTurner99}.
%
The rule~\RCut propagates reductions through cuts and the rules \RCong closes
reduction by structural pre-congruence.

\subsection{Type System}

The types for \Calculus, ranged over by $A$, $B$, \dots, are propositions of
\MALL generated by the following grammar:
\[
    A, B ::= \Zero \mid \Top \mid \One \mid \Bot \mid A \Plus B \mid A \With B \mid A \Ten B \mid A \Par B
\]

The interpretation of propositions as session types is the usual
one~\cite{Wadler14}: the constants $\Bot$ and $\One$ describe the behavior of a
process sending/receiving a termination signal; the additive connectives $A
\Plus B$ and $\A \With B$ describe the behavior of a process sending/receiving a
boolean value and then adhering to either $A$ and $B$ accordingly; the
multiplicative connectives $A \Ten B$ and $A \Par B$ describe the behavior of a
process sending/receiving a channel (to be used according to $A$) and then
continuing as described by $B$. The additive constants $\Zero$ and $\Top$ do not
describe useful protocols, but they can serve the role of smallest/largest type
in type systems that support a notion of subtyping~\citep{HornePadovani24}.

The notion of \emph{duality} is standard and we write $\dual{A}$ for the dual of
$A$.

context syntax and notation
