\section{\Calculus}
\label{sec:calculus}

\subsection{Syntax}
\label{sec:syntax}

\begin{table}
    \caption{Syntax of \Calculus.}
    \label{tab:syntax}
    \begin{math}
        \displaystyle
        \begin{array}[t]{rcll}
            P, Q & ::= & \Link\x\y \\
                & | & \Fail\x \\
                & | & \Close\x \\
                & | & \Wait\x.P \\
                & | & \Select\x{\InTag_i}\z.P \\
                & | & \Case\x\z{P}{Q} \\
                & | & \Fork\x\y\z{P}{Q} \\
                & | & \Join\x\y\z.P \\
                & | & \Cut\x{P}{Q} \\
        \end{array}
    \end{math}
\end{table}

The calculus of pure sessions that is formalized in our development is closely
related to the multiplicative, additive fragment of CP~\citep{Wadler14}, without
shared channels. Its syntax makes use of an infinite set of \emph{channel
names}, ranged over by $x$, $y$ and $z$, and is shown in \cref{tab:syntax}.
%
A link $\Link\x\y$ denotes the merging of the $x$ and $y$ channels, so that
every message sent on one of the channels is forwarded to the other. This form
is useful for modeling \emph{free outputs}, as we will see later.\Luca{Mettere
esempio!}
%
The $\Close\x$ and $\Wait\x.P$ processes respectively model the output and input
of a termination signal on the channel $x$. The former process has no
continuation, while the latter process continues as $P$ once the session has
been terminated.
%
The $\Fail\x$ process denotes a runtime error concerning the session $x$.
%
The $\Select\x{\InTag_i}\z.P$ and $\Case\x\z{Q_1}{Q_2}$ processes respectively
denote the output and input of a label $\InTag_i$ along with a fresh
continuation $z$ on the channel $x$. Depending on the label $\InTag_i$, the
receiver continues as $Q_i$. In practice it is useful to consider arbitrary
(domain-specific) sets of tags instead of the canonical two $\InTag_1$ and
$\InTag_2$. This generalization has no substantial impact on the formalization,
so we stick to the classical case of ``binary choices'' in line with the usual
presentations of linear logic.
%
The $\Fork\x\y\z{P}{Q}$ and $\Join\x\y\z.R$ processes respectively denote the
output and input of a pair of fresh channels $y$ and $z$ on the channel $x$.
These forms are often used in conjunction with links to model \emph{free
outputs}, but can also be used to model bifurcating sessions whereby a
sequential protocol continues as two parallel sub-protocols.

The notions of free and bound names are fairly standard. Just bear in mind that
all action prefixes bind continuation channels in (some) continuation processes.
In particular, $\Select\x{\Tag_i}\z.P$ binds $z$ in $P$, $\Case\x\z{P}{Q}$ binds
$z$ in both $P$ and $Q$, $\Fork\x\y\z{P}{Q}$ binds $y$ in $P$ but not in $Q$ and
$z$ in $Q$ but not in $P$, and $\Join\x\y\z.P$ binds both $y$ and $z$ in $P$.
%
We write $\fn{P}$ for the set of channel names occurring free in $P$ and we
identify processes up to renaming of bound names.

\subsection{Operational Semantics}
\label{sec:semantics}

\begin{table}
    \caption{Operational semantics of \Calculus.}
    \label{tab:semantics}
    \[
        \begin{array}{rrcll}
        \SLink &
        \Link\x\y & \pcong & \Link\y\x \\
        \SComm &
        \Cut\x{P}{Q} & \pcong & \Cut\x{Q}{P} \\
        \SFail &
        \Cut\x{\Fail\y}{P} & \pcong & \Fail\y & x \ne y \\
        \SWait &
        \Cut\x{\Wait\y.P}{Q} & \pcong & \Wait\y.\Cut\x{P}{Q} & x \ne y \\
        \SSelect &
        \Cut\x{\Select\y{\InTag_i}\z.P}{Q} & \pcong & \Select\y{\InTag_i}\z.\Cut\x{P}{Q} & x \ne y,z \\
        \SCase &
        \Cut\x{\Case\y\z{P}{Q}}{R} & \pcong & \Case\y\z{\Cut\x{P}{R}}{\Cut\x{Q}{R}} & x \ne y,z \\
        \SForkL &
        \Cut\x{\Fork\y\u\v{P}{Q}}{R} & \pcong & \Fork\y\u\v{\Cut\x{P}{R}}{Q} & x \in \fn{P}\setminus\set{y,u,v} \\
        \SForkR &
        \Cut\x{\Fork\y\u\v{P}{Q}}{R} & \pcong & \Fork\y\u\v{P}{\Cut\x{Q}{R}} & x \in \fn{Q}\setminus\set{y,u,v} \\
        \SJoin &
        \Cut\x{\Join\y\u\v.P}{Q} & \pcong & \Join\y\u\v.\Cut\x{P}{Q} & x \ne y,u,v \\
        \\
        \RLink &
        \Cut\x{\Link\x\y}{P} & \red & P\subst\y\x \\
        % \RFail &
        % \Cut\x{\Fail\y}{P} & \red & \Fail\y & x \ne y \\
        \RClose &
        \Cut\x{\Close\x}{\Wait\x.P} & \red & P \\
        \RSelect &
        \Cut\x{\Select\x{\Tag_i}\z.P}{\Case\x\z{Q_1}{Q_2}} & \red & \Cut\z{P}{Q_i} & i\in\set{1,2} \\
        \RFork &
        \Cut\x{\Fork\x\y\z{P}{Q}}{\Join\x\y\z.R} & \red & \Cut\y{P}{\Cut\z{Q}{R}} \\
        \RCut &
        \Cut\x{P}{R} & \red & \Cut\x{Q}{R} & P \red Q \\
        \RCong &
        P & \red & Q & P \pcong R \red Q \\
        \end{array}
    \]
\end{table}

The operational semantics of \Calculus is shown in \cref{tab:semantics} and is
given by two relations: a \emph{structural pre-congruence} relation $\pcong$ and
a \emph{reduction} relation $\red$. Structural pre-congruence relates processes
that we consider to be essentially indistinguishable. Reduction relates
processes in which a communication occurs. In some presentations of linear
logic~\cite{Doumane}, these relations are respectively dubbed \emph{external}
and \emph{internal} reductions. Let us describe the two relations more in
detail.

Structural pre-congruence is the least pre-congruence defined by rule
\rulename{s-*} rules.
%
\SLink and \SComm assert that links and parallel compositions are symmetric. The
remaining rules, when read from left to right, push a cut on $x$ underneath the
topmost prefix on $y$ of one of its sub-processes when $x \ne y$. These rules
are key to float input/output actions to the top-level of a process, so that
they can interact with corresponding complementary actions in the context
surrounding the process.
%
Note that some rules have additional side-conditions preventing bound names to
become free.\Luca{Non proprio, sono tutti nomi bound.} Also, there are two
versions of \SForkL and \SForkR depending on which of the two continuations $P$
and $Q$ contains occurrences of the restricted channel $x$.
%
Notably and somewhat surprisingly, there is no pre-congruence rule asserting
that parallel composition is associative. While this is a sound and expected
property of parallel composition, it turns out to be inessential for proving all
of the properties of \Calculus that we consider. We leave it out in light of the
forthcoming formalization of the calculus, in which every simplification is
welcome, although standard presentations of classical linear logic admit such
reduction~\cite{Doumane17}.

The reduction rules \RLink, \RClose, \RSelect and \RFork are in one-to-one
correspondence with the well-known reductions of session calculi and the cut
reductions of linear logic. \RLink eliminates a link $\Link\x\y$ by unifying $x$
and $y$. \RClose closes a session $x$ when a termination signal is exchanged on
$x$. \RSelect and \RFork respectively model the communication of a tag $\Tag_i$
and of a fresh channel $y$. Since channels are linear in \Calculus, each
non-terminating communication carries along a \emph{fresh continuation} $z$ on
which the rest of the conversation may take place, in line with the semantics of
the linear $\pi$-calculus~\cite{KobayashiPierceTurner99}.
%
The rule~\RCut propagates reductions through cuts and the rules \RCong closes
reduction by structural pre-congruence.

\subsection{Type System}

Types, ranged over by $A$, $B$, \dots, are propositions of multiplicative,
additive linear logic:
\[
    A, B ::= \Zero \mid \Top \mid \One \mid \Bot \mid A \Plus B \mid A \With B \mid A \Ten B \mid A \Par B
\]

context syntax and notation

\begin{table}
    \caption{Operational semantics of \Calculus.}
    \label{tab:semantics}
    \begin{mathpar}
        \inferrule[\LinkRule]{~}{
            \wtp{
                \Link\x\y
            }{
                x : A, y : \dual{A}
            }
        }
        \and
        \inferrule[\FailRule]{~}{
            \wtp{
                \Fail\x
            }{
                \Context, x : \Top
            }
        }
        \and
        \inferrule[\CloseRule]{~}{
            \wtp{
                \Close\x
            }{
                x : \One
            }
        }
        \and
        \inferrule[\WaitRule]{
            \wtp{
                P
            }{
                \Context
            }
        }{
            \wtp{
                \Wait\x.P
            }{
                \Context, x : \Bot
            }
        }
        \and
        \inferrule[\SelectRule]{
            \wtp{
                P
            }{
                \Context, y : A_i
            }
        }{
            \wtp{
                \Select\x{\Tag_i}\y.P
            }{
                \Context, x : A_1 \Plus A_2
            }
        }
        \and
        \inferrule[\CaseRule]{
            \wtp{
                P
            }{
                \Context, y : A
            }
            \\
            \wtp{
                Q
            }{
                \Context, y : B
            }
        }{
            \wtp{
                \Case\x\y{P}{Q}
            }{
                \Context, x : A \With B
            }
        }
        \and
        \inferrule[\ForkRule]{
            \wtp{
                P
            }{
                \ContextC, y : A
            }
            \\
            \wtp{
                Q
            }{
                \ContextD, z : B
            }
        }{
            \wtp{
                \Join\x\y\z{P}{Q}
            }{
                \ContextC, \ContextD, x : A \Ten B
            }
        }
        \and
        \inferrule[\JoinRule]{
            \wtp{
                P
            }{
                \Context, y : A, z : B
            }
        }{
            \wtp{
                \Join\x\y\z.P
            }{
                \Context, x : A \Par B
            }
        }
        \and
        \inferrule[\CutRule]{
            \wtp{
                P
            }{
                \ContextC, x : A
            }
            \\
            \wtp{
                Q
            }{
                \ContextD, x : \dual{A}
            }
        }{
            \wtp{
                \Cut\x{P}{Q}
            }{
                \ContextC, \ContextD
            }
        }
    \end{mathpar}
\end{table}