\section{Linear \CP}
\label{sec:calculus}

In this section we give a cursory presentation of \LCP.
%
As we have anticipated in \Cref{sec:introduction}, \LCP is closely related to
\CP~\citep{Wadler14,GayVasconcelos25} except that \LCP features linear channels
instead of sessions. A session consisting of several exchanged messages is
encoded using linear channels by pairing each message with a fresh continuation
channel on which the rest of the session takes place.
%
This way of encoding sessions has been first described by \citet[extended
version]{Kobayashi02b} and later studied by \citet{DardhaGiachinoSangiorgi17}.

We present \LCP starting from its types (\Cref{sec:types}), which coincide with
classical linear logic propositions, then moving on to the syntax of processes
(\Cref{sec:syntax}), their reduction semantics (\Cref{sec:semantics}), the
typing rules (\Cref{sec:typing-rules}) and the formulation of the properties
ensured by the type system (\Cref{sec:properties}).

\subsection{Types}
\label{sec:types}

The types of \Calculus, ranged over by $A$, $B$, \dots, are the linear logic
propositions generated by the grammar
\[
    A, B ::= X \mid \dual{X} \mid \Top \mid \Zero \mid \Bot \mid \One \mid A \With B \mid A \Plus B \mid A \Par B \mid A \Ten B \mid \forall X.A \mid \exists X.A \mid \OfCourse A \mid \WhyNot A
\]
where $X$, $Y$, \dots range over an infinite set of \emph{type (or proposition)
variables}.

The interpretation of linear logic propositions as protocols is fairly
usual~\cite{Wadler14}: the multiplicative constants $\Bot$ and $\One$ describe
protocols that terminate with the input/output of a signal; the additive
connectives $A \With B$ and $\A \Plus B$ describe protocols having two possible
continuations of type $A$ and $B$ which are selected/offered; the multiplicative
connectives $A \Par B$ and $A \Ten B$ describe bifurcating protocols with two
continuations of type $A$ and $B$. The additive constants $\Zero$ and $\Top$ do
not describe useful protocols, but they can play the role of smallest/largest
type in type systems that support a notion of subtyping~\citep{HornePadovani24}. 
%
The quantifiers $\forall X.A$ and $\exists X.A$ describe the input/output of a
type $X$ with a continuation $A$ and are useful to describe parametric protocol
polymorphism.
%
Finally, the ``of course'' modality $\OfCourse A$ and the ``why not'' modality
$\WhyNot A$ describe shared channels on which servers and clients accept and
request connections of type $A$.

The notions of \emph{free type variables}, of \emph{duality} and of \emph{type
substitution} are standard~\cite{Wadler14}. In particular, we write $\fv{A}$ for
the set of type variables occurring free in $A$, we write $\dual{A}$ for the
dual of $A$ and $A\subst{B}X$ for the type obtained by replacing the free
occurrences of $X$ in $A$ with $B$.

\subsection{Processes}
\label{sec:syntax}

\begin{table}[t]
    \caption{Syntax of \Calculus.}\label{tab:syntax}
    \begin{tabular}{c}
        \begin{math}
            \displaystyle
            \begin{array}[t]{rcll}
                P, Q & ::= & \Link\x\y            & \text{link} \\
                    & | & \Fail\x                 & \text{fail} \\
                    & | & \Wait\x.P               & \text{wait} \\
                    & | & \Close\x                & \text{close} \\
                    & | & \Case\x\z{P}{Q}         & \text{case} \\
                    & | & \Select\x{\InTag_i}\z.P & \text{left/right selection} \\
                    & | & \Join\x\y\z.P           & \text{join} \\
                    & | & \Fork\x\y\z{P}{Q}       & \text{fork} \\
                    & | & \Forall\x\X\z.P         & \text{for all} \\
                    & | & \Exists\x{A}\z.P        & \text{exists} \\
                    & | & \Server\x\y.P           & \text{server} \\
                    & | & \Client\x\y.P           & \text{client} \\
                    & | & \Weaken\x.P             & \text{weakening} \\
                    & | & \Contract\x\y\z.P       & \text{contraction} \\
                    & | & \Cut[A]\x{P}{Q}         & \text{cut} \\
            \end{array}
        \end{math}
    \end{tabular}
\end{table}

The syntax of processes makes use of an infinite set of \emph{channels}, ranged
over by $x$, $y$ and $z$, and is shown in~\Cref{tab:syntax}.
%
A link $\Link\x\y$ denotes the merging of the channels $x$ and $y$, so that
every message sent on one of the channels is forwarded to the other. As
discussed in the literature~\cite{LindleyMorris15}, this form is useful for
modeling higher-order sessions, that is the exchange of an existing channel on
another channel.
%
The processes $\Wait\x.P$ and $\Close\x$ respectively model the input and output
of a termination signal on the channel $x$. The latter process has no
continuation, while the former process continues as $P$ once the signal has been
received.
%
The process $\Fail\x$ can be used to denote a failure concerning the channel
$x$.
%
The processes $\Case\x\z{Q_1}{Q_2}$ and $\Select\x{\InTag_i}\z.P$ for $i=1,2$
describe the input/output of a label $\InTag_i$ along with a fresh continuation
$z$ on the channel $x$. The receiver continues as $Q_i$ depending on the
received label $\InTag_i$. In practice it is useful to consider arbitrary
(domain-specific) sets of labels instead of the canonical $\InTag_1$ and
$\InTag_2$. This generalisation has no substantial impact on the formalisation,
so we stick to binary choices in line with the usual presentations of linear
logic.
%
The processes $\Join\x\y\z.R$ and $\Fork\x\y\z{P}{Q}$ describe the input/output
of a pair of fresh channels $y$ and $z$ on the channel $x$. The former process
has a single continuation $R$ that can use both $y$ and $z$. The latter process
forks into $P$ and $Q$, each using $y$ and $z$ respectively. These forms are
often used in conjunction with links to model higher-order sessions.
%
The processes $\Forall\x\X\z.P$ and $\Exists\x{A}\z.P$ describe the input/output
of a type on the channel $x$ along with a fresh continuation $z$.

Next we have process forms dealing with shared (non-linear) channels. The
$\Server\x\y.P$ and $\Client\x\y.P$ processes respectively denote \emph{servers}
and \emph{clients} acting on the shared channel $x$. Each request (from a
client) spawns a copy of the server's body using the continuation channel $y$.
The process $\Weaken\x.P$ denotes an explicit \emph{weakening}, that is a client
that \emph{does not} use $x$. The process $\Contract\x\y\z.P$ denotes an
explicit \emph{contraction} whereby a client uses $x$ multiple times (once with
name $y$ and once with name $z$).

Finally, cuts of the form $\Cut[A]\x{P}{Q}$ represent the parallel composition
of the processes $P$ and $Q$ connected by a channel $x$, which has type $A$ in
$P$ and type $\dual{A}$ in $Q$. Henceforth we write $\Cut\x{P}{Q}$ omitting the
type annotation $A$ when it is irrelevant or clear from the context.

The notions of free and bound channels are fairly standard, bearing in mind that
output prefixes bind continuation channels in (some) continuation processes. In
particular, $\Select\x{\InTag_i}\z.P$ binds $z$ in $P$, while
$\Fork\x\y\z{P}{Q}$ binds $y$ in $P$ but not in $Q$ and $z$ in $Q$ but not in
$P$.
%
We write $\fn{P}$ for the set of channels occurring free in $P$ and we identify
processes up to renaming of bound channels.

\begin{example}
    \label{ex:booleans}
    We can represent the type of a boolean value being produced as the
    proposition $\Bool \eqdef \One \Plus \One$ and that of a boolean value being
    consumed as its dual $\dual\Bool = \Bot \With \Bot$. Following these types,
    the boolean constants can be modeled by the processes
    \[
        \TrueP(x) \eqdef \Select\x\LeftTag{x'}.\Close{x'}
        \qquad
        \FalseP(x) \eqdef \Select\x\RightTag{x'}.\Close{x'}
    \]
    and the boolean negation function by the process
    \[
        \NotP(x,y) \eqdef
        \BigCase\x{x'}{
            \Wait{x'}.\FalseP(y)
        }{
            \Wait{x'}.\TrueP(y)
        }
    \]

    As an example, the composition $\Cut[\Bool]\x{\TrueP(x)}{\NotP(x,y)}$
    produces false on $y$.
    %
    Note the use of explicit continuations in these processes and the fact that
    each channel is used exactly once. The same processes in \CP would be
    written as
    \[
        \TrueP(x) \eqdef \Select\x\LeftTag{}.\Close\x
        \quad
        \FalseP(x) \eqdef \Select\x\RightTag{}.\Close\x
        \quad
        \NotP(x,y) \eqdef
        \BigCase\x{}{
            \Wait\x.\FalseP(y)
        }{
            \Wait\x.\TrueP(y)
        }
    \]
    where each channel is used multiple times to indicate the various
    input/output actions pertaining to the same session.
    %
    In general, the \CP version of an \LCP process can be obtained by reusing
    the same channel $x$ in place of the continuation $z$ in \Cref{tab:syntax}.
    %
    \eoe
\end{example}

\subsection{Operational Semantics}
\label{sec:semantics}

\begin{table}[t]
    \caption{Operational semantics of \Calculus. Many side conditions for the
    \rulename{s-*} rules are omitted (see text).}
    \label{tab:semantics}
    \begin{tabular}{@{}c@{}}
        \begin{math}
            \displaystyle
            \begin{array}{rrcll}
            \SLink &
            \Link\x\y & \pcong & \Link\y\x
            \\
            \SComm &
            \Cut\x{P}{Q} & \pcong & \Cut\x{Q}{P}
            \\
            \SFail &
            \Cut\x{\Fail\y}{P} & \pcong & \Fail\y % & x \ne y
            \\
            \SWait &
            \Cut\x{\Wait\y.P}{Q} & \pcong & \Wait\y.\Cut\x{P}{Q} % & x \ne y
            \\
            \SCase &
            \Cut\x{\Case\y\z{P}{Q}}{R} & \pcong & \Case\y\z{\Cut\x{P}{R}}{\Cut\x{Q}{R}} % & x \ne y,z
            \\
            \SSelect &
            \Cut\x{\Select\y{\InTag_i}\z.P}{Q} & \pcong & \Select\y{\InTag_i}\z.\Cut\x{P}{Q} % & x \ne y,z
            \\
            \SJoin &
            \Cut\x{\Join\y\u\z.P}{Q} & \pcong & \Join\y\u\z.\Cut\x{P}{Q} % & x \ne y,u,v
            \\
            \SForkL &
            \Cut\x{\Fork\y\u\z{P}{Q}}{R} & \pcong & \Fork\y\u\z{\Cut\x{P}{R}}{Q} & x \in \fn{P}
            \\
            \SForkR &
            \Cut\x{\Fork\y\u\z{P}{Q}}{R} & \pcong & \Fork\y\u\z{P}{\Cut\x{Q}{R}} & x \in \fn{Q} %\setminus\set{y,u,v}
            \\
            \SForall &
            \Cut\x{\Forall\y\X\z.P}{Q} & \pcong & \Forall\y\X\z.\Cut\x{P}{Q} % & x \ne y,z
            \\
            \SExists &
            \Cut\x{\Exists\y{A}\z.P}{Q} & \pcong & \Exists\y{A}\z.\Cut\x{P}{Q} % & x \ne y,z
            \\
            \SServer &
            \Cut\x{\Server\y\u.P}{\Server\x\v.Q} & \pcong & \Server\y\u.\Cut\x{P}{\Server\x\v.Q} % & x \ne y,u
            \\
            \SClient &
            \Cut\x{\Client\y\z.P}{Q} & \pcong & \Client\y\z.\Cut\x{P}{Q} % & x \ne y,z
            \\
            \SWeaken &
            \Cut\x{\Weaken\y.P}{Q} & \pcong & \Weaken\y.\Cut\x{P}{Q} % & x \ne y
            \\
            \SContract &
            \Cut\x{\Contract\y\u\v.P}{Q} & \pcong & \Contract\y\u\v.\Cut\x{P}{Q} % & x \ne y,u,v
            \\
            \\
            \RLink &
            \Cut\x{\Link\x\y}{P} & \red & P\subst\y\x \\
            \RClose &
            \Cut\x{\Close\x}{\Wait\x.P} & \red & P \\
            \RSelect &
            \Cut\x{\Select\x{\InTag_i}\z.P}{\Case\x\z{Q_1}{Q_2}} & \red & \Cut\z{P}{Q_i} & i\in\set{1,2} \\
            \RFork &
            \Cut\x{\Fork\x\y\z{P}{Q}}{\Join\x\y\z.R} & \red & \Cut\y{P}{\Cut\z{Q}{R}} \\
            \RExists &
            \Cut\x{\Exists\x{A}\z.P}{\Forall\x\X\z.Q} & \red &
            \Cut\z{P}{Q\subst{A}\X} \\
            \RConnect &
            \Cut\x{\Server\x\y.P}{\Client\x\y.Q} & \red & \Cut\y{P}{Q} \\
            \RWeaken &
            \Cut\x{\Server\x\y.P}{\Weaken\x.Q} & \red & \Weaken{\seqof\z}.Q
            & \fn{P} = \set{y,\seqof\z} \\
            \RContract &
            \Cut\x{\Server\x\y.P}{\Contract\x{x'}{x''}.Q} & \red &
            \multicolumn{2}{l}{
                \Contract{\seqof\z}{\seqof\z'}{\seqof\z''}.\Cut{x'}{
                    \Server{x'}\y.P'
                }{
                    \Cut{x''}{
                        \Server{x''}\y.P''
                    }{
                        Q
                    }
                }
                ~^*
            }
            \\
            \RCut &
            \Cut\x{P}{R} & \red & \Cut\x{Q}{R} & P \red Q \\
            \RCong &
            P & \red & Q & P \pcong R \red Q \\
            \\
            \multicolumn{5}{c}{
                ~^*
                \fn{P} = \set{y,\seqof\z},
                P' = P\subst{\seqof\z'}{\seqof\z},
                P'' = P\subst{\seqof\z''}{\seqof\z}
            }
            \end{array}
        \end{math}
    \end{tabular}
\end{table}

The operational semantics of \Calculus is shown in~\Cref{tab:semantics} and
is given by two relations: a \emph{structural pre-congruence} relation $\pcong$
and a \emph{reduction} relation $\red$. Structural pre-congruence relates
processes that we consider to be essentially indistinguishable. Reduction
relates processes in which a communication occurs. In some presentations of
linear logic~\cite{BaeldeDoumaneSaurin16,Doumane17}, these relations are
respectively dubbed \emph{external} and \emph{internal} reductions. Let us
describe the two relations more in detail.

Structural pre-congruence is the least pre-congruence defined by the
\rulename{s-*} rules.
%
\SLink and \SComm assert that links and parallel compositions are commutative.
The remaining rules, when read from left to right, push a cut on $x$ underneath
the topmost prefix on $y$ of one of its sub-processes when $x \ne y$. These
rules are key to float input/output actions to the top-level of a process, so
that they can interact with corresponding complementary actions in the context
surrounding the process.
%
All these rules have implicit side-conditions (not shown in
\Cref{tab:semantics}) aimed at preserving the meaning of channels when binders
are moved around: terms entering or exiting the scope of a binder for $x$ must
not have free occurrences of $x$. This holds also for the type variable $X$ in
the rule \SForall.
%
We content ourselves with such informal description of these side conditions
given that we are going to formalise \Calculus later on.
%
Note also that there are two versions of \SForkL and \SForkR depending on which
of the two continuations (either $P$ or $Q$) contains free occurrences of the
restricted channel $x$.

There is no pre-congruence rule asserting that parallel composition is
associative. While this is a sound property of parallel composition, it turns
out to be unnecessary for proving the properties of \LCP that we consider. We
leave it out in light of the forthcoming formalisation of the calculus, in which
every simplification is welcome, although standard presentations of classical
linear logic admit such law~\cite{Wadler14}.
%
Another rule that deserves attention is \SServer. In this case, a server prefix
$\Server\y\u$ can be pulled out of a cut only provided that the other process in
the cut is also a server on the channel restricted by the cut.

Reduction is defined by the \rulename{r-*} rules.
%
The reduction rules \RLink, \RClose, \RSelect, \RFork, \RExists, \RConnect,
\RWeaken and \RContract are in one-to-one correspondence with the well-known
reductions of session calculi and the principal cut reductions of linear logic.
\RLink eliminates a link $\Link\x\y$ by substituting $y$ for $x$. \RClose closes
a session $x$ when a termination signal is exchanged on $x$. \RSelect and \RFork
respectively model the communication of a tag $\InTag_i$ and of a fresh channel
$y$. \RExists models the instantiation of a polymorphic variable $X$ as the
communication of a type $A$. We write $Q\subst{A}\X$ for the process obtained by
replacing every free occurrence of the type variable $X$ with $A$. Each of these
communications consumes the channel $x$ and possibly creates and transfers a
\emph{fresh continuation} $z$ on which the rest of the conversation takes place,
in line with the encoding of sessions into the linear
$\pi$-calculus~\cite{KobayashiPierceTurner99,Kobayashi02b,DardhaGiachinoSangiorgi17}.
%
The rules \RConnect, \RWeaken and \RContract describe interactions on shared
channels and respectively represent the connection between a server and a
client, the disposal of an unused server, and the duplication of a server. In
\RWeaken and \RContract we use some convenient (albeit slightly informal)
notation for denoting sequences of (pairwise distinct) channels and prefixes. In
particular, $\seqof\z$ stands for a sequence $z_1, \dots, z_n$ of channels,
$\Weaken{\seqof\z}.Q$ stands for $\Weaken{z_1}\dots\Weaken{z_n}.Q$ and
$\Contract{\seqof\z}{\seqof\z'}{\seqof\z''}.R$ stands for
$\Contract{z_1}{z_1'}{z_1''}\dots\Contract{z_n}{z_n'}{z_n''}.R$.

The rule~\RCut propagates reductions through cuts and the rule \RCong enables
reduction up to structural pre-congruence.

\subsection{Type System}
\label{sec:typing-rules}

We use typing contexts (\ie sequents) to keep track of the type of channels.
Typing contexts are finite maps from channels to types written as $x_1 : A_1,
\dots, x_n : A_n$ and ranged over by $\ContextC$ and $\ContextD$. We write
$\ContextC, \ContextD$ for the union of $\ContextC$ and $\ContextD$ when they
have disjoint domains. We write $\WhyNot\Context$ for some context $\Context =
x_1 : \WhyNot A_1, \dots, x_n : \WhyNot A_n$ where all the types in its range
are prefixed by the $\WhyNot$ modality. We call these types \emph{unrestricted},
since they are used to denote shared channels that can be (explicitly) discarded
and duplicated at will.

\begin{table}[t]
    \caption{Typing rules of \Calculus.}
    \label{tab:typing-rules}
    \begin{tabular}{@{}c@{}}
        \begin{mathpar}
            \inferrule[\LinkRule]{~}{
                \wtp{\Link\x\y}{x : A, y : \dual{A}}
            }
            \and
            \inferrule[\FailRule]{~}{
                \wtp{\Fail\x}{x : \Top, \Context}
            }
            \and
            \inferrule[\WaitRule]{
                \wtp{P}{\Context}
            }{
                \wtp{\Wait\x.P}{x : \Bot, \Context}
            }
            \and
            \inferrule[\CloseRule]{~}{
                \wtp{\Close\x}{x : \One}
            }
            \and
            \inferrule[\CaseRule]{
                \wtp{P}{y : A, \Context}
                \\
                \wtp{Q}{y : B, \Context}
            }{
                \wtp{\Case\x\y{P}{Q}}{x : A \With B, \Context}
            }
            \and
            \inferrule[\SelectRule]{
                \wtp{P}{y : A_i, \Context}
            }{
                \wtp{\Select\x{\InTag_i}\y.P}{x : A_1 \Plus A_2, \Context}
            }
            \and
            \inferrule[\JoinRule]{
                \wtp{P}{y : A, z : B, \Context}
            }{
                \wtp{\Join\x\y\z.P}{x : A \Par B, \Context}
            }
            \and
            \inferrule[\ForkRule]{
                \wtp{P}{y : A, \ContextC}
                \\
                \wtp{Q}{z : B, \ContextD}
            }{
                \wtp{\Fork\x\y\z{P}{Q}}{x : A \Ten B, \ContextC, \ContextD}
            }
            \and
            \inferrule[\ExistsRule]{
                \wtp{P}{y : B\subst{A}\X, \Context}
            }{
                \wtp{\Exists\x{A}\y.P}{x : \exists\X.B, \Context}
            }
            \and
            \inferrule[\ForallRule]{
                \wtp{P}{y : A, \Context}
            }{
                \wtp{\Forall\x\X\y.P}{x : \forall\X.A, \Context}
            }
            ~X\not\in\fn\Context
            \and
            \inferrule[\ServerRule]{
                \wtp{P}{y : A, \WhyNot\Context}
            }{
                \wtp{\Server\x\y.P}{x : \OfCourse A, \WhyNot\Context}
            }
            \and
            \inferrule[\ClientRule]{
                \wtp{P}{y : A, \Context}
            }{
                \wtp{\Client\x\y.P}{x : \WhyNot A, \Context}
            }
            \and
            \inferrule[\WeakenRule]{
                \wtp{P}\Context
            }{
                \wtp{P}{x : \WhyNot A, \Context}
            }
            \and
            \inferrule[\ContractRule]{
                \wtp{P}{y : \WhyNot A, z : \WhyNot A, \Context}
            }{
                \wtp{P}{x : \WhyNot A, \Context}
            }
            \and
            \inferrule[\CutRule]{
                \wtp{P}{x : A, \ContextC}
                \\
                \wtp{Q}{x : \dual{A}, \ContextD}
            }{
                \wtp{\Cut[A]\x{P}{Q}}{\ContextC, \ContextD}
            }
        \end{mathpar}
    \end{tabular}
\end{table}

Typing judgments have the form $\wtp{P}\Context$ meaning that the process $P$ is
well typed in the context $\Context$. Equivalently, the judgment indicates that
the sequent $\wtp{}\Context$ is derivable and $P$ is a \emph{proof term}
corresponding to the derivation for $\wtp{}\Context$.
%
The typing rules are shown in \Cref{tab:typing-rules}. Since they are in
one-to-one correspondence with -- and have exactly the same structure of -- the
proof rules of classical linear logic, the reader may refer to the standard
literature on linear logic or propositions as sessions~\citep{Wadler14} for
their interpretation.

% \begin{example}
%     \label{ex:typing-booleans}
%     Below we show the typing derivation for the process
%     $\Cut[\Bool]{x}{\TrueP(x)}{\NotP(x,y)}$ defined in \Cref{ex:booleans}, where
%     we have elided some obvious sub-derivations.
%     \[
%         \begin{prooftree}
%             \[
%                 \[
%                     \justifies
%                     \wtp{
%                         \Close{x'}
%                     }{
%                         x' : \One
%                     }
%                     \using\CloseRule
%                 \]
%                 \justifies
%                 \wtp{
%                     \TrueP(x)
%                 }{
%                     x : \Bool
%                 }
%                 \using\SelectRule
%             \]
%             \[
%                 \[
%                     \[
%                         \mathstrut\smash\vdots
%                         \justifies
%                         \wtp{
%                             \FalseP(y)
%                         }{
%                             y : \Bool
%                         }
%                     \]
%                     \justifies
%                     \wtp{
%                         \Wait{x'}.\FalseP(y)
%                     }{
%                         x' : \Bot,
%                         y : \Bool
%                     }
%                     \using\WaitRule
%                 \]
%                 \[
%                     \mathstrut\smash\vdots
%                     \justifies
%                     \wtp{
%                         \Wait{x'}.\TrueP(y)
%                     }{
%                         x' : \Bot,
%                         y : \Bool
%                     }
%                 \]
%                 \justifies
%                 \wtp{
%                     \NotP(x,y)
%                 }{
%                     x : \dual\Bool,
%                     y : \Bool
%                 }
%                 \using\CaseRule
%             \]
%             \justifies
%             \wtp{
%                 \Cut[\Bool]{x}{\TrueP(x)}{\NotP(x,y)}
%             }{
%                 y : \Bool
%             }
%             \using\CutRule
%         \end{prooftree}
%     \]
% \end{example}

\begin{example}
    \label{ex:echo}
    In this example we define a polymorphic echo server:
    \[
        \EchoP(x) \eqdef
        \Server\x\y.
        \Forall\y\X{y'}.
        \Join{y'}\u{y''}.
        \Fork{y''}\v{y'''}{\Link\u\v}{\Close{y'''}}
    \]

    The server accepts requests on the shared channel $x$. Each request
    established a new session, initially represented by the channel $y$. The
    session consists in receiving the type $X$ of the value being echoed
    followed by the value itself $u$. The value is then sent back unchanged and
    the session is terminated. Note the succession of different (linear)
    channels $y, y', y'', y'''$ that chain the session together.

    We establish that $\EchoP(x)$ is well typed with the following derivation
    \[
        \begin{prooftree}
            \[
                \[
                    \[
                        \[
                            \justifies
                            \wtp{
                                \Link\u\v
                            }{
                                u : X,
                                v : \dual\X
                            }
                            \using\LinkRule
                        \]
                        \[
                            \justifies
                            \wtp{
                                \Close{y'''}
                            }{
                                y''' : \One
                            }
                            \using\CloseRule
                        \]
                        \justifies
                        \wtp{
                            \Fork{y''}\v{y'''}{\Link\u\v}{\Close{y'''}}
                        }{
                            u : X,
                            y'' : \dual\X \Ten \One
                        }
                        \using\ForkRule
                    \]
                    \justifies
                    \wtp{
                        \Join{y'}\u{y''}.
                        \Fork{y''}\v{y'''}{\Link\u\v}{\Close{y'''}}
                    }{
                        y' : X \Par (\dual\X \Ten \One)
                    }
                    \using\JoinRule
                \]
                \justifies
                \wtp{
                    \Forall\y\X{y'}.
                    \Join{y'}\u{y''}.
                    \Fork{y''}\v{y'''}{\Link\u\v}{\Close{y'''}}
                }{
                    y : \forall\X.X \Par (\dual\X \Ten \One)
                }
                \using\ForallRule
            \]
            \justifies
            \wtp{
                \EchoP(x)
            }{
                x : \OfCourse(\forall\X.X \Par (\dual\X \Ten \One))
            }
            \using\ServerRule
        \end{prooftree}
    \]
    %
    where the side condition of the rule \ForallRule is trivially satifised
    since the typing context does not contain bindings other than the one for
    $y$.
    %
    \eoe
\end{example}

\subsection{Properties of Well-Typed Processes}
\label{sec:properties}

The \emph{linearity challenge}~\citep{CarboneEtAl24} aims at formalising two
essential properties of well-typed processes: (1) typing is preserved by
reductions; (2) the peer endpoints of the same session are always used in
complementary ways. This latter property is called \emph{well formedness} in the
challenge. In this work we also consider \emph{deadlock freedom}, which is more
general than well formedness and holds for \Calculus since its type system is
based on linear logic. We now formulate these properties using the notation
developed so far.

Concerning the preservation of typing, this corresponds to the usual subject
reduction result, which is expressed thus:

\begin{theorem}[subject reduction]
    \label{thm:red}
    If $P \red Q$ then $\wtp{P}\Context$ implies $\wtp{Q}\Context$.
\end{theorem}

In order to formulate deadlock freedom, we first need to introduce some
terminology for referring to processes that are unable to make any progress. A
simple example of deadlock is the process $\Cut\x{\Close\x}{\Close\x}$. This
process is unable to reduce (because a process $\Close\x$ is meant to interact
with a process of the form $\Wait\x.P$) and, more generally, it is unable to
interact regardless of the context in which it occurs because the sub-processes
it contains are blocked on the channel $x$ that is restricted by the cut.
%
In general, the property of being a deadlock is not simply the inability to
reduce: there are irreducible processes that are not a deadlock because they
would be able to reduce if put into a suitable context. For example, $\Wait\x.P$
does not reduce, and yet it is not a deadlock because it would be able to make
progress when composed in parallel with $\Close\x$. Even a process like
$\Cut\y{\Wait\y.P}{\Wait\z.Q}$ where $x\ne y,z$ cannot be considered a deadlock,
because the prefixes $\Wait\y$ and $\Wait\z$ could be exposed using \SWait and
possibly \SComm. Let us make all this more precise.

We say that $P$ is a \emph{thread} if it is anything but a cut. In other words,
a thread is either a link or a process that starts with an input/output action
of some sort. Note that a thread may contain cuts, but these cuts must all
guarded underneath the topmost action prefix of the thread.
%
We say that $P$ is \emph{observable} if $P \pcong Q$ for some thread $Q$. An
observable process is a process that exposes an action on a free channel and
therefore can interact through that channel, if put into some appropriate
context. We say that $P$ is \emph{reducible} if $P \red Q$ for some $Q$. A
reducible process may perform a reduction step.
%
We say that a process is \emph{alive} if it is either observable or reducible
and that it is a \emph{deadlock} if it is not alive.

Well-typed \Calculus processes are deadlock free:

\begin{theorem}[deadlock freedom]
    \label{thm:df}
    If $\wtp{P}\Context$ then $P$ is alive.
\end{theorem}

We now shift the attention to \emph{well formedness}. In the linearity
challenge~\cite{CarboneEtAl24} this property ensures that, whenever two
processes composed in parallel begin with actions concerning the very same
session, then such actions complement each other, in the sense that they
describe opposite forms of interaction. To define well formedness in our
setting, we introduce \emph{reduction contexts} as partial processes with a
single unguarded hole $\Hole$, thus:
\[
    \ReductionContext ::= \Hole \mid \Cut[A]\x\ReductionContext{P} \mid \Cut[A]\x{P}\ReductionContext
\]

As usual, we write $\ReductionContext[P]$ for the process obtained by replacing
the hole in $\ReductionContext$ with $P$, noting that such replacement may
capture channels that are bound in $\ReductionContext$ and occur free in $P$.
%
Now we observe that if $Q_1$ and $Q_2$ both act on the same channel $x$ in
complementary ways, then their parallel composition $\Cut\x{Q_1}{Q_2}$ is
reducible according to one of the principal cut reductions described in
\Cref{tab:semantics}. Therefore, an alternative (and more general) way of
formulating well formedness is simply this:
%
we say that $P$ is \emph{well formed} if $P \pcong \ReductionContext[Q]$ implies
that $Q$ is alive. In the particular case when $Q = \Cut\x{Q_1}{Q_2}$ and both
$Q_1$ and $Q_2$ start with an action on $x$, then $Q$ is not observable (because
actions on $x$ cannot be pulled out of the cut that binds $x$) and therefore it
must be reducible by \Cref{thm:df}.

Well-typed processes are well formed:

\begin{theorem}[type safety]
    \label{thm:type-safety}
    If $\wtp{P}\Context$ then $P$ is well formed.
\end{theorem}

Note that the properties expressed in \Cref{thm:df,thm:type-safety} are
invariant under reductions thanks to \Cref{thm:red}.
