

LF lctx : nat → type =
| nil : lctx zero
| cons : lctx N → obj → tp → mult → lctx (suc N);


LF cx_eq : lctx N → lctx N → type =
| cx/refl : cx_eq Δ Δ;



LF merge : lctx N → lctx N → lctx N → type =
| mg/n : merge nil nil nil
| mg/c : merge Δ₁ Δ₂ Δ → • α₁ α₂ α → merge (cons Δ₁ X A α₁) (cons Δ₂ X A α₂) (cons Δ X A α);


LF upd : lctx N → nat → obj → obj → tp → tp → mult → mult → lctx N → type =
| upd/t : {Δ:lctx N} upd (cons Δ X A α) (suc N) X X' A A' α α' (cons Δ X' A' α')
| upd/n : upd Δ n X X' A A' α α' Δ' → upd (cons Δ Y B β) n X X' A A' α α' (cons Δ' Y B β);


LF exh : lctx _ → type =
| exh/n : exh nil
| exh/c : exh Δ → hal α → exh (cons Δ _ _ α);


LF same_elts: lctx N → lctx N → type =
| se/n : same_elts nil nil
| se/c : same_elts Δ Δ' → same_elts (cons Δ X A _) (cons Δ' X A _);



LF exch : lctx N → nat → obj → nat → obj → lctx N → type =
| exch/u : neq n m → upd Δ n X Y A B α β Δ'' → upd Δ'' m Y X B A β α Δ' → exch Δ n X m Y Δ';


LF lookup : obj → tp → mult → lctx _ → type =
| look : upd Δ _ X X A A α α Δ → lookup X A α Δ;


LF lookup_n : obj → lctx _ → type =
| lookn : upd Δ _ X _ _ _ _ _ _ → lookup_n X Δ;


LF lookup_in : nat → obj → lctx _ → type =
| lookin : upd Δ n X X A A α α Δ → lookup_in n X Δ;


LF lookup_int : nat → obj → tp → lctx _ → type =
| lookint : upd Δ n X X A A α α Δ → lookup_int n X A Δ;


LF lookup_intm : nat → obj → tp → mult → lctx _ → type =
| lookintm : upd Δ n X X A A α α Δ → lookup_intm n X A α Δ;



inductive Wf : (Ψ:ctx) {Δ:[Ψ ⊢ lctx k]} ctype =
| Wf/n : Wf [_ ⊢ nil]
| Wf/c : Wf [_ ⊢ Δ] → ([_ ⊢ lookup_n #p Δ] → [ ⊢ false]) → Wf [_ ⊢ cons Δ #p _ _];


inductive VarCtx : (Ψ:ctx) {Δ:[Ψ ⊢ lctx k]} ctype =
| VCtx/n : VarCtx [_ ⊢ nil]
| VCtx/c : VarCtx [_ ⊢ Δ] → VarCtx [_ ⊢ cons Δ #p _ _];