\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Nat
open import Data.Fin
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; cong; congâ‚‚)
open import Agda.Builtin.Equality.Rewrite
\end{code}

\subsection{Type Representation}
\label{sec:type-agda}

The representation of types is standard. We start by defining an indexed data
type $\AgdaDatatype{PreType}~n$ to represents (\LCC) types in the scope of $n$
quantifiers and we use elements of $\AgdaDatatype{Fin}~n$ as de Bruijn indices
for the quantified type variables. In this way, we make sure that pre-types are
well scoped.

\begin{code}
data PreType : â„• â†’ Set where
  âŠ¤ ğŸ˜ âŠ¥ ğŸ™          : âˆ€{n} â†’ PreType n
  var rav          : âˆ€{n} â†’ Fin n â†’ PreType n
  _&_ _âŠ•_ _â…‹_ _âŠ—_  : âˆ€{n} â†’ PreType n â†’ PreType n â†’ PreType n
  `âˆ€ `âˆƒ            : âˆ€{n} â†’ PreType (suc n) â†’ PreType n
  `! `?            : âˆ€{n} â†’ PreType n â†’ PreType n
\end{code}

Note the constructors \AgdaInductiveConstructor{var} and
\AgdaInductiveConstructor{rav}, which respectively represent type variables and
their dual, and the quantifiers \AgdaInductiveConstructor{`âˆ€} and
\AgdaInductiveConstructor{`âˆƒ} which increase the number of quantifiers in the
scoped pre-type.

The dual of a pre-type is computed by the following function:

\begin{code}
dual : âˆ€{n} â†’ PreType n â†’ PreType n
dual âŠ¤        = ğŸ˜
dual ğŸ˜        = âŠ¤
dual âŠ¥        = ğŸ™
dual ğŸ™        = âŠ¥
dual (var x)  = rav x
dual (rav x)  = var x
dual (A & B)  = dual A âŠ• dual B
dual (A âŠ• B)  = dual A & dual B
dual (A â…‹ B)  = dual A âŠ— dual B
dual (A âŠ— B)  = dual A â…‹ dual B
dual (`âˆ€ A)   = `âˆƒ (dual A)
dual (`âˆƒ A)   = `âˆ€ (dual A)
dual (`! A)    = `? (dual A)
dual (`? A)    = `! (dual A)
\end{code}

It is straightforward to prove that duality is an involution.

\begin{code}
dual-inv : âˆ€{n} {A : PreType n} â†’ dual (dual A) â‰¡ A
\end{code}
\begin{code}[hide]
dual-inv {_} {âŠ¤} = refl
dual-inv {_} {ğŸ˜} = refl
dual-inv {_} {âŠ¥} = refl
dual-inv {_} {ğŸ™} = refl
dual-inv {_} {var x} = refl
dual-inv {_} {rav x} = refl
dual-inv {_} {A & B} = congâ‚‚ _&_ dual-inv dual-inv
dual-inv {_} {A âŠ• B} = congâ‚‚ _âŠ•_ dual-inv dual-inv
dual-inv {_} {A â…‹ B} = congâ‚‚ _â…‹_ dual-inv dual-inv
dual-inv {_} {A âŠ— B} = congâ‚‚ _âŠ—_ dual-inv dual-inv
dual-inv {_} {`âˆ€ A} = cong `âˆ€ dual-inv
dual-inv {_} {`âˆƒ A} = cong `âˆƒ dual-inv
dual-inv {_} {`! A} = cong `! dual-inv
dual-inv {_} {`? A} = cong `? dual-inv
\end{code}

This property is important in the rest of the formalisation so we define an
implicit rewriting rule that Agda can autonomously apply whenever possible. This
is achieved by means of the following pragma directive.\footnote{The directive
is effective provided that the option \texttt{{-}{-}rewriting} is enabled,
either globally when invoking Agda or within an \AgdaPragma{OPTIONS} pragma
directive in the module's source code.}

\begin{code}
{-# REWRITE dual-inv #-}
\end{code}

\begin{code}[hide]
ext : âˆ€{m n} â†’ (Fin m â†’ Fin n) â†’ Fin (suc m) â†’ Fin (suc n)
ext Ï zero = zero
ext Ï (suc k) = suc (Ï k)

rename : âˆ€{m n} â†’ (Fin m â†’ Fin n) â†’ PreType m â†’ PreType n
rename Ï âŠ¤ = âŠ¤
rename Ï ğŸ˜ = ğŸ˜
rename Ï âŠ¥ = âŠ¥
rename Ï ğŸ™ = ğŸ™
rename Ï (var x) = var (Ï x)
rename Ï (rav x) = rav (Ï x)
rename Ï (A & B) = rename Ï A & rename Ï B
rename Ï (A âŠ• B) = rename Ï A âŠ• rename Ï B
rename Ï (A â…‹ B) = rename Ï A â…‹ rename Ï B
rename Ï (A âŠ— B) = rename Ï A âŠ— rename Ï B
rename Ï (`âˆ€ A) = `âˆ€ (rename (ext Ï) A)
rename Ï (`âˆƒ A) = `âˆƒ (rename (ext Ï) A)
rename Ï (`! A) = `! (rename Ï A)
rename Ï (`? A) = `? (rename Ï A)

exts : âˆ€{m n} â†’ (Fin m â†’ PreType n) â†’ Fin (suc m) â†’ PreType (suc n)
exts Ïƒ zero = var zero
exts Ïƒ (suc k) = rename suc (Ïƒ k)
\end{code}

Next we define the function \AgdaFunction{subst} that simultaneously substitutes
the type variables of a pre-type with other pre-types. In practice we will
always substitute one variable at a time, but it is technically easier to define
\AgdaFunction{subst} so that it accepts a function substituting \emph{all}
variables of a pre-type, possibly with themselves. The definition of
\AgdaFunction{subst} relies on some auxiliary functions for \emph{renaming} type
variables and \emph{lifting} substitutions across quantifiers. These functions
are straightforward adaptations of those described by \citet{KokkeSiekWadler20}.

\begin{code}
subst : âˆ€{m n} â†’ (Fin m â†’ PreType n) â†’ PreType m â†’ PreType n
\end{code}
\begin{code}[hide]
subst Ïƒ âŠ¤ = âŠ¤
subst Ïƒ ğŸ˜ = ğŸ˜
subst Ïƒ âŠ¥ = âŠ¥
subst Ïƒ ğŸ™ = ğŸ™
subst Ïƒ (var x) = Ïƒ x
subst Ïƒ (rav x) = dual (Ïƒ x)
subst Ïƒ (A & B) = subst Ïƒ A & subst Ïƒ B
subst Ïƒ (A âŠ• B) = subst Ïƒ A âŠ• subst Ïƒ B
subst Ïƒ (A â…‹ B) = subst Ïƒ A â…‹ subst Ïƒ B
subst Ïƒ (A âŠ— B) = subst Ïƒ A âŠ— subst Ïƒ B
subst Ïƒ (`âˆ€ A) = `âˆ€ (subst (exts Ïƒ) A)
subst Ïƒ (`âˆƒ A) = `âˆƒ (subst (exts Ïƒ) A)
subst Ïƒ (`! A) = `! (subst Ïƒ A)
subst Ïƒ (`? A) = `? (subst Ïƒ A)
\end{code}

Among all substitutions, we will use the one that substitutes the 0-indexed type
variable with a pre-type. It is convenient to introduce this substitution once
and for all, which we do here.

\begin{code}
[_/] : âˆ€{n} â†’ PreType n â†’ Fin (suc n) â†’ PreType n
[ A /] zero     = A
[ A /] (suc k)  = var k
\end{code}

Duality and substitutions are meant to commute.

\begin{code}
dual-subst : âˆ€{m n} {Ïƒ : Fin m â†’ PreType n} {A : PreType m} â†’
             subst Ïƒ (dual A) â‰¡ dual (subst Ïƒ A)
\end{code}
\begin{code}[hide]
dual-subst {_} {_} {Ïƒ} {âŠ¤} = refl
dual-subst {_} {_} {Ïƒ} {ğŸ˜} = refl
dual-subst {_} {_} {Ïƒ} {âŠ¥} = refl
dual-subst {_} {_} {Ïƒ} {ğŸ™} = refl
dual-subst {_} {_} {Ïƒ} {var x} = refl
\end{code}

It is worth looking at one case in the proof of \AgdaFunction{dual-subst},
namely when the type is a dualised type variable:

\begin{code}
dual-subst {_} {_} {Ïƒ} {rav x} = refl
\end{code}

Here we are supposed to prove
$\AgdaFunction{subst}~\sigma~(\AgdaFunction{dual}~(\AgdaInductiveConstructor{rav}~x))
  \equiv
  \AgdaFunction{dual}~(\AgdaFunction{subst}~\sigma~(\AgdaInductiveConstructor{rav}~x))$
  which is definitionally equal to $\sigma~x \equiv
  \AgdaFunction{dual}~(\AgdaFunction{dual}~(\sigma~x))$.
%
We could easily prove this equivalence by invoking \AgdaFunction{dual-inv}, but
thanks to the rewriting rule that we have added earlier a use of
\AgdaInductiveConstructor{refl} suffices. In this case the saved effort is
negligible, but in later results, where it is necessary to use
\AgdaFunction{dual-inv} for rewriting part of the \emph{index} of some type
families, having an implicit rewriting rule allows us to avoid writing some
quite obscure Agda code.

\begin{code}[hide]
dual-subst {_} {_} {Ïƒ} {A & B} = congâ‚‚ _âŠ•_ (dual-subst {Ïƒ = Ïƒ} {A}) (dual-subst {Ïƒ = Ïƒ} {B})
dual-subst {_} {_} {Ïƒ} {A âŠ• B} = congâ‚‚ _&_ (dual-subst {Ïƒ = Ïƒ} {A}) (dual-subst {Ïƒ = Ïƒ} {B})
dual-subst {_} {_} {Ïƒ} {A â…‹ B} = congâ‚‚ _âŠ—_ (dual-subst {Ïƒ = Ïƒ} {A}) (dual-subst {Ïƒ = Ïƒ} {B})
dual-subst {_} {_} {Ïƒ} {A âŠ— B} = congâ‚‚ _â…‹_ (dual-subst {Ïƒ = Ïƒ} {A}) (dual-subst {Ïƒ = Ïƒ} {B})
dual-subst {_} {_} {Ïƒ} {`âˆ€ A} = cong `âˆƒ (dual-subst {Ïƒ = exts Ïƒ} {A})
dual-subst {_} {_} {Ïƒ} {`âˆƒ A} = cong `âˆ€ (dual-subst {Ïƒ = exts Ïƒ} {A})
dual-subst {_} {_} {Ïƒ} {`! A} = cong `? (dual-subst {Ïƒ = Ïƒ} {A})
dual-subst {_} {_} {Ïƒ} {`? A} = cong `! (dual-subst {Ïƒ = Ïƒ} {A})
\end{code}

Just like \AgdaFunction{dual-inv}, \AgdaFunction{dual-subst} too is key in the
formalisation that follows. Therefore, we add it to the set of implicit
rewriting rules used by Agda so that we do not have to think about this property
again.

\begin{code}
{-# REWRITE dual-subst #-}
\end{code}

We call \AgdaDatatype{Type} closed pre-types, those having no free type
variables. From now on, we will seldom use pre-types again.

\begin{code}
Type : Set
Type = PreType zero
\end{code}
