\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Nat
open import Data.Fin
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; cong; congâ‚‚)
open import Agda.Builtin.Equality.Rewrite
\end{code}

\subsection{Type Representation}
\label{sec:type-agda}

The representation of types is fairly standard, with one constructor for each of
the forms described in \Cref{sec:calculus}. We use de Bruijn indices for
denoting type variables and we make sure that types are well-scoped by indexing
them with the number of variables that must be bound.

\begin{code}
data PreType : â„• â†’ Set where
  ğŸ˜ ğŸ™ âŠ¥ âŠ¤          : âˆ€{n} â†’ PreType n
  var rav          : âˆ€{n} â†’ Fin n â†’ PreType n
  Â¡ Â¿              : âˆ€{n} â†’ PreType n â†’ PreType n
  _&_ _âŠ•_ _âŠ—_ _â…‹_  : âˆ€{n} â†’ PreType n â†’ PreType n â†’ PreType n
  $âˆ€ $âˆƒ            : âˆ€{n} â†’ PreType (suc n) â†’ PreType n
\end{code}

Note the constructors \AgdaInductiveConstructor{var} and
\AgdaInductiveConstructor{rav}, which respectively represent type variables and
their dual, and the quantifiers \AgdaInductiveConstructor{\$âˆ€} and
\AgdaInductiveConstructor{\$âˆƒ} which increase the number of bound variables in
the scoped (pre)type.

The dual of a (pre)type is computed by the following \emph{function}
\AgdaFunction{dual}.

\begin{code}
dual : âˆ€{n} â†’ PreType n â†’ PreType n
dual ğŸ˜        = âŠ¤
dual ğŸ™        = âŠ¥
dual âŠ¥        = ğŸ™
dual âŠ¤        = ğŸ˜
dual (var x)  = rav x
dual (rav x)  = var x
dual (Â¡ A)    = Â¿ (dual A)
dual (Â¿ A)    = Â¡ (dual A)
dual (A & B)  = dual A âŠ• dual B
dual (A âŠ• B)  = dual A & dual B
dual (A âŠ— B)  = dual A â…‹ dual B
dual (A â…‹ B)  = dual A âŠ— dual B
dual ($âˆ€ A)   = $âˆƒ (dual A)
dual ($âˆƒ A)   = $âˆ€ (dual A)
\end{code}

It is straightforward to prove that duality is a an involution.

\begin{code}
dual-inv : âˆ€{n} {A : PreType n} â†’ dual (dual A) â‰¡ A
\end{code}
\begin{code}[hide]
dual-inv {_} {ğŸ˜} = refl
dual-inv {_} {ğŸ™} = refl
dual-inv {_} {âŠ¥} = refl
dual-inv {_} {âŠ¤} = refl
dual-inv {_} {var x} = refl
dual-inv {_} {rav x} = refl
dual-inv {_} {Â¡ A} = cong Â¡ dual-inv
dual-inv {_} {Â¿ A} = cong Â¿ dual-inv
dual-inv {_} {A & B} = congâ‚‚ _&_ dual-inv dual-inv
dual-inv {_} {A âŠ• B} = congâ‚‚ _âŠ•_ dual-inv dual-inv
dual-inv {_} {A âŠ— B} = congâ‚‚ _âŠ—_ dual-inv dual-inv
dual-inv {_} {A â…‹ B} = congâ‚‚ _â…‹_ dual-inv dual-inv
dual-inv {_} {$âˆ€ A} = cong $âˆ€ dual-inv
dual-inv {_} {$âˆƒ A} = cong $âˆƒ dual-inv
\end{code}

In fact, this property is so important in the rest of the formalization that it
is worth defining an implicit rewriting rules so that Agda can autonomously
apply it whenever possible. This is achieved by means of the following pragma
directive.

\begin{code}
{-# REWRITE dual-inv #-}
\end{code}


