\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Sum using (inj₁; inj₂)
open import Data.Product using (_,_)
open import Data.List.Base using ([]; _∷_; [_]; _++_)
open import Data.List.Properties using (++-assoc)
open import Relation.Unary
open import Relation.Binary.PropositionalEquality using (sym)

open import Type
open import Context
open import Permutations
open import Process
open import Congruence
\end{code}

\subsection{Reduction}
\label{sec:reduction-agda}

\begin{code}[hide]
weakening : ∀[ Un ∗ Proc ⇒ Proc ]
weakening (un ⟨ p ⟩ P) = ↭proc (↭concat p) (aux un P)
  where
    aux : ∀{Γ₁ Γ₂} (un : Un Γ₁) → Proc Γ₂ → Proc (Γ₁ ++ Γ₂)
    aux un-[] P = P
    aux (un-∷ un) P = weaken (ch ⟨ < ≫ ⟩ aux un P)

contraction : ∀{Γ Γ₁ Γ₂} (un : Un Γ₁) → Γ ≃ Γ₁ + Γ₂ → Proc (Γ₁ ++ Γ) → Proc Γ
contraction un p P = ↭proc (↭concat p) (aux un (↭proc (↭left (↭sym (↭concat p))) P))
  where
    aux : ∀{Γ₁ Γ₂} → Un Γ₁ → Proc (Γ₁ ++ Γ₁ ++ Γ₂) → Proc (Γ₁ ++ Γ₂)
    aux un-[] P = P
    aux {`? A ∷ Γ₁} {Γ₂} (un-∷ un) P with contract (ch ⟨ < ≫ ⟩ (↭proc (↭shift {`? A} {`? A ∷ Γ₁} {Γ₁ ++ Γ₂}) P))
    ... | P₁ rewrite sym (++-assoc (`? A ∷ Γ₁) Γ₁ Γ₂) with ↭proc (↭sym (↭shift {`? A} {Γ₁ ++ Γ₁})) P₁
    ... | P₂ rewrite ++-assoc Γ₁ Γ₁ (`? A ∷ Γ₂) with aux un P₂
    ... | P₃ = ↭proc ↭shift P₃
\end{code}

Just like structural precongruence, reduction is formalised as a binary relation
between processes that are well typed in the very same typing context. Thus, the
definition of reduction embeds the subject reduction result.

\begin{code}
data _↝_ {Γ} : Proc Γ → Proc Γ → Set where
\end{code}

There is a constructor for each of the reduction rules in \Cref{tab:semantics}.
Let us comment a representative selection of them.

The constructor \AgdaInductiveConstructor{r-link} models the reduction
$\Cut[A]\x{\Link\x\y}{P} \red P\subst\y\x$ called \RLink in
\Cref{tab:semantics}:

\begin{code}
  r-link      : ∀{Δ A P} (p : Γ ≃ [ dual A ] + Δ) →
                cut {A} (link (ch ⟨ < > • ⟩ ch) ⟨ p ⟩ P) ↝ ↭proc (↭concat p) P
\end{code}

The splitting $p$ indicates that $y$ (of type $\dual{A}$) occurs on the left
sub-process of the cut (that is the link $\Link\x\y$) and the splitting
$(\AgdaInductiveConstructor{<}~\AgdaInductiveConstructor{>}~\AgdaInductiveConstructor{•})$
to which \AgdaInductiveConstructor{link} is applied is structured consistently
with the syntax of the link $\Link\x\y$ being reduced, which is oriented so that
the restricted channel $x$ occurs on the left. 
%
The process $P$ has type
$\AgdaDatatype{Proc}~(\AgdaFunction{dual}~A~\AgdaInductiveConstructor{∷}~\ContextD)$,
and turns into $P\subst\y\x$ after the reduction. The type
$\AgdaFunction{dual}~A$ of $x$ in $P$ is the first in the typing context,
indicating that it is the newest channel that $P$ is aware of. However, after
the reduction, $x$ is replaced by $y$ which is found \emph{somewhere} within
$\Context$. The exact location of $y$ in $\ContextC$ is found in the splitting
$p$, thus we ``rename'' $x$ into $y$ within $P$ using the permutation
$\AgdaFunction{↭concat}~p$.

The constructor \AgdaInductiveConstructor{r-close} models \RClose:

\begin{code}
  r-close     : ∀{P} (p₀ q₀ : Γ ≃ [] + Γ) →
                cut (close ch ⟨ p₀ ⟩ wait (ch ⟨ < q₀ ⟩ P)) ↝ P
\end{code}

While the \AgdaInductiveConstructor{close} constructor implicitly refers to the
only free channel occurring in a process of the form $\Close\x$, the
\AgdaInductiveConstructor{wait} constructor uses a splitting proof of the form
$(\AgdaInductiveConstructor{<}~q_0)$ to be sure that the referenced channel is
also the restricted one, and therefore matches the one of the
\AgdaInductiveConstructor{close} process.

Note that \AgdaInductiveConstructor{r-close} (and several other reduction
constructors) quantifies over $p_0$ and $q_0$ which both prove the splitting
$\Context \simeq \AgdaInductiveConstructor{[]} + \Context$. Since the left
context is empty, these splittings must be equal and made of a sequence of
\AgdaInductiveConstructor{>} applications followed by
\AgdaInductiveConstructor{•}. In general, Agda will not be able to ``see'' that
they are definitionally equal, hence it is easier to quantify them separately so
that we do not have to worry about proving their equality whenever we wish to
apply this reduction.

The constructor \AgdaInductiveConstructor{r-select-l} models \RSelect when the
selected tag is $\InTag_1$:

\begin{code}
  r-select-l  : ∀{Γ₁ Γ₂ A B P Q R}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) →
                cut {A ⊕ B} (select (ch ⟨ < p₀ ⟩ inj₁ P) ⟨ p ⟩
                             case (ch ⟨ < q₀ ⟩ (Q , R))) ↝ cut (P ⟨ p ⟩ Q)
\end{code}

There is not much to note here except again for the multiple quantifications
over the trivial splittings $\Context_i \simeq \AgdaInductiveConstructor{[]} +
\Context_i$ and the use of \AgdaInductiveConstructor{<} to make sure that the
channel referred to by \AgdaInductiveConstructor{select} and
\AgdaInductiveConstructor{case} is indeed the one restricted by the cut.

\begin{code}[hide]
  r-select-r  : ∀{Γ₁ Γ₂ A B P Q R}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) →
                cut {A ⊕ B} (select (ch ⟨ < p₀ ⟩ inj₂ P) ⟨ p ⟩
                             case (ch ⟨ < q₀ ⟩ (Q , R))) ↝ cut (P ⟨ p ⟩ R)
  r-fork      : ∀{Γ₁ Γ₂ Γ₃ Δ A B P Q R}
                (p : Γ ≃ Δ + Γ₃) (p₀ : Γ₃ ≃ [] + Γ₃) (q : Δ ≃ Γ₁ + Γ₂) (q₀ : Δ ≃ [] + Δ) →
                let _ , p′ , q′ = +-assoc-l p q in
                cut {A ⊗ B} (fork (ch ⟨ < q₀ ⟩ (P ⟨ q ⟩ Q)) ⟨ p ⟩
                             join (ch ⟨ < p₀ ⟩ R)) ↝ cut (P ⟨ q′ ⟩ cut (Q ⟨ > p′ ⟩ R))
  r-client    : ∀{Γ₁ Γ₂ A P Q}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) (un : Un Γ₂) →
                cut {`? A} (client (ch ⟨ < p₀ ⟩ P) ⟨ p ⟩ server (ch ⟨ < q₀ ⟩ (un , Q))) ↝
                cut (P ⟨ p ⟩ Q)
  r-weaken    : ∀{Γ₁ Γ₂ A P Q}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) (un : Un Γ₂) →
                cut {`? A} (weaken (ch ⟨ < p₀ ⟩ P) ⟨ p ⟩ server (ch ⟨ < q₀ ⟩ (un , Q))) ↝
                weakening (un ⟨ +-comm p ⟩ P)
  r-contract  : ∀{Γ₁ Γ₂ A P Q}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) (un : Un Γ₂) →
                cut {`? A} (contract (ch ⟨ < p₀ ⟩ P) ⟨ p ⟩ server (ch ⟨ < q₀ ⟩ (un , Q))) ↝
                contraction un (+-comm p) (cut (server (ch ⟨ < q₀ ⟩ (un , Q)) ⟨ ++≃+ ⟩
                                           cut (server (ch ⟨ < q₀ ⟩ (un , Q)) ⟨ > +-comm p ⟩ P)))
\end{code}

The remaining constructors that describe the base reductions follow a similar
pattern, noting that the implementation of \RWeaken and \RContract makes use of
auxiliary functions that respectively weaken and contract the typing context of
the resulting process as shown in \Cref{tab:semantics}. It is worth glancing at
the implementation of \RExists since it involves a non-trivial rewriting of
types:

\begin{code}
  r-exists     : ∀{A B Γ₁ Γ₂ P F}
                 (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) →
                 cut {`∃ A} (ex {A} {B} (ch ⟨ < p₀ ⟩ P) ⟨ p ⟩ all (ch ⟨ < q₀ ⟩ F)) ↝
                 cut (P ⟨ p ⟩ F B)
\end{code}

Recalling the definitions of \AgdaInductiveConstructor{ex} and
\AgdaInductiveConstructor{all} from \Cref{sec:process-agda}, we note that $P$
has type
$\AgdaDatatype{Proc}~(\AgdaFunction{subst}~[~B~/]~A~\AgdaInductiveConstructor{∷}~\Context_1)$
and $(F~B)$ is a process of type
$\AgdaDatatype{Proc}~(\AgdaFunction{subst}~[~B~/]~(\AgdaFunction{dual}~A)~\AgdaInductiveConstructor{∷}~\Context_2)$.
In order for these two process to be composable in a cut, it must be the case
that $\AgdaFunction{subst}~[~B~/]~(\AgdaFunction{dual}~A) \equiv
\AgdaFunction{dual}~(\AgdaFunction{subst}~[~B~/]~A)$, which was proved in
\Cref{sec:type-agda} under the name \AgdaFunction{dual-subst}. Thanks to the
implicit rewriting rule, we do not have to rewrite the index in the type of
$(F~B)$, which is silently accepted as is.

Reduction is closed under cuts and by structural pre-congruence as per \RCut and
\RCong. The corresponding constructors that model these features are shown
below:

\begin{code}
  r-cut        : ∀{Γ₁ Γ₂ A P Q R} (q : Γ ≃ Γ₁ + Γ₂) →
                 P ↝ Q → cut {A} (P ⟨ q ⟩ R) ↝ cut (Q ⟨ q ⟩ R)
  r-cong       : ∀{P R Q} → P ⊒ R → R ↝ Q → P ↝ Q
\end{code}
