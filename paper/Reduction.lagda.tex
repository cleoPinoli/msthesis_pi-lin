\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Product using (_×_; _,_; ∃; Σ; Σ-syntax; ∃-syntax)
open import Relation.Binary.PropositionalEquality using (_≡_; refl; sym; cong; cong₂)
open import Data.List.Base using (List; []; _∷_; [_]; _++_)
open import Data.List.Properties using (++-assoc)

open import Type
open import Context
open import Permutations
open import Process
open import Congruence
\end{code}

\subsection{Reduction}
\label{sec:reduction-agda}

\begin{code}[hide]
weakening : ∀{Γ Γ₁ Γ₂} (un : Un Γ₁) → Γ ≃ Γ₁ + Γ₂ → Process Γ₂ → Process Γ
weakening un p P = ↭process (↭concat p) (aux un P)
  where
    aux : ∀{Γ₁ Γ₂} (un : Un Γ₁) → Process Γ₂ → Process (Γ₁ ++ Γ₂)
    aux un-[] P = P
    aux (un-∷ un) P = weaken (< ≫) (aux un P)

contraction : ∀{Γ Γ₁ Γ₂} (un : Un Γ₁) → Γ ≃ Γ₁ + Γ₂ → Process (Γ₁ ++ Γ) → Process Γ
contraction un p P = ↭process (↭concat p) (aux un (↭process (↭left (↭sym (↭concat p))) P))
  where
    aux : ∀{Γ₁ Γ₂} → Un Γ₁ → Process (Γ₁ ++ Γ₁ ++ Γ₂) → Process (Γ₁ ++ Γ₂)
    aux un-[] P = P
    aux {`? A ∷ Γ₁} {Γ₂} (un-∷ un) P with contract (< ≫) (↭process (↭shift {`? A} {`? A ∷ Γ₁} {Γ₁ ++ Γ₂}) P)
    ... | P₁ rewrite sym (++-assoc (`? A ∷ Γ₁) Γ₁ Γ₂) with ↭process (↭sym (↭shift {`? A} {Γ₁ ++ Γ₁})) P₁
    ... | P₂ rewrite ++-assoc Γ₁ Γ₁ (`? A ∷ Γ₂) with aux un P₂
    ... | P₃ = ↭process ↭shift P₃
\end{code}

Just like structural precongruence, reduction is formalized as a binary relation
between processes that are well typed in the very same typing context. Thus, the
definition of reduction embeds the subject reduction result.

\begin{code}
data _↝_ {Γ} : Process Γ → Process Γ → Set where
\end{code}

There is a constructor for each of the reduction rules in \Cref{tab:semantics}.
Let us comment a representative selection of them.

The constructor \AgdaInductiveConstructor{r-link} models the reduction
$\Cut[A]\x{\Link\x\y}{P} \red P\subst\y\x$ called \RLink in
\Cref{tab:semantics}:

\begin{code}
  r-link      : ∀{Δ A P} (p : Γ ≃ [ dual A ] + Δ) →
                cut {A} p (link (< > •)) P ↝ ↭process (↭concat p) P
\end{code}

The splitting $p$ indicates that $y$ (of type $\dual{A}$) occurs on the left
sub-process of the cut (that is the link $\Link\x\y$) and the splitting
$(\AgdaInductiveConstructor{<}~\AgdaInductiveConstructor{>}~\AgdaInductiveConstructor{•})$
to which \AgdaInductiveConstructor{link} is applied is structured consistently
with the syntax of the link $\Link\x\y$ being reduced, which is oriented so that
the restricted channel $x$ occurs on the left. 
%
The process $P$ has type
$\AgdaDatatype{Process}~(\AgdaFunction{dual}~A~\AgdaInductiveConstructor{∷}~\ContextD)$,
and turns into $P\subst\y\x$ after the reduction. The type
$\AgdaFunction{dual}~A$ of $x$ in $P$ is the first in the typing context,
indicating that it is the newest channel that $P$ is aware of. However, after
the reduction, $x$ is replaced by $y$ which is found \emph{somewhere} within
$\Context$. The exact location of $y$ in $\ContextC$ is found in the splitting
$p$. We ``rename'' $x$ into $y$ within $P$ using the permutation
$\AgdaFunction{↭concat}~p$.

The constructor \AgdaInductiveConstructor{r-close} models \RClose:

\begin{code}
  r-close     : ∀{P} (p₀ : Γ ≃ [] + Γ) (q₀ : Γ ≃ [] + Γ) →
                cut p₀ close (wait (< q₀) P) ↝ P
\end{code}

While the \AgdaInductiveConstructor{close} constructor implicitly refers to the
only free channel occurring in a process of the form $\Close\x$, the
\AgdaInductiveConstructor{wait} constructor uses a splitting proof of the form
$(\AgdaInductiveConstructor{<}~q_0)$ to be sure that the referenced channel is
also the restricted one, and therefore matches the one of the
\AgdaInductiveConstructor{close} process.

Note that \AgdaInductiveConstructor{r-close} (and several other reduction
constructors) quantifies over $p_0$ and $q_0$ which both prove the splitting
$\Context \simeq \AgdaInductiveConstructor{[]} + \Context$. Since the left
context is empty, these splittings must be equal and made of a sequence of
\AgdaInductiveConstructor{>} applications followed by
\AgdaInductiveConstructor{•}. In general, Agda will not be able to ``see'' that
they are definitionally equal, hence it is easier to quantify them separately so
that we do not have to worry about proving their equality whenever we wish to
apply this reduction.

The constructor \AgdaInductiveConstructor{r-left} models \RSelect when the
selected tag is $\InTag_1$:

\begin{code}
  r-left      : ∀{Γ₁ Γ₂ A B P Q R}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) →
                cut {A ⊕ B} p (left (< p₀) P)
                              (case (< q₀) Q R) ↝ cut p P Q
\end{code}

There is not much more to note here except again for the multiple
quantifications over the trivial splittings $\Context_i \simeq
\AgdaInductiveConstructor{[]} + \Context_i$ and the use of
\AgdaInductiveConstructor{<} to make sure that the channel referred to by
\AgdaInductiveConstructor{left} and \AgdaInductiveConstructor{case} is indeed
the one restricted by the cut.

\begin{code}[hide]
  r-right     : ∀{Γ₁ Γ₂ A B P Q R}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) →
                cut {A ⊕ B} p (right (< p₀) P)
                              (case (< q₀) Q R) ↝ cut p P R
  r-fork      : ∀{Γ₁ Γ₂ Γ₃ Δ A B P Q R}
                (p : Γ ≃ Δ + Γ₃) (p₀ : Γ₃ ≃ [] + Γ₃) (q : Δ ≃ Γ₁ + Γ₂) (q₀ : Δ ≃ [] + Δ) →
                let _ , p′ , q′ = +-assoc-l p q in
                cut {A ⊗ B} p (fork (< q₀) q P Q)
                              (join (< p₀) R) ↝ cut q′ P (cut (> p′) Q R)
  r-client    : ∀{Γ₁ Γ₂ A P Q}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) (un : Un Γ₁) →
                cut {`! A} p (server (< p₀) un P) (client (< q₀) Q) ↝ cut p P Q
  r-weaken    : ∀{Γ₁ Γ₂ A P Q}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) (un : Un Γ₁) →
                cut {`! A} p (server (< p₀) un P)
                             (weaken (< q₀) Q) ↝ weakening un p Q
  r-contract  : ∀{Γ₁ Γ₂ A P Q}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) (un : Un Γ₁) →
                cut {`! A} p (server (< p₀) un P)
                             (contract (< q₀) Q) ↝
                    contraction un p
                      (cut ++≃+ (server (< p₀) un P)
                      (cut (> p) (server (< p₀) un P) Q))
\end{code}

The remaining constructors that describe the base reductions follow a similar
pattern, noting that the implementation of \RWeaken and \RContract makes use of
auxiliary functions that respectively weaken and contract the typing context of
the resulting process as shown in \Cref{tab:semantics}. It is worth glancing at
\RExists since it involves a non-trivial rewriting of types:

\begin{code}
  r-exists     : ∀{A B Γ₁ Γ₂ P F}
                 (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) →
                 cut {`∃ A} p (ex {_} {B} (< p₀) P) (all (< q₀) F) ↝ cut p P (F B)
\end{code}

Recalling the definitions of \AgdaInductiveConstructor{ex} and
\AgdaInductiveConstructor{all} from \Cref{sec:process-agda}, we note that $P$
has type
$\AgdaDatatype{Process}~(\AgdaFunction{subst}~[~B~/\_]~A~\AgdaInductiveConstructor{∷}~\Context_1)$
and $(F~B)$ is a process of type
$\AgdaDatatype{Process}~(\AgdaFunction{subst}~[~B~/\_]~(\AgdaFunction{dual}~A)~\AgdaInductiveConstructor{∷}~\Context_2)$.
In order for these two process to be composable in a cut, it must be the case
that $\AgdaFunction{subst}~[~B~/\_]~(\AgdaFunction{dual}~A) \equiv
\AgdaFunction{dual}~(\AgdaFunction{subst}~[~B~/\_]~A)$, which was proved in
\Cref{sec:type-agda} under the name \AgdaFunction{dual-subst}. Thanks to the
implicit rewriting rule, we do not have to rewrite the index in the type of
$(F~B)$, which is silently accepted as is.

Reduction is closed under cuts and by structural pre-congruence as per \RCut and
\RCong. The corresponding constructors that model these features are shown
below:

\begin{code}
  r-cut        : ∀{Γ₁ Γ₂ A P Q R} (q : Γ ≃ Γ₁ + Γ₂) →
                 P ↝ Q → cut {A} q P R ↝ cut q Q R
  r-cong       : ∀{P R Q} → P ⊒ R → R ↝ Q → P ↝ Q
\end{code}
