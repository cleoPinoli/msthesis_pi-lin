\begin{code}[hide]
open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Product using (_Ã—_; _,_; âˆƒ; âˆƒ-syntax)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; sym; cong; congâ‚‚)
open import Data.List.Base using (List; []; _âˆ·_; [_]; _++_)
open import Data.List.Properties using (++-assoc)

open import Type
open import Context
open import Permutations
open import Process
open import Congruence
\end{code}

\subsection{Reduction}
\label{sec:reduction-agda}

\begin{code}[hide]
weakening : âˆ€{Î“ Î“â‚ Î“â‚‚} (un : Un Î“â‚) â†’ Î“ â‰ƒ Î“â‚ + Î“â‚‚ â†’ Process Î“â‚‚ â†’ Process Î“
weakening un p P = #process (+++# p) (aux un P)
  where
    aux : âˆ€{Î“â‚ Î“â‚‚} (un : Un Î“â‚) â†’ Process Î“â‚‚ â†’ Process (Î“â‚ ++ Î“â‚‚)
    aux un-[] P = P
    aux (un-âˆ· un) P = weaken (split-l +-unit-l) (aux un P)

contraction : âˆ€{Î“ Î“â‚ Î“â‚‚} (un : Un Î“â‚) â†’ Î“ â‰ƒ Î“â‚ + Î“â‚‚ â†’ Process (Î“â‚ ++ Î“) â†’ Process Î“
contraction un p P = #process (+++# p) (aux un (#process (#left (#sym (+++# p))) P))
  where
    aux : âˆ€{Î“â‚ Î“â‚‚} â†’ Un Î“â‚ â†’ Process (Î“â‚ ++ Î“â‚ ++ Î“â‚‚) â†’ Process (Î“â‚ ++ Î“â‚‚)
    aux un-[] P = P
    aux {Â¿ A âˆ· Î“â‚} {Î“â‚‚} (un-âˆ· un) P with contract (split-l +-unit-l) (#process (#shift {Â¿ A âˆ· Î“â‚} {Â¿ A} {Î“â‚ ++ Î“â‚‚}) P)
    ... | Pâ‚ rewrite sym (++-assoc (Â¿ A âˆ· Î“â‚) Î“â‚ Î“â‚‚) with #process (#sym (#shift {Î“â‚ ++ Î“â‚} {Â¿ A})) Pâ‚
    ... | Pâ‚‚ rewrite ++-assoc Î“â‚ Î“â‚ (Â¿ A âˆ· Î“â‚‚) with aux un Pâ‚‚
    ... | Pâ‚ƒ = #process #shift Pâ‚ƒ
\end{code}

Just like structural precongruence, reduction is formalized as a binary relation
between processes that are well typed in the very same typing context. Thus, the
definition of reduction embeds the subject reduction result.

\begin{AgdaAlign}
\begin{code}
data _â†_ {Î“} : Process Î“ â†’ Process Î“ â†’ Set where
\end{code}

There is a constructor for each of the reduction rules in \Cref{tab:semantics}.
Let us comment a representative selection of them.

The constructor \AgdaInductiveConstructor{r-link} models \RLink. 

\begin{code}
  r-link      : âˆ€{Î” A B} {P : Process (B âˆ· Î”)}
                (d : Dual A B) (e : Dual A B) (p : Î“ â‰ƒ B , Î”) â†’
                cut d p (link e (split-l (split-r split-e))) P â† #process (#cons p) P
\end{code}

For generality, the rules quantifies over two proofs $d$ and $e$ of the same
duality relation between $A$ and $B$. Even though such proofs would necessarily
be the same, distinguishing them saves us a proof that they are equal whenever
we want to apply this reduction. 
%
Also note that the splitting
$(\AgdaInductiveConstructor{split-l}~(\AgdaInductiveConstructor{split-r}~\AgdaInductiveConstructor{split-e}))$
to which \AgdaInductiveConstructor{link} is applied is structured consistently
with \Cref{tab:semantics}, where the link $\Link\x\y$ being reduced is oriented
so that the restricted channel $x$ occurs on the left. 
%
Finally, the process $P\subst\y\x$ resulting from the reduction is subject to a
channel substitution in \Cref{tab:semantics}. In the Agda representation of
processes with nameless channels, the same effect is achieved by the permutation
$\AgdaFunction{\#cons}~p$, which ``renames'' (the position of) the free
occurrence of $x$ within $P$ with (the position of) $y$ encoded in the splitting
$p$.

The constructor \AgdaInductiveConstructor{r-close} models \RClose:

\begin{code}
  r-close     : âˆ€{P : Process Î“} (pâ‚€ : Î“ â‰ƒ [] + Î“) (qâ‚€ : Î“ â‰ƒ [] + Î“) â†’
                cut d-ğŸ™-âŠ¥ pâ‚€ close (wait (split-l qâ‚€) P) â† P
\end{code}

While the \AgdaInductiveConstructor{close} constructor implicitly refers to the
only free channel occurring in a process of the form $\Close\x$, the
\AgdaInductiveConstructor{wait} constructor uses a splitting proof of the form
$(\AgdaInductiveConstructor{split-l}~q_0)$ to be sure that the referenced
channel is also the restricted one, and therefore matches the one of the
\AgdaInductiveConstructor{close} process.
%
Just like \AgdaInductiveConstructor{r-link} quantifies over multiple proofs for
the same duality relation, also \AgdaInductiveConstructor{r-close} (and several
other reduction constructors) quantifies over $p_0$ and $q_0$ which both prove
the splitting $\Context \simeq \AgdaInductiveConstructor{[]} + \Context$. Since
the left context is empty, these splittings must be equal and made of a sequence
of \AgdaInductiveConstructor{split-r} applications followed by
\AgdaInductiveConstructor{split-e}, but it is easier to quantify them separately
so that we do not have to worry about proving their equality whenever we wish to
apply this reduction.

The constructor \AgdaInductiveConstructor{r-select-l} models \RSelect when the
selected tag is $\InTag_1$, that is \AgdaInductiveConstructor{true} in Agda:

\begin{code}
  r-select-l  : âˆ€{Î“â‚ Î“â‚‚ A Aâ€² B Bâ€²}
                {P : Process (A âˆ· Î“â‚)} {Q : Process (Aâ€² âˆ· Î“â‚‚)} {R : Process (Bâ€² âˆ· Î“â‚‚)}
                (d : Dual A Aâ€²) (e : Dual B Bâ€²)
                (p : Î“ â‰ƒ Î“â‚ + Î“â‚‚) (pâ‚€ : Î“â‚ â‰ƒ [] + Î“â‚) (qâ‚€ : Î“â‚‚ â‰ƒ [] + Î“â‚‚) â†’
                cut (d-âŠ•-& d e) p
                    (select true (split-l pâ‚€) P)
                    (case (split-l qâ‚€) Q R) â† cut d p P Q
\end{code}

There is not much more to note here (and in other omitted reduction rules),
except again for the multiple quantifications over the trivial splittings
$\Context_i \simeq \AgdaInductiveConstructor{[]} + \Context_i$ and the use of
\AgdaInductiveConstructor{split-l} to make sure that the channel referred to by
\AgdaInductiveConstructor{select} and \AgdaInductiveConstructor{case} is indeed
the one restricted by the cut.

\begin{code}[hide]
  r-select-r  :
    âˆ€{Î“â‚ Î“â‚‚ A Aâ€² B Bâ€²}
    {P : Process (B âˆ· Î“â‚)} {Q : Process (Aâ€² âˆ· Î“â‚‚)} {R : Process (Bâ€² âˆ· Î“â‚‚)}
    (d : Dual A Aâ€²) (e : Dual B Bâ€²) (p : Î“ â‰ƒ Î“â‚ + Î“â‚‚) (pâ‚€ : Î“â‚ â‰ƒ [] + Î“â‚) (qâ‚€ : Î“â‚‚ â‰ƒ [] + Î“â‚‚) â†’
    cut (d-âŠ•-& d e) p
        (select false (split-l pâ‚€) P)
        (case (split-l qâ‚€) Q R) â† cut e p P R

  r-fork      :
    âˆ€{Î“â‚ Î“â‚‚ Î“â‚ƒ Î” A B Aâ€² Bâ€²}
    {P : Process (A âˆ· Î“â‚)} {Q : Process (B âˆ· Î“â‚‚)} {R : Process (Bâ€² âˆ· Aâ€² âˆ· Î“â‚ƒ)}
    (d : Dual A Aâ€²) (e : Dual B Bâ€²) (p : Î“ â‰ƒ Î” + Î“â‚ƒ) (pâ‚€ : Î“â‚ƒ â‰ƒ [] + Î“â‚ƒ)
    (q : Î” â‰ƒ Î“â‚ + Î“â‚‚) (qâ‚€ : Î” â‰ƒ [] + Î”) â†’
    let _ , pâ€² , qâ€² = +-assoc-l p q in
    cut (d-âŠ—-â…‹ d e) p
        (fork (split-l qâ‚€) q P Q)
        (join (split-l pâ‚€) R) â† cut d qâ€² P (cut e (split-r pâ€²) Q R)

  r-client    :
    âˆ€{Î“â‚ Î“â‚‚ A Aâ€²}
    {P : Process (A âˆ· Î“â‚)} {Q : Process (Aâ€² âˆ· Î“â‚‚)} (d : Dual A Aâ€²)
    (p : Î“ â‰ƒ Î“â‚ + Î“â‚‚) (pâ‚€ : Î“â‚ â‰ƒ [] + Î“â‚) (qâ‚€ : Î“â‚‚ â‰ƒ [] + Î“â‚‚) (un : Un Î“â‚) â†’
    cut (d-!-? d) p
      (server (split-l pâ‚€) un P)
      (client (split-l qâ‚€) Q) â† cut d p P Q

  r-weaken    :
    âˆ€{Î“â‚ Î“â‚‚ A Aâ€²}
    {P : Process (A âˆ· Î“â‚)} {Q : Process Î“â‚‚}
    (d : Dual A Aâ€²) (p : Î“ â‰ƒ Î“â‚ + Î“â‚‚) (pâ‚€ : Î“â‚ â‰ƒ [] + Î“â‚) (qâ‚€ : Î“â‚‚ â‰ƒ [] + Î“â‚‚) (un : Un Î“â‚) â†’
    cut (d-!-? d) p
        (server (split-l pâ‚€) un P)
        (weaken (split-l qâ‚€) Q) â† weakening un p Q

  r-contract  :
    âˆ€{Î“â‚ Î“â‚‚ A Aâ€²}
    {P : Process (A âˆ· Î“â‚)} {Q : Process (Â¿ Aâ€² âˆ· Â¿ Aâ€² âˆ· Î“â‚‚)}
    (d : Dual A Aâ€²) (p : Î“ â‰ƒ Î“â‚ + Î“â‚‚) (pâ‚€ : Î“â‚ â‰ƒ [] + Î“â‚) (qâ‚€ : Î“â‚‚ â‰ƒ [] + Î“â‚‚) (un : Un Î“â‚) â†’
    cut (d-!-? d) p
      (server (split-l pâ‚€) un P)
      (contract (split-l qâ‚€) Q) â†
      contraction un p
        (cut (d-!-? d) ++â‰ƒ+
             (server (split-l pâ‚€) un P)
             (cut (d-!-? d) (split-r p) (server (split-l pâ‚€) un P) Q))
\end{code}

Reduction is closed under cuts and by structural pre-congruence as per \RCut and
\RCong. The corresponding constructors that model these features are shown
below:

\begin{code}
  r-cut       : âˆ€{Î“â‚ Î“â‚‚ A B} {P Q : Process (A âˆ· Î“â‚)} {R : Process (B âˆ· Î“â‚‚)}
                (d : Dual A B) (q : Î“ â‰ƒ Î“â‚ + Î“â‚‚) â†’ P â† Q â†’
                cut d q P R â† cut d q Q R

  r-cong      : âˆ€{P R Q : Process Î“} â†’ P âŠ’ R â†’ R â† Q â†’ P â† Q
\end{code}
\end{AgdaAlign}
