\begin{code}[hide]
{-# OPTIONS --rewriting #-}
open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Product using (_×_; _,_; ∃; Σ; Σ-syntax; ∃-syntax)
open import Relation.Binary.PropositionalEquality using (_≡_; refl; sym; cong; cong₂)
open import Data.List.Base using (List; []; _∷_; [_]; _++_)
open import Data.List.Properties using (++-assoc)

open import Type
open import Context
open import Permutations
open import Process
open import Congruence
\end{code}

\subsection{Reduction}
\label{sec:reduction-agda}

\begin{code}[hide]
weakening : ∀{Γ Γ₁ Γ₂} (un : Un Γ₁) → Γ ≃ Γ₁ + Γ₂ → Process Γ₂ → Process Γ
weakening un p P = ↭process (↭concat p) (aux un P)
  where
    aux : ∀{Γ₁ Γ₂} (un : Un Γ₁) → Process Γ₂ → Process (Γ₁ ++ Γ₂)
    aux un-[] P = P
    aux (un-∷ un) P = weaken (< ≫) (aux un P)

contraction : ∀{Γ Γ₁ Γ₂} (un : Un Γ₁) → Γ ≃ Γ₁ + Γ₂ → Process (Γ₁ ++ Γ) → Process Γ
contraction un p P = ↭process (↭concat p) (aux un (↭process (↭left (↭sym (↭concat p))) P))
  where
    aux : ∀{Γ₁ Γ₂} → Un Γ₁ → Process (Γ₁ ++ Γ₁ ++ Γ₂) → Process (Γ₁ ++ Γ₂)
    aux un-[] P = P
    aux {`? A ∷ Γ₁} {Γ₂} (un-∷ un) P with contract (< ≫) (↭process (↭shift {`? A} {`? A ∷ Γ₁} {Γ₁ ++ Γ₂}) P)
    ... | P₁ rewrite sym (++-assoc (`? A ∷ Γ₁) Γ₁ Γ₂) with ↭process (↭sym (↭shift {`? A} {Γ₁ ++ Γ₁})) P₁
    ... | P₂ rewrite ++-assoc Γ₁ Γ₁ (`? A ∷ Γ₂) with aux un P₂
    ... | P₃ = ↭process ↭shift P₃
\end{code}

Just like structural precongruence, reduction is formalized as a binary relation
between processes that are well typed in the very same typing context. Thus, the
definition of reduction embeds the subject reduction result.

\begin{AgdaAlign}
\begin{code}
data _↝_ {Γ} : Process Γ → Process Γ → Set where
\end{code}

There is a constructor for each of the reduction rules in \Cref{tab:semantics}.
Let us comment a representative selection of them.

The constructor \AgdaInductiveConstructor{r-link} models \RLink. 

\begin{code}
  r-link      : ∀{Δ A P} (p : Γ ∋ dual A ⊳ Δ) →
                cut {A} p (link (< > •)) P ↝ ↭process (↭concat p) P
\end{code}

For generality, the rules quantifies over two proofs $d$ and $e$ of the same
duality relation between $A$ and $B$. Even though such proofs would necessarily
be the same, distinguishing them saves us a proof that they are equal whenever
we want to apply this reduction. 
%
Also note that the splitting
$(\AgdaInductiveConstructor{split-l}~(\AgdaInductiveConstructor{split-r}~\AgdaInductiveConstructor{split-e}))$
to which \AgdaInductiveConstructor{link} is applied is structured consistently
with \Cref{tab:semantics}, where the link $\Link\x\y$ being reduced is oriented
so that the restricted channel $x$ occurs on the left. 
%
Finally, the process $P\subst\y\x$ resulting from the reduction is subject to a
channel substitution in \Cref{tab:semantics}. In the Agda representation of
processes with nameless channels, the same effect is achieved by the permutation
$\AgdaFunction{\#cons}~p$, which ``renames'' (the position of) the free
occurrence of $x$ within $P$ with (the position of) $y$ encoded in the splitting
$p$.

The constructor \AgdaInductiveConstructor{r-close} models \RClose:

\begin{code}
  r-close     : ∀{P} (p₀ : Γ ≃ [] + Γ) (q₀ : Γ ≃ [] + Γ) →
                cut p₀ close (wait (< q₀) P) ↝ P
\end{code}

While the \AgdaInductiveConstructor{close} constructor implicitly refers to the
only free channel occurring in a process of the form $\Close\x$, the
\AgdaInductiveConstructor{wait} constructor uses a splitting proof of the form
$(\AgdaInductiveConstructor{split-l}~q_0)$ to be sure that the referenced
channel is also the restricted one, and therefore matches the one of the
\AgdaInductiveConstructor{close} process.
%
Just like \AgdaInductiveConstructor{r-link} quantifies over multiple proofs for
the same duality relation, also \AgdaInductiveConstructor{r-close} (and several
other reduction constructors) quantifies over $p_0$ and $q_0$ which both prove
the splitting $\Context \simeq \AgdaInductiveConstructor{[]} + \Context$. Since
the left context is empty, these splittings must be equal and made of a sequence
of \AgdaInductiveConstructor{split-r} applications followed by
\AgdaInductiveConstructor{split-e}, but it is easier to quantify them separately
so that we do not have to worry about proving their equality whenever we wish to
apply this reduction.

The constructor \AgdaInductiveConstructor{r-select-l} models \RSelect when the
selected tag is $\InTag_1$, that is \AgdaInductiveConstructor{true} in Agda:

\begin{code}
  r-left      : ∀{Γ₁ Γ₂ A B P Q R}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) →
                cut {A ⊕ B} p (left (< p₀) P)
                              (case (< q₀) Q R) ↝ cut p P Q
\end{code}

There is not much more to note here (and in other omitted reduction rules),
except again for the multiple quantifications over the trivial splittings
$\Context_i \simeq \AgdaInductiveConstructor{[]} + \Context_i$ and the use of
\AgdaInductiveConstructor{split-l} to make sure that the channel referred to by
\AgdaInductiveConstructor{select} and \AgdaInductiveConstructor{case} is indeed
the one restricted by the cut.

\begin{code}[hide]
  r-right     : ∀{Γ₁ Γ₂ A B P Q R}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) →
                cut {A ⊕ B} p (right (< p₀) P)
                              (case (< q₀) Q R) ↝ cut p P R
  r-fork      : ∀{Γ₁ Γ₂ Γ₃ Δ A B P Q R}
                (p : Γ ≃ Δ + Γ₃) (p₀ : Γ₃ ≃ [] + Γ₃) (q : Δ ≃ Γ₁ + Γ₂) (q₀ : Δ ≃ [] + Δ) →
                let _ , p′ , q′ = +-assoc-l p q in
                cut {A ⊗ B} p (fork (< q₀) q P Q)
                              (join (< p₀) R) ↝ cut q′ P (cut (> p′) Q R)
  r-client    : ∀{Γ₁ Γ₂ A P Q}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) (un : Un Γ₁) →
                cut {`! A} p (server (< p₀) un P) (client (< q₀) Q) ↝ cut p P Q
  r-weaken    : ∀{Γ₁ Γ₂ A P Q}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) (un : Un Γ₁) →
                cut {`! A} p (server (< p₀) un P)
                             (weaken (< q₀) Q) ↝ weakening un p Q
  r-contract  : ∀{Γ₁ Γ₂ A P Q}
                (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) (un : Un Γ₁) →
                cut {`! A} p (server (< p₀) un P)
                             (contract (< q₀) Q) ↝
                    contraction un p
                      (cut ++≃+ (server (< p₀) un P)
                      (cut (> p) (server (< p₀) un P) Q))
  r-poly       : ∀{A B Γ₁ Γ₂ P F} (p : Γ ≃ Γ₁ + Γ₂) (p₀ : Γ₁ ≃ [] + Γ₁) (q₀ : Γ₂ ≃ [] + Γ₂) ->
                 cut {`∃ A} p (ex {_} {B} (< p₀) P) (all (< q₀) F) ↝ cut p P (F B)
\end{code}

Reduction is closed under cuts and by structural pre-congruence as per \RCut and
\RCong. The corresponding constructors that model these features are shown
below:

\begin{code}
  r-cut        : ∀{Γ₁ Γ₂ A P Q R} (q : Γ ≃ Γ₁ + Γ₂) →
                 P ↝ Q → cut {A} q P R ↝ cut q Q R
  r-cong       : ∀{P R Q} → P ⊒ R → R ↝ Q → P ↝ Q
\end{code}
\end{AgdaAlign}
